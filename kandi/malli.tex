% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{tktltiki2}



% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[hyphens]{url}
\usepackage[pdftex,hidelinks]{hyperref}
\usepackage{amsmath}
\numberwithin{table}{section}

\usepackage{adjustbox}  

\usepackage{floatrow}
\floatsetup[table]{capposition=top}
\usepackage[font={small,it}]{caption}

\usepackage{rotating}

\usepackage{tabularx}

\usepackage[sort]{natbib} %uncomment for a harvard-style
%\usepackage[square,sort,comma,numbers]{natbib}

\usepackage{array}

\usepackage{chngcntr}
\counterwithout{footnote}{section}

% --- Auto Commands ---


% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}




% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:


% testattavuus & arkkitehtuuri
\title{Testattavuus ja ohjelmistoarkkitehtuuri}
\author{Kristian Wahlroos}
\date{\today}
\level{Kandidaatintutkielma}

% ; kenelle, miksi, millaisessa ympäristössä; tutkimuskysymys; tulokset; impakti) 100-200 sanaa

\abstract{Tässä tutkielmassa tarkastellaan ohjelmiston arkkitehtuurin ja testattavuuden suhdetta. Arkkitehtuurisella tasolla tarkasteltavaksi otetaan ohjelmistojärjestelmän rakenne, jota on mahdollista visualisoida erilaisin keinoin. Arkkitehtuurin kuvauksesta pyritään määrittelemään tekijöitä, joita voidaan arvioida sekä metrisinä että laadullisina ominaisuuksina.

Tavoitteena on selvittää, minkä tekijöiden avulla järjestelmän testattavuutta olisi mahdollista tarkastella visuaalisella tasolla. Tämän lisäksi tarkastelu kiinnittyy erilaisiin keinoihin, joiden avulla metriset ja laadulliset ominaisuudet testattavuuden kannalta tulevat mahdollisimman hyvin ilmi. Tutkimuksen tulos voi täten toimia hyvänä ohjenuorana ohjelmoijille ja alustana koodianalyysi-työkaluille.

Tässä tutkielmassa on käytetty pääosin kahdensuuntaista lumipallomenetelmää. Kirjallisuuskatsauksen avulla on ensin etsitty aiheesta merkittäviä tutkimuksia, joiden lähdeluettelon kautta on etsitty paljon viitattuja tutkimuksia. Tämän jälkeen lähteitä on käytetty käänteisesti eli etsitty niitä teoksia, jotka ovat viitanneet löydettyihin teoksiin.

Tutkielman tuloksena on saatu muodostettua seitsemän päätekijää, jotka löytyvät sekä ohjelmistojärjestelmän abstraktimmalta tasolta että konkreettisemmalta luokkatasolta. Osa näistä muodostetuista ominaisuuksista on metrillisiä ominaisuuksia, osa laadullisia. Kaikkia ominaisuuksia on kuitenkin mahdollista tarkastella ohjelmistojärjestelmän rakenteen visuaalisesta kuvauksesta, jonka abstraktiotaso voi vaihdella riippuen siitä, halutaanko jotain tiettyä asiaa painottaa enemmän. Seitsemän päätekijää on kerätty kootusti taulukkoon tämän tutkielman loppuun.

}

% The following can be used to specify keywords and classification of the paper:

\keywords{ohjelmistoarkkitehtuuri, testattavuus, metriikka, näkymä}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):" 
 
%98 D.2.4 D.2.5  D.2.8 
 
 \classification{
	Software and its engineering $\rightarrow$ System description languages 	\\
	Software and its engineering $\rightarrow$ Software defect analysis
 }
% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
%\numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}
\renewcommand*{\harvardand}{\&}
% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}


%\section{Johdanto}
%purkaa auki teknisemmälle yleisölle samalla käsitteitä määritellen tutkimuskysymyksen, ratkaisuille ympäristöstä esiintulevat vaatimukset ja keskeiset käsitteet näiden asioiden esittelemiseksi.

%antaa riittävästi termistöä ja kysymyksenasetteluja, jotta myöhempänä teksissä on mahdollisuus analyysiin ja evaluointiin.
%Keskimmäiset luvut keskittyvät kukin "opettamaan" lukijalle yhden osakysymyksen tai näkökulman käsiteltävään asiaan. Lukujen työnjaon tulisi olla selkeä ja niillä tulee olla selkeä oma rakenteensa, jonka valintaperuste on lukijalle kerrottu.

%Viimeistä edellinen luku on varsinaisen kontribuution koti: vertailu, soveltaminen, osien synteesi ja mahdolliset evaluointimenetelmät ja -tulokset pääroolissa.

Ohjelmistoarkkitehtuuri on ohjelmistojen ymmärtämisen kannalta tärkeä konsepti, josta jokaisen ohjelmoijan pitäisi olla tietoinen, sillä jokaisella ohjelmistojärjestelmällä on oma arkkitehtuurinsa. Järjestelmän arkkitehtuurin voidaan nähdä muodostuvan niistä hallitsevista ominaisuuksista, jotka ovat konkretisoituneet sen elementteihin ja suhteisiin \citep[s. 2]{ISOIEEE42010}. Suunnittelematon arkkitehtuuri eli niin sanottu \textit{Big Ball of Mud} \footnote{Lisätietoa \textit{Big Ball of Mud}-mallista: \url{http://www.laputan.org/mud/}} saattaa pahimmassa tapauksessa olla yksi epäonnistuneen projektin tunnusmerkkejä, kun taas hyvin muodostettu arkkitehtuuri auttaa eri sidosryhmien välisessä kommunikaatiossa ja tekee tuotettavasta ohjelmistojärjestelmästä helposti lähestyttävän. Onnistunut arkkitehtuuri taas helpottaa sekä ohjelmiston testausta että validointia ja on yksi suurimmista onnistumistekijöistä projektin jatkon kannalta. 

Ohjelmistojen ylläpidettävyys lasketaan yhdeksi ei-toiminnalliseksi laatuvaatimukseksi, ja siihen kuuluu vahvasti ohjelmistojen testattavuus \citep{ISO/IEC25010:2011}, joka taas vaatimuksena on lähempänä ohjelmoijaa kuin asiakasta. Testausta tapahtuu ohjelmistojärjestelmän elinaikana useita kertoja, joista  aikaisimmat jo projektin alkumetreillä, kun halutaan evaluoida järjestelmän toiminnallisuutta. Testattavuus taas määrittelee, kuinka hyvin järjestelmään kohdistuva testaus löytää mahdolliset virheet ja kuinka helppo on erilaisia testitapauksia luoda järjestelmää varten. Arkkitehtuurin ja testattavuuden yhteys on kuitenkin hieman häilyvä, vaikka monelle kehittäjälle hyvät käytänteet ovatkin tuttuja esimerkiksi oliopohjaisten järjestelmien arkkitehtuurista. Suuri osa opituista käytänteistä kuitenkin ottaa kantaa vain lähdekooditasolla tapahtuviin ongelmakohtiin, jolloin arkkitehtuurinen puoli saattaa jäädä kokonaan huomioimatta. Tämä tutkielma pyrkii selkeyttämään ohjelmistojärjestelmän rakenteen ja testattavuuden suhdetta sekä sitä, miten testattavuus tulee ilmi ohjelmistoarkkitehtuurissa, kun ohjelmistoarkkitehtuuri nähdään ohjelmistojärjestelmän rakenteena. Tutkielma edellyttää lukijalta tuntemusta olio-ohjelmoinnin paradigmasta, tietoa siitä miten oliopohjaisia järjestelmiä on mahdollista testata sekä hieman ymmärrystä käsitteistä \textit{yksikkötestaus} ja \textit{integraatiotestaus}. 

\subsection{Tutkimuskysymys}
Tutkielma vastaa kysymykseen miten testattavuus näkyy ohjelmistojen arkkitehtuurisella tasolla. Itse kysymys voidaan jakaa vielä tarkentaviin kysymyksiin: mitä on testattavuus ohjelmistojärjestelmissä ja mitkä tekijät siihen vaikuttavat, miten arkkitehtuuria on mahdollista kuvata ja miten ohjelmistojärjestelmän arkkitehtuurista luotu näkymä kertoo jotain järjestelmän testattavuudesta. 

\subsection{Tutkimusmenetelmä}
Tutkimuskysymykseen vastataan kirjallisuuskatsauksen avulla ja tutkimalla mitkä seikat tuovat testattavuutta ohjelmistojärjestelmään. Näiden perusteella pyritään tunnistamaan kriittisiä arkkitehtuurisia ominaisuuksia, joiden avulla testattavuuden tasoa olisi mahdollista tarkastella järjestelmässä. Testattavuuden havaitsemiseen etsitään näkymää nykyisistä menetelmistä kuvata arkkitehtuuria. Näitä menetelmiä ovat pääasiassa erilaisten näkymien ja näkökulmien joukko, joiden avulla on mahdollista tuoda ohjelmistojärjestelmästä esiin joitain sen erityispiirteitä.

Itse tutkimus on rajattu ainoastaan oliopohjaiseen arkkitehtuuriin ja sen erilaisiin kuvaamistapoihin. Testaustavoista on mainittu yksikkö- ja integraatiotestaus, koska niiden oletetaan olevan tuttuja lukijalle. Arkkitehtuurin mallintamisesta on jätetty ADL:t (architecture description languages) pois, koska ne eivät tarjoa visuaalista näkymää arkkitehtuuriin, kuin piirtämiseen keskittyvät mallinnustavat. Myöskään erilaisia arkkitehtuurisia tyylejä ei vertailla tutkimuksessa testattavuuden kannalta, vaan tutkimus keskittyy nimenomaan ohjelmistojärjestelmän konkreettisen rakenteen arvioimiseen testattavuuden kannalta.

\subsection{Tutkimuksen rakenne}

Luvussa \ref{software_architecture_main} käydään läpi ohjelmistoarkkitehtuuria käsitteenä ja luodaan pohja eri kuvaustavoille ohjelmistoarkkitehtuuria varten. Samalla kuvataan miten ja mistä näkymä voidaan luoda ohjelmistojärjestelmälle. Luku \ref{testability_main} tarkentaa testattavuutta laadullisena tekijänä ja pyrkii määrittelemään mitä on testattavuus ohjelmistojärjestelmissä. Luku \ref{arch_testability_main} määrittelee arkkitehtuurin ja testattavuuden välistä suhdetta ja sen lopussa on muodostettu kokoava taulukko tutkielman aikana löydetyistä testattavuuteen vaikuttavista tekijöistä. Viimeinen luku \ref{pondering} esittää kirjoittajan omat pohdinnat ja ehdottaa tutkimuksia tulevaisuuteen. 


\section{Ohjelmistoarkkitehtuuri} \label{software_architecture_main}
Arkkitehtuuri ohjelmistojärjestelmissä on käsite, joka ei ole kovin yksiselitteinen eikä siitä ole yksimielistä määritelmää \citep[s. 363]{solms_what_2012}. 
Ohjelmistoarkkitehtuuri kuitenkin kuvaa vähintään aina abstraktilla tasolla toteutettavaa ohjelmistojärjestelmää niin, että sitä tarkastelevan tahon on mahdollista keskittyä vain suppeeseen alueeseen kerrallaan. Arkkitehtuurin kuvaaminen tapahtuu usein visuaalisella tavalla, koska visuaalisesta mallista on nopea ja helppo saada ulos tarvittava informaatio. Visuaalisen mallin avulla on mahdollista myös nähdä ohjelmistojärjestelmästä sellaista lähdekoodiin piilotettua informaatiota, joka muuten jäisi sen kirjoittaneen kehittäjän omiksi ajatuksiksi.   

\subsection{Ohjelmistojen arkkitehtuuri käsitteenä} \label{ark}
Ohjelmistoarkkitehtuuri voidaan nähdä karkeasti neljästä eri näkökulmasta  \citep[s. 2-7]{gorton_understanding_2011}:  ohjelmiston rakenteen kuvaajana, kuvaajana ohjelmiston komponenttien välisille suhteille, ei-toiminnalliset (non-functional) vaatimukset huomioon ottavana mallina ja yleisenä abstraktiona. 

Toiselta näkökulmalta arkkitehtuuri määritelmänä voidaan jakaa kolmeen eri luokkaan \citep{solms_what_2012}: korkean tason abstraktioon ohjelmistojärjestelmästä, rakenteita sekä ulkoisia ominaisuuksia korostavaan määritelmään ja käsitteistöön sekä rajoitteisiin, joiden puitteissa ohjelmistojärjestelmää kehitetään. Näistä kaksi ensimmäistä määritelmää vastaavat samoja kuin \cite{gorton_understanding_2011} ja niitä voidaan mallintaa erilaisten näkymien ja UML-kaavioiden avulla

\begin{itemize}
	\item korkean tason abstraktioita mallinnetaan erilaisten näkymien kautta tai käyttämällä IEEE:n määrittelemiä käytänteitä
	\item rakenteita korostavassa mallinnuksessa voidaan käyttää UML-kaavioita ja niiden tuomia keinoja abstrahoida järjestelmää.
	
\end{itemize}


Näistä kahdesta määrittelystä ohjelmistoarkkitehtuuri-käsitteen välillä voidaan nähdä merkittävinä tarpeina kuvata ohjelmistojärjestelmän rakenteellisuutta ja kommunikaatiota. Kaikki nämä edellämainitut ominaisuudet on saatava  upotettua ohjelmistojärjestelmästä luotavaan arkkitehtuuriseen malliin niin, että ne vastaavat muun muassa seuraaviin kysymyksiin \citep[s. 31 - 33]{Rozanski:2011:SSA:2072649}: mitkä ovat arkkitehtuurin toiminnalliset elementit; miten nämä elementit kommunikoivat keskenään ja ulkomaailman kanssa; mitä tietoa käsitellään, talletetaan ja esitetään; mitä fyysisiä ja ohjelmallisia elementtejä tarvitaan tukemaan näitä elementtejä.

Arkkitehtuurista luotava malli ei kuitenkaan saisi olla monoliittinen malli, koska arkkitehtuuria ei ole mahdollista kuvata vain yhden mallin avulla \citep{Rozanski:2011:SSA:2072649}. Tämä johtuu siitä, että monoliittinen malli paisuu liian suureksi, jolloin sitä on vaikea kenenkään osapuolen enää ymmärtää ja siitä on vaikeaa löytää arkkitehtuurin tärkeimmät ominaisuudet. Monoliittinen malli on usein myös puutteellinen, jäljessä eikä vastaa enää nykyistä ohjelmistojärjestelmää.  


\subsection{Arkkitehtuurin kuvaus}

Ratkaisu monoliittiseen malliin on jakaa arkkitehtuurin kuvaus useisiin toisiinsa liittyviin näkymiin (views), jotka esittävät jokainen yhden näkökulman (viewpoint) järjestelmän arkkitehtuuriin keräämällä yhteen sekä toiminnalliset piirteet että laadulliset ominaisuudet \citetext{\citealp{Ran:1998:ASV:288408.288438}; \citealp[s. 33-34]{Rozanski:2011:SSA:2072649}; \citealp[s. 8-9]{gorton_understanding_2011}}.

Useiden erilaisten näkymien avulla on helpompi kommunikoida eri sidosryhmien välillä ja ne mahdollistavat järjestelmän tarkastelun vain niiltä osin, jotka tietty sidosryhmä kokee tärkeiksi. Yleisesti voidaan sanoa, että erilaiset näkymät auttavat jakamaan arkkitehtuurin vastuista pienempiin palasiin \citep[s. 2]{Galster:2011:DTC:2031759.2031761}. Vastuiden ja näkymien jakaminen taas auttaa jokaista ohjelmistoarkkitehtuuriin liittyvää prosessia tehden ohjelmistoarkkitehtuurin tarkastelusta, suunnittelusta ja toteutuksesta modulaarisempaa.

%Arkkitehtuurin kuvaaminen sallii myös kommunikoinnin eri sidosryhmien välille ja mahdollistaa järjestelmän tarkastelemisen vain niiltä osin, jotka tiettyä sidosryhmää kiinnostavat \citetext{\citealp[s. 329]{ARaHVeSCiSDu}; \citealp[s. 60]{Brondum:2010:TAV:1833335.1833344}}. Kuvaaminen tapahtuu näkymien avulla, jotka auttavat erottelemaan (separation of concerns) arkkitehtuuria pienempiin palasiin \citep[s. 2]{Galster:2011:DTC:2031759.2031761}. Itse näkymät luodaan käyttämällä ennaltamäärättyjä näkökulmia, jotka edustavat tiettyä tai useampaa sidosryhmälle tärkeää asiaa. 

\subsubsection{Näkymät}
Arkkitehtuuristen näkymien tehtävänä on kuvata tietylle asialle olevat merkitykselliset näkökulmat arkkitehtuurista. Yksi määritelmistä arkkitehtuuriselle näkymälle on Krutchenin 4+1 näkymämalli (4+1 View Model) \citep{krutchen1995}. 

4+1 -mallissa arkkitehtuurin kuvaus muodostetaan neljän näkymän ja yhden tekstuaalisen kuvauksen avulla 

\begin{itemize}
	\item looginen, joka kuvailee järjestelmän rakennetta ja suhteita
	\item prosessinen, joka keskittyy suorituksen kuvaamiseen
	\item fyysinen, joka esittää miten komponentit kuvautuvat fyysiselle laitteistolle
	\item kehityksellinen, joka kuvailee järjestelmän sisäistä toteutusta
	\item skenaariollinen, jonka avulla näkymät liitetään yhteen.
\end{itemize}
 
Muita näkymämalleja arkkitehtuuriin on useita, joista jokainen kuitenkin tuo esille vähintään jollain tavalla ohjelmistojärjestelmän rakennetta ja yhteyksiä. Tästä esimerkkinä on tunnettu \textit{Views and Beyond} -malli \citep{Clements:2002:DSA:599933}. Siinä arkkitehtuurinen malli kuvataan kolmella eri näkymällä

\begin{itemize}
	\item moduuli, joka on rakenteellinen näkymä järjestelmään
	\item komponentit ja konnektorit, jotka kuvailevat järjestelmän toiminnallista puolta ja yhteyksiä
	\item allokaatio, joka kuvaa miten prosessit kuvautuvat laitteistotasolla.
\end{itemize}
 
Näiden kahden esitellyn mallin lisäksi on olemassa joukko eri tarkoituksiin sopivia näkymämalleja, joilla on omat vahvuutensa ja heikkoutensa. Kuitenkin edellä mainituista kahdestakin mallista jo nähdään, että niissä pyritään nostamaan esille järjestelmän rakennetta ja rakenteessa ilmeneviä suhteita, joita muun muassa komponenttien sekä moduulien välillä on.

%Yhteensä viittä eri mallia vertailtiin Mayn tutkimuksessa \citep{may2005survey}. Siinä kartoitettiin mahdollisimman laajaa näkymien muodostamaa näkökulmien joukkoa, jotka kattaisivat mahdollisimman laajalti ohjelmistoarkkitehtuurin aluetta (domain). Vertailtavat arkkitehtuurit olivat 4+1-malli, SEI:n (Software Engineering Institute) \textit{Views and Beyond}-malli, ISO:n (International Organization for Standardization) \textit{Reference Model of Open Distributed Processing}, Siemensin \textit{Four View Model} ja \textit{Rational Architecture Description Specification}. Malleja vertailtiin tutkimalla kuinka niiden tarjoamat näkökulmat painottavat kolmeen eri kategoriaan liittyviä asioita: sidosryhmät, laadulliset tekijät ja rakenteelliset ominaisuudet. Lopulliseen valintaan, joka painotti mahdollisimman laajasti jokaisen osa-alueen ominaisuuksia, otettiin mukaan \textit{Views and Beyond} -mallin kaikki kolme näkymää ja \textit{Rational ADS}:n vaatimukset-näkökulma (requirements viewpoint). Syy, miksi juuri nämä valittiin oli se, että \textit{Views and Beyond} sopii erittäin hyvin mallin pohjaksi, koska se kuvaa järjestelmän rakennetta kattavasti, sen näkökulmat ovat itsenäisiä ja se limittyy kokonaisuudessaan hyvin 4+1-mallin sekä Siemens'n mallin kanssa. Se ei kuitenkaan sisällä tarvittavia näkymiä kuvaamaan eri sidosryhmille tärkeitä asioita esimerkiksi loppukäyttäjiä varten oleva näkymä puuttuu kokonaan. Tämän takia mukaan on otettu \textit{Rational ADS}, jonka vaatimukset-näkökulma koostuu neljästä eri näkymästä: ei-toiminnalliset vaatimukset, alue (domain), käyttötapaus ja käyttökokemus. 



\subsubsection{Näkökulmat}
Näkökulmat liittyvät vahvasti arkkitehtuurisiin näkymiin, koska näkymien avulla halutaaan tuoda jokin näkökulma esille \citep[s. 36-42]{Rozanski:2011:SSA:2072649}. Näkökulma voidaan määritellä olevan kokoelma malleja (patterns), templaatteja sekä konventioita, joiden avulla näkymä pystytään rakentamaan.  Näkökulmien joukko taas voidaan jakaa seitsemään eri osaan: kontekstuaalinen, funktionaalinen, informaatiollinen, samanaikaisuudellinen, tuotannollinen, käyttöönotollinen ja operationaalinen. Näistä keskitytään tämän tutkielman myöhemmässä vaiheessa hieman tuotannollisen sekä funktionaalisuuden näkökulmaan. Tuotannollinen näkökulma on tärkeä siksi, että se ottaa huomioon niiden sidosryhmien asiat, jotka ovat mukana järjestelmän kehityksessä, testauksessa, ylläpidossa ja parantamisessa. Funktionaalinen näkökulma taas painottaa muun muassa järjestelmän suorituksenaikaisia komponentteja ja niiden rajapintoja. Näiden avulla halutaan tuoda esille näkökulma testattavuuden analysoimiseen, jota esimerkiksi kehittäjät voisivat höydyntää.

% 4210 ISO
IEEE:n virallinen määritelmä näkokulmalle on \citep[s. 6]{ISOIEEE42010} \textit{A concern can be framed by more than one
viewpoint.
A view is governed by its viewpoint: the viewpoint establishes the conventions for constructing, interpreting
and analyzing the view to address concerns framed by that viewpoint. Viewpoint conventions can include
languages, notations, model kinds, design rules, and/or modelling methods, analysis techniques and other
operations on views. } Se on määritelmä, jota tullaan käyttämään myös tässä tutkielmassa.


\subsection{Näkymän luominen} % aika turha kappale

Ohjelmistoarkkitehtuuri toimii siltana ohjelmakoodin ja ohjelmalle asetettujen vaatimusten välillä \citep[s. 94]{Garlan:2000:SAR:336512.336537}, joten on luonnollista, että näkymä luodaan näiden pohjalta. Sitä luodessa on myös otettava huomioon kenelle näkymä on tarkoitettu, minkälaisia asioita halutaan näkymän painottavan ja millä abstraktiotasolla näkymän tulisi olla. 


Luotavan näkymän perimmäinen tarkoitus voi esimerkiksi olla, että mahdollisimman paljon halutaan nähdä arkkitehtuurisia ominaisuuksia katsomatta lähdekoodia. Syy tähän voi olla esimerkiksi ettei lähdekoodi ole saatavilla tai se on kehittäjälle liian monimutkaista ja aikaavievää käydä kokonaan läpi ajatuksen kanssa. Toisen kirjoittamaa ohjelmakoodia koetaan yleisesti olevan myös vaikea ymmärtää\footnote{Syitä miksi toisen ohjelmakoodia on vaikea lukea: \url{http://www.preposterousuniverse.com/blog/2013/04/24/why-is-code-hard-to-understand/}}. Tällaiseen näkymän tarpeeseen sopivat esimerkiksi UML:n avulla luodut kaaviot järjestelmän rakenteeesta, joiden avulla erilaisten suhteiden ja rakenteellisten ominaisuuksien tarkastelu helpottuu huomattavasti.

\subsection{UML}

UML eli \textit{Unified Modeling Language} on yksi visuaalinen formalisoitu mallinnuskieli näkymien luomiseen \citep{UML}. Sen avulla ohjelmistoa voidaan mallintaa kolmelta eri näkökulmalta: kehitystä täydentävät mallit, käyttäytymisen kuvaamiseen tarkoitetut mallit ja rakennetta kuvaavat mallit. Käytännössä sen avulla pystytään siis kuvaamaan esimerkiksi jokainen sekä 4+1 -mallin että \textit{Views and Beyond}-mallin näkymä käyttäen hyväksi UML:n 13 erilaista kaaviota. Arkkitehtuurin kuvauksen kannalta relevanteimmat kaaviot ovat luokkakaavio ja komponenttikaavio, koska niiden avulla saadaan kuvattua erittäin tarkasti ja monipuolisesti järjestelmän rakenteellisia ominaisuuksia ja rajoitteita. Luokkakaaviossa huomio keskittyy konkreettisten luokkien ja niiden välisten suhteiden kuvaamiseen, kun taas komponenttikaavio kuvaa korkeammalla tasolla järjestelmää kuvaavia komponentteja, joita yhdistävät erilaiset rajapinnat.   

UML sopii ominaisuuksiensa takia erittäin hyvin oliojärjestelmien kuvaamiseen tarjoamalla tuen muun muassa periytymisen ja rajapintojen kuvaamiselle. Tämän takia se on otettu tässä tutkielmassa erityisasemaan järjestelmän ja sen rakenteen kuvaamisessa.


\section{Testattavuus laadullisena tekijänä} \label{testability_main}
Testattavuus luetaan kuuluvaksi ylläpidettävyyden alle \citep{ISO/IEC25010:2011} ja on täten yksi ohjelmistojärjestelmän laadullisista tekijöistä. Laatuvaatimuksena se ei kuitenkaan ole aina edes kovin näkyvä esimerkiksi asiakkaalle, mutta ohjelmistokehittäjälle se tulee esille useassakin kontekstissa. Vaikeasti testattava järjestelmä on kehittäjälle vaikea ylläpitää ja ylläpidettävyys on tärkeä ominaisuus myös asiakkaalle, koska se tuo järjestelmään vakautta.

% Yksikkö vs integraatio vs regressio testauksessa.
Ohjelmistojärjestelmään kohdistuva testaus voidaan jakaa moneen eri luokkaan, joista kaksi esimerkkiä ovat yksikkö -ja integraatiotestaus. Yksikkötestauksessa varmistetaan järjestelmän komponenttien kuten luokkien toiminnallisuutta itsenäisesti, kun taas integraatiotestauksessa testaus kohdistuu järjestelmän rajapintoihin ja komponenttien yhteistoiminnallisuuteen. Testauksen voidaan nähdä siis löytävän itse viat, mutta testattavuus taas paikat, joissa viat voivat sijaita \citep[s. 19]{Voas:1995:STN:624607.625469}. Testattavuus tukee täten testausta ja testausprosessia, ja sen avulla on mahdollista määritellä myös todennäköisyyttä sille, että järjestelmässä piilevät viat löydetään \citep{voas_improving_1992}. 


\subsection{Testattavuuden arviointi} \label{contro_and_observ}

Testattavuuden arvioimisessa voidaan käyttää hyödyksi kolmea eri parametria \citep[s. 2]{baudry_measuring_2003}: havaittavuus (observability), hallittavuus (controllability) ja vaativuus, joka tarvitaan suorittamaan tietty testi. Havaittavuus määrittelee, kuinka mahdollista testien tuloksia on tarkastella, ja hallittavuus sitä, kuinka paljon testauksen kohteena olevan komponentin tilaan voidaan vaikuttaa. 

Havaittavuus voidaan myös nähdä arvona, joka kertoo kuinka helppo on määrittää vaikuttavatko tietyt syötteet testituloksiin ja hallittavuus vaativuutena tuottaa jokin tietty tulos syötteestä \citep[s. 554]{Freedman:1991:TSC:126218.126229}. 
Hallittavuuden parametrisoimiseen on mahdollista käyttää \textit{domain-to-range} -arvoa eli DRR-arvoa. Sen avulla voidaan havaita tiedon katoamista komponenttien sisällä \citep{Voas:1995:STN:624607.625469} ja se pystytään muodostamaan laskemalla tulosteen (output) suhteellista osuutta syötteen (input) koosta.





\subsection{Testattavuuden parantaminen}


Hyvä testattavuus auttaa järjestelmän ylläpidossa, validoinnissa ja parantaa  laatua \citep[s. 20]{Voas:1995:STN:624607.625469}, joten se on tärkeä ominaisuus ohjelmistojärjestelmissä. Tarkastelu hyvään testattavuuteen voidaan kohdistaa niihin tekijöihin, jotka yleisesti luovat hyvää testattavuutta, jotta saataisiin muodostettua kuva ilman takertumista yksityiskohtiin.


Koska ohjelmistojärjestelmä koostuu sen rakenteen muodostavista komponenteista, voidaan tutkiminen keskittää ensin näihin. Testattavan komponentin ominaisuuksiksi voidaan määritellä \citep{Freedman:1991:TSC:126218.126229}: komponentista luotavat testitapaukset pysyvät pieninä ja ovat helposti luotavissa; komponentin testitapaukset eivät ala toistamaan itseään; komponentin testauksen aikana havaitut ongelmat on helppo jäljittää tiettyihin komponentteihin. Näitä tukemaan voidaan jo ohjelmistojärjestelmän alkuvaiheessa kiinnittää huomiota tekijöihin, jotka saadaan DRR-arvoja analysoimalla \citep{voas_improving_1992} 

\begin{itemize}
	\item ymmärtää toiminnan eriyttämisen mahdollisuus
	\item tunnistaa moduulit, joiden DRR-arvo on korkea ja tehdä ne mahdollisimman pieniksi ja yksinkertaisiksi
	\item tunnistaa rajapinta korkean DRR-arvon moduuleille siten, että rajapinta paljastaa tarpeeksi tietoa komponenttien sisäisestä tilasta
	\item eriyttää korkean DRR-arvon komponentit toisistaan \citep[s. 23]{Voas:1995:STN:624607.625469}.
\end{itemize}


Hyvää testattavuutta on siis mahdollista saavuttaa pelkästään analysoimalla komponentteja yksittäisinä tekijöinä. Huomio voidaan kiinnittää asioihin, kuten kuinka paljon komponentit tukevat itse testausprosessia ja kuinka paljon komponentit ovat riippuvaisia toisistaan. Suuria DRR-arvon komponentteja pitäisi yrittää välttää ja eriyttää toiminnallisuus niin, että mahdollisia ongelmakohtia pystyttäisiin hallitsemaan ja havaitsemaan.




\subsection{Testausta heikentävät ominaisuudet}

Tietyt ominaisuudet vaikuttavat yleisesti ohjelmistojärjestelmissä negatiivisesti testattavuuteen. Tiedon katoaminen on yksi näistä \citep{Voas:1995:STN:624607.625469} ja se voidaan jakaa implisiittisen ja eksplisiittisen  katoamiseen. Implisiittisessä katoamisessa useat eri parametrit samaan kohteeseen tuottavat saman testituloksen, ja eksplisiittisessä tiedon katoamisessa tietoa piilotetaan ulkoiselta näkymältä eli tieto jää tarkastelemattomaksi ominaisuudeksi komponentin sisälle. 

Tiedon piilottaminen on hyvin yleinen tapa olio-ohjelmoinnissa, mutta liiallinen tiedon piilotus tuottaa vaikeuksia testauksessa, koska testauksen hallittavuus heikkenee. %Ohjelmistojärjestelmä voidaan esimerkiksi tarkoituksella suunnitella niin tiiviiksi, että sisäinen tila jää täysin tarkastelemattomaksi. Tällöin testauksen aikana syntyneessä virhetilanteessa on hyvin vaikea sanoa, että mistä päin virhe syntyi ja virheen paikallistaminen saattaa täten viedä aikaa. 
Ongelmat syötteiden ja tulosten tarkastelussa tiedon katoamisen johdosta johtavat helposti tarpeettomiin testeihin, joita on vaikea ymmärtää, ja vaikeasti testattava komponentti sisältää ulos- ja sisääntuloparametrien epäjohdonmukaisuuksia \citep{Voas:1995:STN:624607.625469}. Toisin sanoen vaikeasti testattava komponentti tuottaa eri tuloksia eri ajoilla tai ei ikinä tuota haluttua tulosta, koska sen hallittavuus ja havaittavuus ovat ongelmallisia.   




\subsection{Testattavuuden mittaaminen} \label{testability_measure}


Erilaisia testattavuuteen luokkatasolla vaikuttavia mittareita tutkittu paljon, koska niiden käyttäminen tuo konkretiaa analysoimiseen ja niiden pohjalta on mahdollista tehdä esimerkiksi staattista koodianalyysia suorittavia erillisiä ohjelmia\footnote{Esimerkiksi JArchitect-ohjelman käyttämät metriikat: \url{http://www.jarchitect.com/Metrics##MetricsOnApplication}}. 

Yksikkötestauksen näkökulmasta on Java-pohjaisille ohjelmistojärjestelmille määritetty metriikoita tutkimuksessa, jossa tutkimuksen mittareina käytettiin testitapausten kasvua ja pituutta \citep{Bruntink:2004}. Hieman samanlainen jaottelu tehtiin eräässä toisessa myöhemmässä tutkimuksessa, jossa määriteltiin yleisesti tiettyjä testaukseen vaikuttavia mittareita, joiden suuri arvo korreloi vahvasti huonoon testattavuuteen \citep{Dubey:2011:AMM:2020976.2020983}. Nämä määritetyt tekijät ovat negatiivisia asioita testauksen kannalta, koska esimerkiksi suuri metodien määrä on merkki luokan liiallisesta kompleksisuudesta ja se johtaa testauksen monimutkaistumiseen. Suuri kytkennän määrä vaikeuttaa luokan itsenäistä testaamista, koska luokka käyttää hyvin paljon hyväkseen muiden luokkien toiminnallisuutta. Suuri periytymisaste tuo taas luokalle mahdollisesti paljon perittyjä metodeja, jotka on toteutettu jossain muualla. Tämä voi johtaa helposti siihen, että luokka on riippuvainen erittäin paljon muiden luokkien toteutuksista ja luokan testaaminen vaatii käytännössä koko luokkahierarkian läpikäymisen. 

Neljää korkeamman tason metriikkaa on käytetty laskemaan testattavuutta ohjelmistojärjestelmissä, jotka korreloivat vahvasti edellisten tutkimusten metriikoihin. Niitä voidaan pitää keskeisinä olio-ohjelmoinnin suunnitteluperiaatteina \citep{Khan:2009:MBT:1507195.1507204} ja edellämainituissa tutkimuksissa käytetyistä mittareista voidaankin muodostaa seuraava taulukko, jossa jokaisen mittarin pääidea on kiteytetty ja suhteutettu neljään korkean tason yleismetriikkaan.

\begin{table}[ht]
\centering
	\setlength{\extrarowheight}{4pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{| m{3.5cm} | m{3.5cm} | m{6cm} |}
	\hline
	\textbf{Mittari} & \textbf{Korreloi} & \textbf{Ehdotettu}\\ \hline
	Ulkoiset viittaukset & Kytkentä, Koheesio & \citet{Bruntink:2004}\\ \hline
	Koko (rivit + metodit) & Enkapsulaatio & \citet{Bruntink:2004, Dubey:2011:AMM:2020976.2020983}\\ \hline
	Luokkahierarkien aktivoituminen & Enkapsulaatio & \citet{Dubey:2011:AMM:2020976.2020983}\\ \hline
	Kytkennän määrä & Kytkentä & \citet{Dubey:2011:AMM:2020976.2020983}\\ \hline
	Periytymisaste & Uudelleenkäyttö & \citet{Dubey:2011:AMM:2020976.2020983}\\ \hline
\end{tabular}
		
	\caption{Mittarit pelkistettyinä ja niiden suhteet Khanin ja Mustafan esittämään neljään eri korkean tason metriikkaan. Ehdotettu-sarake kertoo mistä lähteestä mittarin ideat ovat.}
	\label{tab:codeTestability}
	}
\end{table}



\noindent
Taulukkon \ref{tab:codeTestability} on kerätty mittareiden pääideat kaikista kolmesta lähteestä ja niistä voidaan nähdä luokkien näkökulmasta muutama iso tekijä testattavuudessa: koko, itsenäinen toimiminen, riippuvuudet muista luokista ja periytyminen. Mittareista osa on kuitenkin ominaisuuksiltaan sellaisia, joita voidaan mitata suurimmaksi osaksi vain lähdekoodin avulla, ja ne ottavat kantaa testattavuuteen vain yhden luokan näkökulmasta. Tämä vaikeuttaa kokonaisuuden hahmottamista, koska lähdekoodin kautta tulee liikaa irrelevanttia tietoa vaikeuttaen tiedon analysointia. Suuremman kokonaisuuden tarkasteleminen tai keskittyminen vain tiettyyn testausta vaikuttavaan osa-alueeseen vaatii muita keinoja.

\section{Testattavuus arkkitehtuurisella tasolla} \label{arch_testability_main}

Arkkitehtuurisella tasolla testattavuutta voidaan tutkia esimerkiksi komponenttitasolla, jota tukevat hyvin UML-komponenttikaaviot. Tämä käy arkkitehtuurin arvioimiseen testattavuuden kannalta hyvin, koska testattavuus tulee ilmi korkealla tasolla muun muassa integraatiotestauksen aikana, kun sekä komponenttien rajapintojen toimivuus että komponenttien toimivuus pitää validoida \citep[s. 65]{Eickelmann:1996:MOS:243327.243602}. Toinen tapa tutkia testattavuutta arkkitehtuurisella tasolla on UML-luokkakaavioiden avulla. Luokkakaavioiden apuna voidaan käyttää hyväksi esimerkiksi niitä aliluvun \ref{testability_measure} metriikoita, jotka eivät tarvitse lähdekoodia tuekseen. 

Yksittäisten komponenttien, eli luokista koostuvien kokonaisuuksien testattavuutta, on analysoitu erilaisten mallien avulla ja näistä eräs on komponenttien pentagrammimalli \citep{gao_component_2005}. Sen avulla jokaista komponenttia voidaan tarkastella viideltä eri näkökulmalta: havaittavuus, hallittavuus, jäljitettävyys (traceability), tuki testivalmiudelle (test support capability) ja ymmärrettävyys (understandability). Näistä kaksi ensimmäistä ovat ideoiltaan samat kuin aliluvussa \ref{contro_and_observ} ja loput vastaavat muun muassa kysymyksiin: kuinka helppoa on tarkastella komponentin tilaa ulkopuolisena; kuinka hyvin komponentti tukee erilaisia testausstrategioita; kuinka hyvin komponentin tarkoitus ymmärretään, että testejä pystytään luomaan. 
 
On siis hyvä tarkastella testattavuutta arkkitehtuurisella tasolla kahdelta eri näkökulmalta: metriikoista koostuva analyysi ja yksittäisten komponenttien laadullinen tarkastelu. Analyysi ilman metriikoita keskitetään enemmän kokonaisuuksien hahmottamiseen ja ongelmakohtien löytämiseen laadullisten ominaisuuksien pohjalta, kun taas metriikoiden kanssa analyysi on staattista ja painottaa enemmän määrällistä tutkimusta.


\subsection{Hyvä testattavuus arkkitehtuurissa} \label{good_testability}

 
Hyvää testattavuutta arkkitehtuureissa on vaikea määrittää, koska eri järjestelmillä on tiettyyn tarkoitukseen sopiva arkkitehtuuri. Tietyt arkkitehtuuriset tyylit tukevat kuitenkin tiettyjä testausstrategioita \citep{Eickelmann:1996:MOS:243327.243602}, joten on selvää että oikein valittu arkkitehtuurinen tyyli vaikuttaa positiivisesti testattavuuteen. Paljon mielekkäämpää on kuitenkin tarkastella  ominaisuuksia testattavalle arkkitehtuurille, jotta voitaisiin luetella erinäisiä testattavuuteen vaikuttavia tekijöitä.

Oliopohjaisissa ohjelmistojärjestelmissä koetaan vähintään vastuiden jakamisen olevan lähtökohta hyvälle testattavuudelle, koska se parantaa koko järjestelmän havaittavuutta ja hallittavuutta \citep{Binder:1994:DTO:182987.184077}. Suoraan ohjelmistojärjestelmän rakenteelliselta tasolta voidaan huomio keskittää esimerkiksi kapseloinnin, polymorfismin, perinnän ja kompleksisuuden tarkasteluun. 

Järjestelmää suunniteltaessa testauksen varalle, on siihen olemassa erilaisia laadullisia ja metrisiä ominaisuuksia, joihin huomio pitäisi kiinnittää koko ohjelmistoprosessin ajan \citep{joshi_design_2014}. Näiden metriikoiden avulla löydettyjen ongelmakohtien eliminoimiseen voidaan käyttää hyväksi järjestelmän modulaarista rakennetta, joka pitäisi myös olla vallitseva ominaisuus järjestelmässä koko sen elinkaaren ajan. Toinen apukeino on UML ja sen  muokkaaminen stereotyyppien avulla. UML-kaavioiden muokkaus voi tapahtua esimerkiksi luomalla uusia malleja nykyisten pohjalta tai käyttämällä UML:n geneerisiä laajennoskohtia, joiden avulla näkymää saadaan muokattua haluttuun suuntaan.


%Järjestelmän tarkasteltavuus (monitorability) voidaan lukea ohjelmistojärjestelmän yhdeksi ominaisuudeksi, joka nostaa positiivisesti testattavuuden tasoa \citep{mari_impact_2003}. Tarkasteltavuus ohjelmistojärjestelmissä voidaan jakaa kolmeen eri luokkaan: komponentin sisäinen, komponenttien välinen sekä järjestelmätasoinen yhteistoiminnallisuus. Tarkasteltavuutta analysoitaessa huomio voidaan kiinnittää esimerkiksi siihen kuinka hyvin järjestelmän tilaa voidaan tarkastella, testien etenemistä, komponenttien interaktiota sekä testauksen hallinnoimista esimerkiksi tynkäluokkien (stub) avulla. 

%He esittävät 


\begin{table}[H]
	\centering
	\setlength{\extrarowheight}{10pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{|l|m{7cm}|m{5cm}|}
	\hline 
	\textbf{Analyysimentelmä} & \textbf{Ominaisuus} & \textbf{Lähde} \\ 
	\hline 
	Laadullinen & Testausominaisuus, jäljitettävyys, vaatimusten tarkkuus, antimallit\footnote{Toistuva ratkaisu johonkin ongelmaan, joka vaikuttaa kuitenkin negatiivisesti laatuun.}, havaittavuus, hallittavuus & \citet{Binder:1994:DTO:182987.184077, joshi_design_2014} \\ 
	\hline 
	Metrinen & Sykliset riippuvuudet, kytkennän taso, koheesion taso &  \citet{joshi_design_2014} \\ 
	\hline 
	\end{tabular} 
	}
	\caption{Hyvään testattavuuteen rakenteellisella tasolla vaikuttavat ominaisuudet jaoteltuna kahteen eri luokkaan: laadulliset ja metriset.}
	\label{tab:goodArchTestability}
\end{table}

\noindent
Taulukossa \ref{tab:goodArchTestability} on koottu yhteen ominaisuudet, jotka ottavat kantaa laadullisiin ja mitattaviin ominaisuuksiin. Niistä nähdään, että on tärkeää tarkastella sekä komponenttien ulkoisia että sisäisiä ominaisuuksia, jotta voitaisiin muodostaa hyvä kuva testattavuuden tasosta. Suoraan ohjelmistojärjestelmän rakenteen näkökulmasta esiin nousevat riippuvuudet, kytkentä ja koheesio.


\subsection{Arkkitehtuurin testattavuuden mittaaminen} \label{arch_testability_measurement}

Ylläpidettävyys on vaikuttava piirre testattavuuteen, joten on luonnollista tarkastella myös sen kautta järjestelmän testattavuutta. Ylläpidettävyyden näkökulmasta on tunnistettu erilaisia arkkitehtuurisen tason mittareita arkkitehtuurisille elementeille ja niiden avulla voidaan mitatata järjestelmän ominaisuuksia, kuten kytkennän ja koheesion tasoa \citep{bengtsson1998towards}.  

\iffalse


\begin{itemize}
	\item metodien määrä elementin rajapinnassa
	\item paikkamerkkien (placeholder) määrä arkkitehtuurisille elementeille, joiden avulla elementti parametrisoidaan
	\item elementistä lähtevien viestien määrä
	\item elementtityyppien määrä, joita tarkasteltava elementti toteuttaa (implement)
	\item elementtien määrä, jotka toteuttavat tarkasteltavan elementin tyypin
	\item saatavilla olevien metodien lukumäärä muista elementeistä, jotka ovat yhteydessä tarkasteltavaan elementtiin
	\item elementin metodien ja parametrien määrä
\end{itemize}
\fi


\begin{table}[H]
	\centering
	\setlength{\extrarowheight}{4pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{|m{10cm}|m{4cm}|}
	\hline 
	\textbf{Mittari} & \textbf{Tarkkuuden taso} \\ 
	\hline 
	Metodien määrä elementin rajapinnassa & Matala \\ 
	\hline 
	Elementin metodien ja parametrien määrä & Matala\\ \hline
	Saatavilla olevat metodit muualta & Matala\\ \hline
	Lähtevien viestien määrä & Matala/Korkea\\ \hline
	Paikkamerkkien (placeholder) määrä & Korkea\\ \hline
	Elementtityyppien määrä, joita tarkasteltava elementti toteuttaa & Korkea\\ \hline
	Elementtien määrä, jotka toteuttavat tarkasteltavan elementin tyypin & Korkea\\ \hline

	\end{tabular} 
	\caption{Mittarit, joiden avulla ylläpidettävyyttä voidaan mitata. Tarkkuuden taso on skaalattu arkkitehtuurin näkökulmasta matalasta korkeaan. Matala tarkoittaa, että kuvaus on lähellä ohjelmakoodia ja korkea, että mittaria pystytään käyttämään myös abstraktimmalla tasolla.}
	\label{tab:maintainMeters}
	}
\end{table}


\noindent
Taulukkoon \ref{tab:maintainMeters} kootuista mittareista nähdään, että mittarit jakautuvat karkeasti kahteen eri tarkkuuden tasoon: matalaan ja korkeaan. Syy siihen on, että arkkitehtuurisen kuvauksen ollessa abstraktio ohjelmakoodista on luonnollista, että eri tarkkuuden tasoilla on mahdollista liikkua. Tunnistetuiden mittareiden ominaisuuksista taas nähdään samankaltaisuutta aliluvun \ref{testability_measure} määriteltyjen mittareiden kanssa, mutta tässä tunnistetut mittarit tarkastelevat korkeampaa tasoa. Kytkentä ja koheesio, joita kummatkin mittarisarjat osittain mittaavat, määriteltiin myös tavoiksi mitata järjestelmän testattavuutta samaisessa aliluvussa. Kytkentää voidaan tutkia analysoimalla ohjelmistojärjestelmän arkkitehtuuristen elementtien välisiä suhteita ja koheesiota tutkimalla kuinka itsenäisiä ne ovat ovat.

\subsubsection{UML-kaaviot testattavuuden mittaamisessa} \label{uml_arch_test}

UML-luokkakaavio toimii hyvänä pohjana, kun halutaan mitata luokkien välisiä suhteita ja riippuvuuksia \citep{baudry_testability_2002} ja sen avulla voidaan määritellä testattavuuden antimalli (testability anti-pattern), joka on luokkakaavioiden avulla esille tuleva ilmiö \citep{baudry_measuring_2003}. Antimallissa kaksi suurta tekijää vaikuttavat testattavuuteen negatiivisesti: luokkien välinen suuri interaktio ja itsekäyttö, jossa luokka on riippuvainen rekursiivisesti itsestään. Syitä näiden kahden esiintymiselle voidaan lukea olevan: luokkien välinen suuri kytkentätaso, riippuvuuksien syklimäisyys ja luokkien välinen suuri kommunikaatiotaso. Yhdessä nämä tekijät vaikeuttavat paljon vastuiden jakamista ja kasvattavat tarvittavien testitapausten määrää \citep{baudry_measuring_2003}. 

Antimallin osatekijöiden löytyminen arkkitehtuurista on siis vihje siitä, että arkkitehtuuri saattaa sisältää testausta vaikeuttavaa rakennetta. Toinen mahdollinen lähestymistapa on tarkastella järjestelmää UML:n avulla luotavalla erityisellä riippuvuusgraafilla \citep{baudry_testability_2002}, jonka avulla nähdään helposti komponenttien välistä riippuvuuksien hajontaa. Riippuvuuksien tunnistaminen sekä vähentäminen on kytkennän kannalta tärkeää, koska kytkennän tasoa voidaan nähdä riippuvuuksien määrästä.  On myös mahdollista tarkastella testauksen kannalta kriittisten riippuvuuksien poistoa analysoimalla pelkästä luokkakaaviosta saatavia ominaisuuksia \citep{Jungmayr:2002}. Tällöin riippuvuudeksi lasketaan mikä tahansa komponenttien välinen interaktio, jossa komponentti joutuu käyttämään toisen komponentin tarjoamia palveluita, jotka ovat usen metodeja, suorittaakseen toiminnallisuuttaan. 

Riippuvuuksiin littyviä tekijöitä voidaan havainnollistaa seuraavan taulukon avulla, jossa jokaiselle testautta vaikeuttavalle ominaisuudelle on annettu myös tapa, jolla ominaisuutta on mahdollista tarkastella.


\begin{table}[H]
	\centering
	\setlength{\extrarowheight}{10pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabularx}{500pt}{|X|X|X|}
	\hline 
	\textbf{Ominaisuus} & \textbf{Tapa havaita} & \textbf{Lähde} \\ 
	\hline 
	Kompleksiset perintäsuhteet & Graafimalli & \citet{baudry_testability_2002} \\ 
	\hline 
	Abstraktien luokkien liikakäyttö rajapintojen sijasta & Graafimalli ja luokkakaavio & \citet{baudry_testability_2002} \\ 
	\hline 
	Metriikat
	\begin{itemize}
		\item Riippuvuuksien määrä komponenteissa 
		\item Komponenttien määrä riippuvuussykleissä
		\item Feedback-riippuvuuksien määrä\footnote{Feedback-riippuvuus on syklinen riippuvuussuhde komponenttien välillä, josta poistamalla jokin riippuvuus saadaan sykli purettua täysin.}
	\end{itemize}	 
	& Graafimalli ja luokkakaavio & \citet{Jungmayr:2002}\\ \hline
	\end{tabularx} 
	\caption{Tekijöitä ongelmallisten riippuvuuksien syntymiselle testattavuuden kannalta.}
	\label{tab:problemDepend}
	}
\end{table}

\noindent
Taulukossa \ref{tab:problemDepend} olevista tekijöistä voidaan nähdä, että riippuvuuksien tarkastelu testattavuuden kannalta on mahdollista UML-kaavion ja siitä luotavan graafimallin avulla. Varsinkin sykliset riippuvuudet tulevat ilmi testattavuutta heikentävänä tekijänä, joiden tarkastelu kooditasolla on hyvin vaikeaa, koska kooditasolla keskitytään vain yhden luokan näkökulmaan ja kokonaisuus voi tällöin jäädä hahmottamatta.

UML on auttanut työkaluna löytämään yhteydellisiä ominaisuuksia arkkitehtuurissa, joita tarkastellessa voidaan sanoa tarkasteltavan  kytkennän tasoa, kompleksisuutta ja riippuvuuksia. Komponenttien sekä yhteyksien tarkastelu oli myös luvussa \ref{ark} esitelty eräs näkemys ohjelmistoarkkitehtuuriin ja on järjestelmän todellisen testattavuuden määrittelemisen kannalta parempi, jos testattavuutta voidaan tarkastella myös korkealla tasolla. Liian tarkka kuvaus järjestelmästä vaikeuttaa todellisten ongelmien näkemistä, koska se vie aikaa ymmärtää ja keskittyy liian pikkutarkkoihin asioihin, jotka eivät kaikki välttämättä ole relevantteja testattavuuden analysoinnin kannalta. Ylätason kuvauksella on etuna myös se, että sen avulla pystytään löytämään helposti usein esiintyviä ongelmallisia tilanteita, joiden tunnistaminen auttaa järjestelmän testattavuuden hallinnassa.


\subsubsection{UML uusien näkymien tukena}


Standardi UML-kaavio ei kuitenkaan itsessään riitä näyttämään kaikkia testattavuuden kannalta tärkeitä näkökulmia arkkitehtuurisella tasolla, mutta sen tueksi on luotu useita menetelmiä, jotka hyödyntävät esimerkiksi jo valmista UML-luokkakaaviota. Eräs näistä on graafimalli eli \textit{class dependency graph model} \citep{baudry_testability_2002}, joka myös aliluvussa \ref{uml_arch_test} mainittiin. Sen avulla on mahdollista nähdä muun muassa luokkien välistä suurta interaktiota, itsekäyttöä, interaktioiden kompleksisuutta, pitkiä luokkahierarkisia haaraumia ja kompleksisia periytymisiä rajapintatasoilla.
Kaikista näistä on mahdollista luoda erilaisia metriikoita ja saada laskettua kytkennän, perinnän ja yleisen kompleksisuuden tasoa testattavuuden näkökulmalta. 

Tämä tuottaa kuitenkin ongelmia, koska jotkut tulokset saattavat olla vääriä niiden sisältäessä virheellistä esiintymää (false-positive results). Tähän ongelmaan on ehdotettu UML-kaavion jatkamista stereotyyppien avulla. Uusia kytköksiä riippuvuuksille ehdotetaan neljä kappaletta \citep[s. 4]{baudry_measuring_2003}

\begin{itemize}
	\item \textit{create}, jos luokka A luo luokan B
	\item \textit{use}, jos luokka A voi kutsua kaikkia B:n metodeja, muttei luo sitä
	\item \textit{use\_consult}, jos A:n kutsumat metodit eivät muokkaa B:n sisäistä tilaa
	\item \textit{use\_def}, jos yksikin A:n kutsuma metodi muokkaa B:n sisäistä tilaa
\end{itemize}

\noindent
Kyseisten stereotyyppien avulla saadaan luokkakaavioissa paremmin esille riippuvuudet ja niiden tyypit virheellisten tuloksien välttämiseksi. On esimerkiksi usein melko normaalia oliojärjestelmissä, että yksi luokka saattaa luoda useita riippuvuuksia muihin luokkiin, mutta tämä on tehty tarkoituksella eikä vahingossa kehittäjien toimesta. Näin on esimerkiksi tehdas-mallin\footnote{Lisätietoa tehdas-mallista: \url{http://www.oodesign.com/factory-pattern.html}} (factory pattern) käytössä, jossa erikseen määritelty tehdas-olio on riippuvainen useiden eri luokkien synnystä. Se vähentää globaalisti riippuvuuksien määrää, mutta itse tehdas-oliot tuottaisivat metriikoiden mukaan paljon virheellisiä riippuvuusongelmia, jos jokainen kaaviossa esiintyvä riippuvuus olisi samanarvoinen.



%\subsection{Erilaiset menetelmät UML-kaavoiden tukena}
%Muita keinoja tutkia -> formulointi (Design Structure Matrix) \citep{mo_mapping_2013}

%Erilaisia skenaariopohjaisia menetelmiä ehdottaa \citep[s. 8-9]{mattsson2006software} testattavuuden kannalta: SAAM, ATAM, EBAE.

%Riippuvuuksien anti-pattern (7 kpl) ja niiden havaitseminen lähdekoodin avulla. Pystyisikö soveltamaan myös arkkitehtuurisella tasolla? \citep{binkley_dependence_2008} 


\subsection{Arkkitehtuuriset hajut ja testattavuus} \label{arch_smells_and_testability}

Arkkitehtuurisiin hajuihin on alettu kinnittämään yhä enemmän huomiota niiden helposti lähestyttävien konkreettisten ominaisuuksiensa vuoksi \citep{de_andrade_architectural_2014}. Ne ovat sukua tutummalle käsitteelle koodihaju, mutta tulevat esille arkkitehtuurisella tasolla, kun koodihajut tulevat esille luokkatasolla ja vaativat melkein aina lähdekoodin tunnistamisen tuekseen. Arkkitehtuuriset hajut ovat pääosin suunnittelupäätöksiä, jotka negatiivisesti vaikuttavat järjestelmän elinkaareen ja muun muassa testattavuuten sekä ylläpidettävyyteen. Niitä ei voi pitää välttämättä virheinä, mutta ne vaikuttavat vähintään aina laatuun huonontavalla tavalla. Syitä arkkitehtuurisille hajuille voidaan nähdä olevan muun muassa: suunnittelumalli väärässä kontekstissa;  suunnitteluabstrahoinnin (design abstraction) käyttö niin, että sillä on ei-toivottuja vaikutuksia; suunnitteluabstrahoinnin käyttö väärällä tarkkuuden tasolla.

Arkkitehtuuristen hajujen tutkimiseen voidaan käyttää analyyttistä lähestymistapaa, koska arkkitehtuuristen hajujen lähtökohtana toimii usein joku virheellinen arkkitehtuurinen päätös. Yleisesti on kuitenkin helpompi tutkia visuaalista informaatiota ja tämän avulla arkkitehtuuriin vaikuttavia hajuja. Seuraavien metriikoiden avulla on mahdollista löytää sekä visuaalisen että analyyttisen tarkastelun avulla arkkitehtuurisia hajuja \citep{bertran_detecting_2011}

\begin{itemize}
	\item ei-haluttujen asiakas-komponenttien (client component) määrä
	\item komponentin vastuiden määrä
	\item komponentin konnektoreiden määrä
	\item komponentin erilaisten konnektoreiden määrä
	\item komponenttien välinen riippuvuuksien hajauma.
\end{itemize}

%\citep{HotSpot} arkkitehtuuriset hajut "hotspotit"\ 5kpl + kaikista altin virheille oli \citep[s. 57]{HotSpot} Unstable Interface \& Cross-Module Cycle.

\noindent
Metriikoista nähdään, että ne mittaavat paljon koheesiota, kytkentää, riippuvuuksia ja vastuita. Näiden metriikoiden avulla sekä näkymällä moduulitasoon, olisi esimerkiksi hyvin mahdollistaa löytää yksi virhealttiillisin arkkitehtuurista löytyvä ongelmakohta \textit{Cross-Module Cycle} \citep[s. 57]{HotSpot}. \textit{Cross-Module Cycle} on olemassa arkkitehtuurissa silloin, kun siinä on syklinen riippuvuussuhde moduulitasolla. Se vaikeuttaa testattavuutta siten, että testauksen aikana yhden moduulin testaaminen vaatii käytännössä myös kaikkien muiden moduulien testauksen, jolloin testitapausten eriyttäminen vaikeutuu huomattavasti. Sykliset riippuvuudet todettiin olevan myös aliluvun \ref{good_testability} yksi testattavuuteen vaikuttava tekijä. Muita arkkitehtuurisia hajuja, jotka suoraan vaikuttavat testattavuuteen, voidaan tunnistaa olevan ainakin kaksi lisää \citep{garcia_identifying_2009}:  \textit{Connector Envy} ja \textit{Scattered Parasitic Functionality}.

\textit{Connector Envy} on tilanne, jossa komponentti toteuttaa konnektorille kuuluvaa toiminnallisuutta eli toteuttaa esimerkiksi joko kommunikointia, koordinointia tai tiedon konversiota. Nämä toiminnallisuudet tulisi jättää konnektorin toteutettavaksi, koska komponentin toiminnallisuus ja interaktiot eivät ole enää erillään testattavia ominaisuuksia. Tilanteena se johtaa siihen, että ei pystytä enää varmasti sanomaan, että mikä kohta komponentissa oli virheellinen, jos se testauksen aikana hajoaa. \textit{Scattered Parasitic Functionality} taas syntyy, jos useammalla komponentilla on sama korkean tason vastuu ja joidenkin näiden komponenttien täytyy toteuttaa myöskin joku oma ortogonaalinen vastuu. Tämä estää komponenttien järkevän yhdistämisen ilman, että uuteen komponettiin tulee parasiitteja eli ylimääräisiä vastuita. Testattavuus kärsii tästä, koska esimerkiksi integraatiotestauksen aikana tapahtunut virhe vaikuttaa laajalla alueella ja vaikeuttaa vian alkuperän määrittämistä. 

Testaukseen vaikuttavista arkkitehtuurisista hajusta voidaan huomata, että ne pyrkivät löytämään sykliset riippuvuudet, huonon koheesion ja riippuvuuksien jakautumisen turhan laajalle. Samat asiat jotka vaikuttavat luokkatasolla testattavuuteen vaikuttavat arkkitehtuurisella tasolla, mutta hieman eri näkökulmasta. Arkkitehtuurisella tasolla tarkasteltavana voi olla usean eri luokan kokonaisuudet eli komponentit tai arkkitehtuuriset elementit, kun luokkatasolla tarkastelun alla voi olla yksittäiset luokat ja jopa yksittäiset metodit.


\subsubsection{Koodihajujen ja arkkitehtuuristen hajujen suhde} \label{hybridsmells}

Arkkitehtuurin ja ohjelmakoodin suhde on luonnollisesti hyvin vahva ja monissa metriikoissakin on nähty samankaltaisuuksia. Tätä suhdetta selittämään on tuotu käsite hybridihajut, jotka ovat sekoitus koodihajuja ja arkkitehtuurisia hajuja, tuoden uuden näkökulman arkkitehtuuristen hajujen löytämiseksi myös testattavuuden kannalta. Koodipoikkeama (code anomaly) luetaan hybridihajuksi, jos sen vaikuttamat luokat ovat vastuussa arkkitehtuurisista elementeistä vaikuttamissa arkkitehtuurisissa elementeissä on arkkitehtuurisia ongelmia \citep{vale_bad_2014}. Hybridihajujen tunnistaminen on siis eräs keino helpottaa arkkitehtuuristen hajujen löytämistä. Löytämällä koodihajujen pohjalta arkkitehtuuriin vaikuttavia ongelmallisia luokkia, voidaan vastaavasti arkkitehtuuriselta tasolla tunnistaa muodostuneita arkkitehtuurisia hajuja. Arkkitehtuuristen hajujen löytäminen saattaa taas antaa tärkeää tietoa pinnan alla piilevistä koodihajuista, joten kumpikin suunta täydentää hyvin toisiaan.

On tutkittu, että tietyt kooditason ongelmat ovat indikaattoreita arkkitehtuurisista hajuista aspektiorientoituneissa järjestelmissä \citep{macia_impact_2011}. Seuraavaan taulukkoon on koottu nämä ongelmat yhteen ja suhteutettu ne testattavuuten vaikuttaviin arkkitehtuurisiin hajuihin.

% EI SELITTÄMÄTTÖMIÄ OSIA


\begin{table}[ht]
	\centering
	\setlength{\extrarowheight}{1pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{| m{5cm} | m{7cm} |}
	\hline 
	\textbf{Arkkitehtuurinen haju} & \textbf{Syy kooditasolla} \\ \hline
	\textit{SPF} & Liikaa vastuita \\ \hline
	\textit{SPF, Connector Envy} & Liikaa suoria vastuita \\ \hline
	\textit{SPF} & Liikaa riippuvuuksia \\ \hline
	\textit{SPF} & Samankaltaista toiminnallisuutta \\ 
	\hline
	\end{tabular}
	}
	\caption{Arkkitehtuurinen haju ja syy sen esiintymiselle kooditasolla.}
	\label{tab:aspectSmells} 
\end{table}


%Koodi ja arkkitehtuuri-info. Detection strategies \citep[s. 179-182]{macia_enhancing_2013}

\noindent
Vaikka taulukon \ref{tab:aspectSmells} koodihajut eivät suoraan koske oliopohjaisia järjestelmiä, niistä voidaan silti nähdä, että ongelmat tulevat liiallisista vastuista, liiallisista riippuvuuksista ja samankaltaisesta toiminnallisuudesta. Nämä ominaisuudet ovat nähtävissä tavallisissakin oliojärjestelmissä, joista on mahdollista määrittää samankaltaisia  arkkitehtuuriherkkiä koodipoikkeamia \citep{macia_enhancing_2013}.

Seuraavassa taulukossa on kerätty oliojärjestelmissä esiintyvät ongelmat ja niiden suorat yhteydet testattavuuteen vaikuttaviin arkkitehtuurisiin hajuihin \citep{macia_enhancing_2013}.

% NÄÄ VOIS SELITTÄÄ ESIM ALAINDEKSISSÄ


\begin{table}[h]
	\centering
	\setlength{\extrarowheight}{1pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{| l | l | m{6cm} |}
	\hline
	\textbf{Koodihaju} & \textbf{Arkkitehtuurinen haju} & \textbf{Syy}\\ \hline
	\textit{God Class}\footnote{Luokka, joka tekee suuren osan järjestelmän toiminnallisuudesta.} & \textit{SPF, Connector Envy} &  Toiminnallisuus liian keskittynyttä, liialliset vastuut\\ \hline
	
	\textit{Misplaced Class}\footnote{Luokka, joka on väärässä moduulissa/komponentissa.} & \textit{Cyclic Dependencies, SPF} & Riippuvuuksia enemmän komponentin ulkopuolelle kuin sisäpuolelle\\ \hline
	\end{tabular}
	}
	\caption{Olioperäisten koodihajujen ja arkkitehtuuristen hajujen suhde, sekä niiden syyt.}
	\label{tab:codeSmells}
\end{table}


\noindent
Taulukon \ref{tab:codeSmells} suhteista nähdään hieman samanlaisuutta, kuin mitä taulukko \ref{tab:aspectSmells} näytti syinä aspektiorientoituneille koodihajuille. Suurimmat ongelmat olioperäisissäkin hajuissa tulivat liiallisista riippuvuuksista ja huonosta vastuiden jaosta, jotka saattavat johtaa yksittäisten komponenttien paisumiseen. Yksittäisten komponenttien paisuminen taas luo helposti huonoa kompositiota ja toistuvaa toiminnallisuutta. Pahimmassa tapauksessa järjestelmässä on vain muutama komponentti, joiden harteilla on iso osa toiminnallisuuden toteuttamisesta. 
Ongelmat kooditasolla täten helposti realisoituvat arkkitehtuurisen tason ongelmiksi, jolloin pienet ongelmat saattavat muodostua suuriksi ja vaikeasti ratkaistaviksi ongelmiksi.


%Koodihajujen tunnistaminen arkkitehtuurisen degraation tunnistamiseksi \citep{fontana_towards_2015}. Vaikuttavat ylläpidettävyyteen. God Class, Data Class, Brain Method, Shotgun Surgery, Dispersed Coupling, Message Chains. Metriikoina käytettiin muun muassa: Tight Class Cohesion, Access to Foreign Data, Number of Public Attributes, Maximum Nesting Level, Coupling Intensity. Co-Occurence of smells. 

Tarkastelu voidaan keskittää myös enemmän aiheisiin kuten mistä koodihajut johtuvat tai mitkä tekijät koodihajuissa vaikuttavat arkkitehtuuristen hajujen esiintymiseen järjestelmissä. Näiden asioiden tarkastelun avuksi on luotu erityisen näkymä koodihajujen tunnistamiseksi ja sen avulla voidaan tunnistaa muun muassa kytkentään ja koheesioon vaikuttavia koodihajuja \citep{fontana_towards_2015}. 

\begin{table}[H]
	\centering
	\setlength{\extrarowheight}{4pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{| m{4cm} | m{8cm} | m{4cm} |}
	\hline
		\textbf{Koodihaju} & \textbf{Vastuussa} & \textbf{Vaikuttaa}\\ \hline
		\textit{God Class} & Suuret luokat & Koheesio \& Kytkentä\\ \hline
		\textit{Long Method} & Pitkät metodit & Koheesio \& Kytkentä\\ \hline
		\textit{Dispersed Coupling} & Laajalle hajautunut kytkentä & Koheesio \& Kytkentä\\ \hline
		\textit{Shotgun Surgery} & Replikoituvasta muutoksen vaatimasta kohdealueesta & Koheesio\\ \hline
	\end{tabular}
	}
	\caption{Suoraan kytkentään ja koheesioon suhteessa olevat koodihajut. }
	\label{tab:coupAndCohes}
\end{table}


\noindent
Taulukon \ref{tab:coupAndCohes} tekijöistä nähdään, että ongelmat syntyvät, jos jollakin luokalla on seuraavia ominaisuuksia: liian suuri koko; riippuvuuksia paljon muihin luokkiin; toiminnallisuus hajautunut niin laajalle, että sen muuttaminen vaatii usean muutoksen eri kohteisiin. Näitä samoja ominaisuuksia on mahdollista tarkastella arkkitehtuurisella tasolla niin, että luokkien sijaan tarkastelu kohdistuu komponentteihin. 

On edellisten tarkasteluiden nojalla siis selvää, että hyvä kytkennän ja koheesion taso ovat tavoteltavia ominaisuuksia sekä kooditasolla että arkkitehtuuritasolla. Merkkittävä tekijöitä arkkitehtuuristen hajujen synnyssä olivat nimittäin vastuut, riippuvuudet, koheesio ja kytkentä. Testattavuuden kannalta ohjelmistojärjestelmän rakennetta voidaan arvioida esiteltyjen arkkitehtuurisiin hajuihin vaikuttavien tekijöiden näkökulmasta ja käyttämällä hyväksi luvussa \ref{arch_testability_measurement} esiteltyjä mittareita.  



\subsection{Havaitut testattavuuteen vaikuttavat tekijät}

Seuraavalla sivulla olevan taulukkoon \ref{tab:conclusions} on kerätty kootusti tutkielman aikana löydetyt tekijät, jotka testattavuuteen vaikuttavat rakenteellisella tasolla eli tasolla, jossa rakennetta pystytään analysoimaan ja arvioimaan erilaisten näkökulmien avulla. Taulukkoon on pyritty keräämään vain keskeisiä asioita, joiden tarkastelu onnistuu sekä arkkitehtuurisella tasolla, että kooditasolla. Kooditasolla tarkastelu voidaan aloittaa tutkimalla löydettyjä ominaisuuksia yksittäisille luokille, jotka ovat sidoksissa vahvasti tärkeisiin arkkitehturaalisiin elementteihin, kun taas arkkitehtuurisella tasolla paino voidaan kiinnittää laajempiin kokonaisuuksiin, kuten komponettien tarkasteluun.  

On kuitenkin huomattava, että ominaisuudet jakautuvat varsinkin järjestelmän tasolla pelkästään laadullisiin ominaisuuksiin, joiden mittaaminen suoraan ei  ole edes kovin mahdollista. Tällöin analyysin avuksi on otettava esimerkiksi dokumentaatiota järjestelmästä, komponenttien suunnittelusta vastuussa olevien ihmisiä, koko komponentin toteuttavaa ryhmää tai yleisesti koottua ryhmää, jonka kanssa komponentteja ja rakennetta tarkastellaan yhdessä. Näin pystytään muodostamaan hyvä kuva pelkästään järjestelmän testattavuuden tasosta ilman metrisiä mittareita, jotka vaativat jotain formalismia taustalleen virheellisten tuloksien minimoimiseksi.

Kaikki muut ominaisuudet ovat kuitenkin sekä laadullisia että mitattavia ominaisuuksia. Metrisinä ne voidaan nähdä siten, että monessa jokin määrällinen ominaisuus korostuu. Esimerkiksi mitä enemmän riippuvuuksia yhdellä luokalla on, sitä enemmän siinä piilee mittarien mukaan ongelmia testattavuuden kannalta. Totuus voi kuitenkin olla toinen ja tämän takia jokainen mittari pitäisikin nähdä enemmän indikaattorina mahdollisille ongelmille. Oikeat ongelmien syyt löytyvät mittareiden osoittamien ongelmakohtien tarkemmalla analyysillä. Tässä analyysissä voidaan miettiä esimerkiksi mitkä tekijät ohjelmistojärjestelmässä ovat luoneet ongelmallisen tilanteen ja löytyykö ongelmaan ratkaisua. 

Olio-ohjelmoinnista on määritelty tiettyjä klassisia metriikoita \citep{chidamber_metricssuite_1994} ja taulukosta löytyvät ominaisuudet heijastelevat vahvasti näiden metriikoiden ideoihin. Testattavuuden analysointi on täten mahdollista samalla, kun arvioidaan järjestelmän muita ei-toiminnallisia vaatimuksia.

\begin{sidewaystable}[htbp]
	\centering
	\captionsetup{width=\columnwidth}
	\setlength{\extrarowheight}{10pt}%
	
		\resizebox{\linewidth}{!}{
	
		\begin{tabular}{| m{5cm} | m{8cm} | m{6cm} | m{6cm} |}
		\hline
	\textbf{Tekijä} & \textbf{Tarkennus} & \textbf{Menetelmä} & \textbf{Lähde}\\ \hline
	
		Järjestelmän ominaisuudet & Komponenttien testattavuus, vastuut, vaatimukset, havaittavuus, hallittavuus, jäljitettävyys  & Analysointi, pentagrammimalli & \citet{Binder:1994:DTO:182987.184077, baudry_measuring_2003, gao_component_2005, joshi_design_2014}  \\ \hline	
	
		Kompleksisuus & Kompleksinen toteutus, kompleksiset perintäsuhteet & Metriikat, UML, Graafimalli & \citet{Binder:1994:DTO:182987.184077, baudry_testability_2002, baudry_measuring_2003, Dubey:2011:AMM:2020976.2020983} \\ \hline	
		
		Perintä & Ongelmalliset ja liialliset perintäsuhteet & Metriikat, UML, Graafimalli & \citet{baudry_testability_2002, Dubey:2011:AMM:2020976.2020983} \\ \hline	
		
		Kytkentä & Itsekäyttö, suuret kytkentätasot & Metriikat, UML, Graafimalli, hajut & \citet{Dubey:2011:AMM:2020976.2020983, joshi_design_2014} \\ \hline		
		
		Riippuvuudet & Syklimäisyys, määrä, antimalli & UML, graafimalli, hajut & \citet{baudry_testability_2002,Jungmayr:2002,joshi_design_2014} \\ \hline
		
		Koheesio & Toiminta huonosti keskitettyä & Metriikat, hajut, analysointi & \citet{garcia_identifying_2009, joshi_design_2014} \\ \hline
		
		Vastuut & Vastuut jakautuneet huonosti & Hajut, UML & \citet{garcia_identifying_2009} \\ \hline
		
		\end{tabular}
		}
		
		\caption{Testattavuuteen vaikuttavat tekijät arkkitehtuurisella tasolla. Tarkennus-sarake antaa lisätietoa menetelmästä ja Menetelmä-sarake kuvaa miten niitä voidaan havaita. Lähde-sarake kertoo mikä tutkimus on tutkinut aihetta ja mahdollisesti esittänyt jonkun menetelmistä.}
	
	\label{tab:conclusions}		
		
	\end{sidewaystable}

\newpage



\section{Pohdinta} \label{pondering}


Testattavuuteen löydetyt tekijät ovat osoittautuneet mielestäni hyvin keskeisiksi oliojärjestelmien ominaisuuksiksi, jotka heijastelevat olio-ohjelmoinnin hyviä käytänteitä. Taulukossa \ref{tab:conclusions} olevien ominaisuuksien huomioon ottaminen ja noudattaminen nostaa ohjelmistojen laatua myös muullakin kuin vain testattavuuden saralla. Esimerkiksi järjestelmän modulaarisuuden parantaminen vaikuttaa sekä muunneltavuuteen että testattavuuteen.

Luvussa \ref{arch_testability_main} esiin tulleet metriikat testattavuudesta ovat hieman vaikeakäyttöisiä oikeissa projekteissa, koska usein järjestelmää ei mallinneta täydellisesti ja saattaa olla, ettei järjestelmän visuaalinen kuvaus noudattele täysin, tai edes etäisesti, UML-standardia. On myös vaikeaa määritellä, että mitä kaikkea pystytään metrisesti löytämään ilman laadullista analyysiä. Ilman metriikoiden osoittamien ongelmakohtien analyysia saatetaan nimittäin helposti joutua tilanteeseen, jossa metriikka on sokea todellisille ongelmille tai hälyttää vääristä virheistä. 

Aliluvussa \ref{arch_smells_and_testability} esille nousseet arkkitehtuuriset hajut ja riippuvuusgraafeista saatava data aliluvussa \ref{uml_arch_test} ovat kuitenkin hyvinkin potentiaalisia keinoja ohjelmistokehittäjän tueksi löytämään ongelmakohtia projekteista. Näiden automatisointi olisi mielestäni hyvin läpimurtavaa ja koen, että itsekin käyttäisin tällaista hyväksi, jos analyysityökalu olisi olemassa. Arkkitehtuurista analyysia suorittavia työkaluja ei tällä hetkellä kovinkaan paljoa ole ja harva edes ottaa huomioon esimerkiksi arkkitehtuurisia hajuja, vaan ne keskittyvät enemmän koodihajuihin ja niiden löytämiseen\footnote{Esimerkkinä analyysityökalu SonarQube: \url{http://www.sonarqube.org}}. Tämä painottuneisuus kuitenkin on todennäköisesti siitä syystä, että arkkitehtuurisia hajuja on hyvin vaikeaa koneellisesti staattisen analyysin keinoin tuoda ilmi, koska ohjelmistojärjestelmän rakenteen taustalla on jokin ihmisen tekemä piilevä päätös, jota ei voida havaita välttämättä kooditasolta ollenkaan.

Testattavuuteen vaikuttavia arkkitehtuurisia hajuja pitäisi mielestäni tutkia lisää ja muodostaa niistä yhtä kattava katalogi, kuin koodihajuista on muodostettu\footnote{Koodihajut katalogina: \url{https://refactoring.guru/catalog}}. Näihin arkkitehtuurisiin hajuihin voitaisiin yhdistää testattavuuteen vaikuttavat hybridihajut aliluvusta \ref{hybridsmells}, jolloin olisi mahdollista löytää arkkitehtuurisia ongelmakohtia kooditasolta alkaen. Näistä olevia tutkimuksia on kuitenkin melko vähän ja vielä harvempi ottaa mukaan edes testattavuutta, joka on harmi koska testaus on tärkeä osa jokaisen ohjelmiston elinkaarta.

Tulevaisuuden tutkimuksista voitaisiinkin painottaa enemmän testattavuuden saralle, koska nyt aiheesta löytyy vaihtelevasti tutkimuksia, jotka painottavat eri asioita. Testattavuutta laatutekijänä pitäisi tutkia enemmän ja varsinkin rakenteen ja jopa eri arkkitehtuuristen tyylien vaikutusta testattavuuteen. 




\section{Yhteenveto}

%Tutkimuksessa on tehty katsaus ensin ohjelmistoarkkitehtuuriin käsitteenä ja luotu sen avulla katsaus siihen miten ohjelmistoarkkitehtuuria mallinnetaan. Ohjelmistoarkkitehtuuri on nähty tapana kuvata järjestelmän todellista rakennetta tavalla, joka kertoisi mahdollisimman selkeästi järjestelmän todellisen luonteen ilman tarvetta lähdekoodille. Katsauksen jälkeen on etsitty vastausta sille mitä on järjestelmän testattavuus. Testattavuudesta on jatkettu tarkastelua arkkitehtuuriselta näkökulmalta ja etsitty tapoja joiden avulla arkkitehtuurin mallinnus tuottaisia mahdollisimman paljon informaatiota järjestelmän testattavuudesta.

Tutkielman tuloksena tutkimuskysymykseen voidaan vastata seuraavalla tavalla. Testattavuus näkyy ohjelmistojen arkkitehtuurissa niinä laadullisina ja metrisinä rakenteellisina ominaisuuksina, jotka korostavat testattavuutta. Laadulliset ominaisuudet voi olla jokin komponentin konkreettinen ominaisuus, joka helpottaa testausprosessia huomattavasti tai se voi olla komponenttien vastuiden ja vaatimusten ymmärtäminen niin, että testausta on helpompi tehdä. Testattavia ominaisuuksia järjestelmälle voidaan määritellä sen havaittavuuden, hallittavuuden ja jäljitettävyyden tasot. Nämä pätevät myös yksittäisiin komponentteihin ja niiden tarjoamiin palveluihin, jotka metodeina ja rajapintoina usein nähdään.

Metrisinä tekijöinä voidaan nähdä rakenteen kompleksisuus, perinnän taso, kytkennän määrä, riippuvuuksien laatu ja määrä, koheesion taso ja vastuiden jakautuminen. Kaikkia näitä on mahdollista tarkastella UML:n luokka- ja komponenttikaavion kaavion sekä riippuvuusgraafin avulla. Hieman toisenlaista analyysiä voidaan tehdä etsimällä visuaalisesta näkymästä testattavuuteen vaikuttavia arkkitehtuurisia hajuja (\textit{Cross-Module Cycle, Connector Ency, Scattered Parasitic Functionality}) ja niihin vaikuttavia hybridihajuja. 


%Tutkielma vastaa kysymykseen miten testattavuus näkyy ohjelmistojen arkkitehtuurisella tasolla. Itse kysymys voidaan jakaa vielä tarkentaviin kysymyksiin: mitä on testattavuus ohjelmistojärjestelmissä ja mitkä tekijät siihen vaikuttavat, miten arkkitehtuuria on mahdollista kuvata, miten ohjelmistojärjestelmän arkkitehtuurista luotu näkymä kertoo jotain järjestelmän testattavuudesta. 


\newpage

%Muistuttaa mieleen tutkimuskysymyksen, mainitsee tärkeimmät tulokset ja niiden perusteet. Keskittyy impaktiin ja esimerkiksi suosituksiin. Ei vain summeeraa luku kerrallaan aikaisempaa tekstiä.


% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

%\bibliographystyle{babalpha-lf}
\bibliographystyle{apsrfin}
\bibliography{references-fi}


% --- Appendices ---

% uncomment the following

% \newpage
% \appendix
% 
% \section{Esimerkkiliite}

\end{document}
