% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage{amsmath}
\numberwithin{table}{section}

\usepackage{adjustbox}  

\usepackage{floatrow}
\floatsetup[table]{capposition=top}
\usepackage[font={small,it}]{caption}

\usepackage{rotating}

\usepackage{tabularx}

\usepackage[sort]{natbib} %uncomment for a harvard-style
%\usepackage[square,sort,comma,numbers]{natbib}

\usepackage{array}

% --- Auto Commands ---



% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:


% testattavuus & arkkitehtuuri
\title{Testattavuus ja ohjelmistoarkkitehtuuri}
\author{Kristian Wahlroos}
\date{\today}
\level{Kandidaatintutkielma}

% ; kenelle, miksi, millaisessa ympäristössä; tutkimuskysymys; tulokset; impakti)

\abstract{tiivistelmä (100-200 sanaa)}

% The following can be used to specify keywords and classification of the paper:

\keywords{ohjelmistoarkkitehtuuri, testattavuus, näkymä, näkökulma}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):" 
 
 \classification{
	Software and its engineering $\rightarrow$ System description languages 	\\
	Software and its engineering $\rightarrow$ Software defect analysis
 }
% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
%\numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}

% Write some science here.

%Esimerkkilause ja lähdeviite~\cite{esimerkki} ja \cite{esimerkki2}.
%jäsennelty asianmukaisesti (kenelle, miksi, millaisessa ympäristössä; ratkaisun lähestymistapa; tutkimuskysymys, tulokset ja impakti; loppulukujen roolitus).




%\section{Johdanto}
%purkaa auki teknisemmälle yleisölle samalla käsitteitä määritellen tutkimuskysymyksen, ratkaisuille ympäristöstä esiintulevat vaatimukset ja keskeiset käsitteet näiden asioiden esittelemiseksi.

%antaa riittävästi termistöä ja kysymyksenasetteluja, jotta myöhempänä teksissä on mahdollisuus analyysiin ja evaluointiin.
%Keskimmäiset luvut keskittyvät kukin "opettamaan" lukijalle yhden osakysymyksen tai näkökulman käsiteltävään asiaan. Lukujen työnjaon tulisi olla selkeä ja niillä tulee olla selkeä oma rakenteensa, jonka valintaperuste on lukijalle kerrottu.

%Viimeistä edellinen luku on varsinaisen kontribuution koti: vertailu, soveltaminen, osien synteesi ja mahdolliset evaluointimenetelmät ja -tulokset pääroolissa.

Ohjelmistoarkkitehtuuri on ohjelmistojen ymmärtämisen kannalta tärkeä konsepti, josta jokaisen ohjelmoijan pitäisi olla tietoinen, sillä jokaisella ohjelmistojärjestelmällä on oma arkkitehtuurinsa. Tämä siksi, koska järjestelmän arkkitehtuurin voidaan nähdä olevan ne hallitsevat ominaisuudet, jotka ovat konkretisoituneet sen elementteihin ja suhteisiin \citep[s. 2]{ISOIEEE42010}. Suunnittelematon arkkitehtuuri eli niin sanottu \textit{Big Ball of Mud} saattaa pahimmassa tapauksessa olla yksi epäonnistuneen projektin tunnusmerkkejä, kun taas hyvin muodostettu arkkitehtuuri auttaa eri sidosryhmien välisessä kommunikaatiossa, tekee tuotettavasta ohjelmistojärjestelmästä helposti lähestyttävän, helpottaa sekä ohjelmiston testausta että validointia ja on yksi suurimmista onnistumistekijöistä projektin jatkon kannalta. 

Ohjelmistojen ylläpidettävyys lasketaan yhdeksi ei-toiminnalliseksi laatuvaatimukseksi, ja siihen kuuluu vahvasti ohjelmistojen testattavuus, joka taas vaatimuksena on lähempänä ohjelmoijaa kuin asiakasta. Testausta tapahtuu ohjelmistojärjestelmän elinaikana useita kertoja, joista  aikaisimmat jo projektin alkumetreillä, kun halutaan evaluoida järjestelmän toiminnallisuutta. Testattavuus taas määrittelee kuinka hyvin järjestelmään kohdistuva testaus löytää mahdolliset virheet ja kuinka helppo testitapauksia on luoda. Arkkitehtuurin ja testattavuuden yhteys on kuitenkin hieman häilyvä, vaikka monelle kehittäjälle ovatkin tuttuja hyvät käytänneet olio-ohjelmoinnissa. Suuriosa opituista käytänneistä kuitenkin ottaa kantaa vain lähdekooditasolla tapahtuviin ongelmakohtiin, jolloin arkkitehtuurinen puoli saattaa jäädä kokonaan huomioimatta. Testauksen aikana löytyneet arkkitehtuuriset ongelmat taas kuluttuvat turhaa aikaa ja hidastavat koko ohjelmistotuotantoprosessia, koska ne löydetään usein liian myöhään. Tämä tutkielma pyrkii selventämään ohjelmistojärjestelmän rakenteen ja testattavuuden suhdetta sekä sitä, miten testattavuus tulee ilmi ohjelmistoarkkitehtuurissa. 

\subsection{Tutkimuskysymys}
Tutkimus vastaa kysymykseen miten testattavuus näkyy ohjelmistojen arkkitehtuurisella tasolla. Itse kysymys voidaan jakaa vielä tarkentaviin kysymyksiin: mitä ylipäätänsä on testattavuus ohjelmistojärjestelmissä ja mitkä tekijät siihen vaikuttavat, miten arkkitehtuuria on mahdollista kuvata, miten ohjelmistojärjestelmän arkkitehtuurista luotu näkymä kertoo jotain järjestelmän testattavuudesta. 

\subsection{Tutkimusmenetelmä}
Tutkimuskysymykseen vastataan kirjallisuuskatsauksen avulla ja tutkimalla mitkä seikat tuovat testattavuutta ohjelmistojärjestelmään. Näiden perusteella pyritään tunnistamaan kriittisiä arkkitehtuurisia ominaisuuksia, joiden avulla testattavuuden tasoa olisi mahdollista tarkastella järjestelmässä. Testattavuuden havaitsemiseen etsitään näkymää nykyisistä menetelmistä kuvata arkkitehtuuria. Näitä menetelmiä ovat pääasiassa erilaisten näkymien ja näkökulmien joukko, joiden avulla on mahdollista tuoda ohjelmistojärjestelmästä esiin joitain sen erityispiirteitä.

Itse tutkimus on rajattu pääosin ainoastaan oliopohjaiseen arkkitehtuuriin ja sen erilaisiin kuvaamistapoihin. Testaustavoista on tuotu esille yksikkö- ja integraatiotestaus. Arkkitehtuurin mallintamisesta on jätetty ADL:t (architecture description languages) pois, koska ne eivät tarjoa visuaalista näkymää arkkitehtuuriin ja ovat harvemmin käytössä monimutkaisuutensa vuoksi. Myöskään erilaisia arkkitehtuurisia tyylejä ei vertailla tutkimuksessa testattavuuden kannalta, vaan tutkimus keskittyy nimenomaan ohjelmistojärjestelmän konkreettisen rakenteen arvioimiseen testattavuuden kannalta.

\subsection{Tutkimuksen rakenne}

Kappaleessa \ref{software_architecture_main} käydään läpi ohjelmistoarkkitehtuuria käsitteenä ja luodaan pohja eri kuvaustavoille ohjelmistoarkkitehtuuria varten. Samalla kuvataan miten ja mistä näkymä voidaan luoda ohjelmistojärjestelmälle. Kappale \ref{testability_main} tarkentaa testattavuutta laadullisena tekijänä ja pyrkii määrittelemään mitä on testattavuus ohjelmistojärjestelmissä. Kappale \ref{arch_testability_main} etsii arkkitehtuurin ja testattavuuden välistä suhdetta. Viimeinen kappale \ref{pondering} tuo mukaan kirjoittajan omat pohdinnat ja ehdottaa tutkimuksia tulevaisuuteen. 


\section{Ohjelmistoarkkitehtuuri} \label{software_architecture_main}
Arkkitehtuuri ohjelmistojärjestelmissä on käsite, joka ei ole kovin yksiselitteinen eikä siitä ole yksimielistä määritelmää \citep[s. 363]{solms_what_2012}. 
Ohjelmistoarkkitehtuuri kuitenkin kuvaa vähintään aina abstraktilla tasolla toteutettavaa ohjelmistojärjestelmää niin, että on mahdollista keskittyä vain suppeaan alueeseen jättämällä pois eri sidosryhmien kannalta epärelevantteja asioita. Arkkitehtuurin kuvaaminen tapahtuu usein visuaalisella tavalla, koska visuaalisesta mallista on nopea ja helppo saada ulos tarvittava informaatio. Visuaalisen mallin avulla voidaan ohjelmistojärjestelmästä myös nähdä uutta informaatioita, joka muuten olisi piilotettu lähdekoodiin kehittäjän omina ajatuksina.   

\subsection{Ohjelmistojen arkkitehtuuri käsitteenä} \label{ark}
Ohjelmistoarkkitehtuuri voidaan nähdä karkeasti neljästä eri näkökulmasta  \citep[s. 2-7]{gorton_understanding_2011}:  ohjelmiston rakenteen kuvaajana, kuvaajana ohjelmiston komponenttien välisille suhteille, ei-toiminnalliset (non-functional) vaatimukset huomioon ottavana mallina ja yleisenä abstraktiona. 
% kappaleessa selitetään myös riippuvuuksien vähentämisestä

%Rakenteen kuvaajana arkkitehtuuri määrittelee ohjelmistojärjestelmän sisäistä rakennetta, joka koostuu useista komponenteista sekä moduuleista, jotka yhdistävät ja ryhmittelet komponentteja. Erilaiset moduulit tarjoavat aina tietyn toiminnallisuuden ja tämän kautta erilaiset vastuut on jaettu ohjelmistojärjestelmän sisällä loogiisiin kokoelmiin.
% kappaleessa myös patterneja

%Komponenttien välisen kommunikaation mallintaminen tapahtuu, kun ohjelmistojärjestelmää jaetaan erilaisiin komponentteihin. Tavoitteena on kertoa mallintamalla, että mitkä komponentit tai moduulit ovat vuorovaikutuksessa toistensa kanssa ja millä tavoin. Yleisin kommunikaatiotapa on esimerkiksi suorat funktiokutsut komponenttien välillä, joiden mallinnus selventää esimerkiksi informaation kulkua järjestelmässä.  
% kappaleessa ei-toiminnallisten vaatimuksien jako kolmeen eri luokkaan

%Ei-toiminnaliset vaatimukset tulevat kunnolla esille vasta arkkitehtuurin avulla ja arkkitehtuurin mallinnuksen avulla voidaan määrittää miten ohjelma suorittaa sille määrättyä tehtävää sen sijasta, että mallinnettaisiin ainoastaan mitä ohjelma tekee. 
% lähteitä lisää?

%Arkkitehtuurin avulla on mahdollista abstrahoida
%sidosryhmille ohjelmistojärjestelmää helpommin lähestyttäväksi, jolloin kommunikaatio eri osapuolten välillä helpottuu. Abstrahoinnin avulla pystytään yksinkertaistamaan järjestelmän konkreettista toteutusta ja suorittamaan arkkitehtuurista erittelyä (architectural decomposition), jossa muodostetaan epärelevanteista komponenteista mustia laatikoita (black boxes). Mustien laatikoiden ideana on piilottaa komponenttien sisäistä toteutusta eri abstraktiotasoilla, jolloin arkkitehtuurista voidaan muodostaa eri tarkkuustason malleja. 

Hieman samanlainen jaottelu on määritelty myös Solmsin tutkimuksessa \citep{solms_what_2012}. Siinä ohjelmistoarkkitehtuuri-määritelmä jaetaan kolmeen eri luokkaan: korkean tason abstraktioon ohjelmistojärjestelmästä, rakenteita sekä ulkoisia ominaisuuksia korostavaan määritelmään ja käsitteistöön sekä rajoitteisiin, joiden puitteissa ohjelmistojärjestelmää kehitetään. Näistä kaksi ensimmäistä määritelmää vastaavat samoja kuin \cite{gorton_understanding_2011} ja niitä voidaan mallintaa erilaisten näkymien ja UML-kaavioiden avulla

\begin{itemize}
	\item korkean tason abstraktioita mallinnetaan erilaisten näkymien kautta tai käyttämällä IEEE:n määrittelemiä käytänteitä
	\item rakenteita korostavassa mallinnuksessa käytetään usein UML-kaavioita ja niiden tuomia keinoja abstrahoida järjestelmää.
	
\end{itemize}

% IEEE:stä voisi kirjoittaa enemmän    
%Rakenteita korostettaessa mallinnuksessa käytetään usein UML-kaavioita, koska UML määrittelee ohjelmiston arkkitehtuuria osina, joita pystytään rekursiivisesti tarkentamaan haluttaessa. Tarkennuksen avulla osat pystytään kuvaamaan kommunikoivan keskenään erilaisten rajapintojen kautta, osia yhdistäviä suhteita pystytään tarkastelemaan ja erilaisia rajoitteita pystytään luomaan osien välille. 
% järjestelmien välinen kommunikaatio se lähde.

%Kolmas määritelmä on paljon laajempi näkemys ohjelmistoarkkitehtuurista, koska se kuvaa ohjelmistojärjestelmän käsitteistön ja ominaisuudet siinä ympäristössä, jossa ne ilmenevät elementtien, suhteiden ja suunnittelun periaatteiden kautta. Peruskäsitteistö tarjoaa sen käsitteistön, jonka avulla sovelluslogiikka voidaan määritellä, joten esimeriksi määrittelemällä, että jokin komponentti toteuttaa palvelimen toiminnallisuutta, saadaan asiat lokeroitua käsitteellisesti erilleen toisistaan. Ominaisuudet liittyvät ohjelmistojärjestelmän laadullisiin ominaisuuksiin. Periaatteet voidaan nähdä järjestelmän keskeisinä suunnittelurajoitteina (core design constraints), joiden kokonaisuus muodostaa järjestelmän arkkitehtuurisen tyylin. Ohjelmistojärjestelmän arkkitehtuurin tyyli voi koostua esimerkiksi väylistä ja suodattimista (pipes and filters). % lisää


Näistä kahdesta eri jaottelusta ohjelmistoarkkitehtuuri-käsitteen välillä voidaan nähdä merkittävinä tarpeina kuvata ohjelmistojärjestelmän rakenteellisuutta, komponenttien välistä kommunikaatiota ja laadullisia vaatimuksia. Kaikki nämä edellämainitut ominaisuudet on saatava  upotettua ohjelmistojärjestelmästä luotavaan arkkitehtuuriseen malliin niin, että ne vastaavat muun muassa seuraaviin kysymyksiin \citep[s. 31 - 33]{Rozanski:2011:SSA:2072649} 

\begin{itemize}
	\item mitkä ovat arkkitehtuurin toiminnalliset elementit
	\item miten nämä elementit kommunikoivat keskenään ja ulkomaailman kanssa
	\item mitä tietoa käsitellään, talletetaan ja esitetään
	\item mitä fyysisiä ja ohjelmallisia elementtejä tarvitaan tukemaan näitä. elementtejä
\end{itemize}

Arkkitehtuurista luotava malli ei saisi olla monoliittinen malli, joka pyrkii kuvamaan kaiken yhdessä mallissa, koska arkkitehtuuria ei ole mahdollista kuvata vain yhden mallin avulla \citep{Rozanski:2011:SSA:2072649}. Tämä johtuu siitä, että monoliittinen malli paisuu liian suureksi, jolloin sitä on vaikea kenenkään osapuolen enää ymmärtää ja siitä on vaikeaa löytää arkkitehtuurin tärkeimmät ominaisuudet. Monoliittinen malli on usein myös puutteellinen, jäljessä eikä vastaa enää nykyistä ohjelmistojärjestelmää.  


\subsection{Arkkitehtuurin kuvaus}

Ratkaisu monoliittiseen malliin on jakaa arkkitehtuurin kuvaus useisiin toisiinsa liittyviin näkymiin (views), jotka esittävät jokainen yhden näkökulman (viewpoint) järjestelmän arkkitehtuuriin keräämällä yhteen sekä toiminnalliset piirteet että laadulliset ominaisuudet \citetext{\citealp{Ran:1998:ASV:288408.288438}; \citealp[s. 33-34]{Rozanski:2011:SSA:2072649}; \citealp[s. 8-9]{gorton_understanding_2011}; }.

Useiden erilaisten näkymien avulla on helpompi kommunikoida eri sidosryhmien välillä ja ne mahdollistavat järjestelmän tarkastelun vain niiltä osin, jotka tietty sidosryhmä kokee tärkeiksi. Yleisesti voidaan sanoa, että erilaiset näkymät auttavat jakamaan arkkitehtuurin vastuista pienempiin palasiin \citep[s. 2]{Galster:2011:DTC:2031759.2031761}. Vastuiden ja näkymien jakaminen taas auttaa jokaista ohjelmistoarkkitehtuuriin liittyvää prosessia tehden ohjelmistoarkkitehtuurin tarkastelusta, suunnittelusta ja toteutuksesta modulaarisempaa.

%Arkkitehtuurin kuvaaminen sallii myös kommunikoinnin eri sidosryhmien välille ja mahdollistaa järjestelmän tarkastelemisen vain niiltä osin, jotka tiettyä sidosryhmää kiinnostavat \citetext{\citealp[s. 329]{ARaHVeSCiSDu}; \citealp[s. 60]{Brondum:2010:TAV:1833335.1833344}}. Kuvaaminen tapahtuu näkymien avulla, jotka auttavat erottelemaan (separation of concerns) arkkitehtuuria pienempiin palasiin \citep[s. 2]{Galster:2011:DTC:2031759.2031761}. Itse näkymät luodaan käyttämällä ennaltamäärättyjä näkökulmia, jotka edustavat tiettyä tai useampaa sidosryhmälle tärkeää asiaa. 

\subsubsection{Näkymät}
Arkkitehtuuristen näkymien tehtävänä on kuvata tietylle asialle olevat merkitykselliset näkökulmat arkkitehtuurista. Yksi tunnetuimmista määritelmistä arkkitehtuuriselle näkymälle on Krutchenin 4+1 näkymämalli (4+1 View Model) \citep{krutchen1995}. 

4+1 -mallissa arkkitehtuuri kuvataan neljän näkymän ja yhden tekstuaalisen kuvauksen avulla 

\begin{itemize}
	\item looginen, joka kuvailee järjestelmän rakennetta ja suhteita
	\item prosessinen, joka keskittyy suorituksen kuvaamiseen
	\item fyysinen, joka esittää miten komponentit kuvautuvat fyysiselle laitteistolle
	\item kehityksellinen, joka kuvailee järjestelmän sisäistä toteutusta
	\item skenaariollinen, jonka avulla näkymät liitetään yhteen.
\end{itemize}

%Looginen näkymä kuvailee esimerkiksi luokkakaavioiden avulla ohjelmistojärjestelmän elementtejä ja niiden välisiä suhteita tarkentaen järjestelmän rakennetta, prosessinäkymä keskittyy ajonaikaisen suorituksen kuvaamiseen tarkentamalla muun muassa miten samanaikaisuuden hallinta tapahtuu järjestelmässä, fyysinen näkymä keskittyy siihen miten järjestelmän eri komponentit kuvautuvat fyysiselle laitteistolle jossa komponenttia ajetaan ja lopuksi kehitysnäkymä (development view) keskittyy järjestelmän sisäiseen toteutukseen tarkemmalla tasolla kuvailemalla sisäkkäisia pakkauksia tai luokkahierarkiaa. Jokainen näkymä voidaan liittää osaksi toista näkymää skenaarioiden avulla, jotka heijastelevat järjestelmälle asetettuja vaatimuksia, jolloin skenaariot voidaan nähdä ikäänkuin liimana muuten erillisille näkymille. 

Muita näkymämalleja arkkitehtuuriin on useita, joista jokainen kuitenkin tuo esille vähintään jollain tavalla ohjelmistojärjestelmän rakennetta ja yhteyksiä. Tästä esimerkkinä tunnettu \textit{Views and Beyond} -malli \citep{Clements:2002:DSA:599933}. Siinä arkkitehtuurinen malli kuvataan kolmella eri näkymällä

\begin{itemize}
	\item moduuli, joka on rakenteellinen näkymä järjestelmään
	\item komponentit ja konnektorit, jotka kuvailevat järjestelmän toiminnallista puolta ja yhteyksiä
	\item allokaatio, joka kuvaa miten prosessit kuvautuvat laitteistotasolla.
\end{itemize}

 %moduuli, joka on järjestelmän rakenteellinen näkymä kuvaten muun muassa luokkia, pakkauksia, moduulien eriyttämistä (decomposition) sekä periytymistä; komponentti ja konnektori, joka kuvailee järjestelmän toiminnallista puolta sekä miten komponentit ovat yhteydessä toisiinsa; allokaatio, joka kuvailee miten prosessit kuvautuvat laitteistotasolla  ja miten ne kommunikoivat keskenään. 

Näiden kahden esitellyn mallin lisäksi on olemassa joukko eri tarkoituksiin sopivia näkymämalleja, joilla on omat vahvuutensa ja heikkoutensa. Kuitenkin edellä mainitusta kahdestakin mallista jo nähdään, että kummatkin pyrkivät nostamaan esille järjestelmän rakennetta ja rakenteessa ilmeneviä suhteita, joita muun muassa komponenttien sekä moduulien välillä on.

%Yhteensä viittä eri mallia vertailtiin Mayn tutkimuksessa \citep{may2005survey}. Siinä kartoitettiin mahdollisimman laajaa näkymien muodostamaa näkökulmien joukkoa, jotka kattaisivat mahdollisimman laajalti ohjelmistoarkkitehtuurin aluetta (domain). Vertailtavat arkkitehtuurit olivat 4+1-malli, SEI:n (Software Engineering Institute) \textit{Views and Beyond}-malli, ISO:n (International Organization for Standardization) \textit{Reference Model of Open Distributed Processing}, Siemensin \textit{Four View Model} ja \textit{Rational Architecture Description Specification}. Malleja vertailtiin tutkimalla kuinka niiden tarjoamat näkökulmat painottavat kolmeen eri kategoriaan liittyviä asioita: sidosryhmät, laadulliset tekijät ja rakenteelliset ominaisuudet. Lopulliseen valintaan, joka painotti mahdollisimman laajasti jokaisen osa-alueen ominaisuuksia, otettiin mukaan \textit{Views and Beyond} -mallin kaikki kolme näkymää ja \textit{Rational ADS}:n vaatimukset-näkökulma (requirements viewpoint). Syy, miksi juuri nämä valittiin oli se, että \textit{Views and Beyond} sopii erittäin hyvin mallin pohjaksi, koska se kuvaa järjestelmän rakennetta kattavasti, sen näkökulmat ovat itsenäisiä ja se limittyy kokonaisuudessaan hyvin 4+1-mallin sekä Siemens'n mallin kanssa. Se ei kuitenkaan sisällä tarvittavia näkymiä kuvaamaan eri sidosryhmille tärkeitä asioita esimerkiksi loppukäyttäjiä varten oleva näkymä puuttuu kokonaan. Tämän takia mukaan on otettu \textit{Rational ADS}, jonka vaatimukset-näkökulma koostuu neljästä eri näkymästä: ei-toiminnalliset vaatimukset, alue (domain), käyttötapaus ja käyttökokemus. 



\subsubsection{Näkökulmat}
Näkökulmat liittyvät vahvasti arkkitehtuurisiin näkymiin, koska näkymien avulla halutaaan tuoda jokin näkökulma esille \citep[s. 36-42]{Rozanski:2011:SSA:2072649}. Näkökulma voidaan määritellä olevan kokoelma malleja (patterns), templaatteja sekä konventioita, joiden avulla näkymä pystytään rakentamaan.  Näkökulmien joukko taas voidaan jakaa seitsemään eri osaan: kontekstuaalinen, funktionaalinen, informaatiollinen, samanaikaisuudellinen, tuotannollinen, käyttöönotollinen ja operationaalinen. Näistä keskitytään tämän tutkimuksen myöhemmässä vaiheessa hieman tuotannollisen sekä funktionaalisuuden näkökulmaan. Tuotannollinen näkökulma on tärkeä siksi, että se ottaa huomioon niiden sidosryhmien asiat, jotka ovat mukana järjestelmän kehityksessä, testauksessa, ylläpidossa ja parantamisessa. Funktionaalinen näkökulma taas painottaa muun muassa järjestelmän suorituksenaikaisia komponentteja ja niiden rajapintoja. Näiden avulla halutaan tuoda esille näkökulma testattavuuden analysoimiseen, jota kehittäjät voisivat käyttää hyödyksi.

% 4210 ISO
IEEE:n virallinen määritelmä näkokulmalle on \citep[s. 6]{ISOIEEE42010} \textit{frames one or more concerns. A concern can be framed by more than one
viewpoint.
A view is governed by its viewpoint: the viewpoint establishes the conventions for constructing, interpreting
and analyzing the view to address concerns framed by that viewpoint. Viewpoint conventions can include
languages, notations, model kinds, design rules, and/or modelling methods, analysis techniques and other
operations on views. } Se on määritelmä, jota tullaan käyttämään myös tässä tutkimuksessa.


\subsection{Näkymän luominen} % aika turha kappale

Ohjelmistoarkkitehtuuri toimii siltana ohjelmakoodin ja ohjelmalle asetettujen vaatimusten välillä \citep[s. 94]{Garlan:2000:SAR:336512.336537}, joten on luonnollista, että näkymä luodaan näiden pohjalta. Sitä luodessa on myös otettava huomioon kenelle näkymä on tarkoitettu, minkälaisia asioita halutaan näkymän painottavan ja millä abstraktiotasolla näkymän tulisi olla. 


Luotavan näkymän perimmäinen tarkoitus voi esimerkiksi olla, että mahdollisimman paljon halutaan nähdä arkkitehtuurisia ominaisuuksia katsomatta lähdekoodia, koska lähdekoodi joko ei ole saatavilla tai se on kehittäjälle liian monimutkaista ja aikaavievää käydä kokonaan läpi ajatuksen kanssa. Tällaiseen näkymän tarpeeseen sopivat esimerkiksi UML:n avulla luodut kaaviot järjestelmän rakenteeesta, joiden avulla erilaisten suhteiden ja rakenteellisten ominaisuuksien tarkastelu helpottuu huomattavasti.

%Chapt. 7 & 8 + Arch views -paperi + What is an architectural description?
%Jos järjestelmää ei ole vielä olemassa lainkaan, voidaan järjestelmän arkkitehtuuria lähteä ensin rakentamaan iteratiivisesti kolmen eri vaiheen kautta \citep[s. 97-115]{gorton_understanding_2011}: määritellään arkkitehtuuriset vaatimukset; luodaan rakenne, joka tukee näitä vaatimuksia; testataan, että rakenne tukee vaatimuksia. Arkkitehtuurille asetetut vaatimukset syntyvät toiminnallisten ja sidosryhmien asettamien vaatimusten tuloksena, koska ne yhdessä luovat tärkeimmät vaatimukset ja rajoitukset ohjelmistojärjestelmälle. Esimerkkinä järjestelmälle asetettavista vaatimuksista saattaa olla, että sen on pystyttävä tukemaan useita eri käyttöliittymiä. Tämä vaatimus voidaan taas ryhmittää tiettyyn laatuvaatimukseen, kuten useat muutkin järjestelmälle asetetut vaatimukset \citep[s. 117]{Ran:1998:ASV:288408.288438}. Tässä tapauksessa vaatimus ryhmitettäisiin muokattavuus-laatuvaatimuksen alle. Seuraavassa vaiheessa valitaan tätä laatuvaatimusta tukeva tyyli (architectural style), jota koko järjestelmä joutuu noudattamaan. Esimerkiksi N-tason -malli tukee muokattavuutta hyvin \citep[s. 103]{gorton_understanding_2011}. Tämän jälkeen järjestelmän keskeisimmät komponentit suunnitellaan ja sijoitetaan ne oikeisiin alueisiin, jotka valittu arkkitehtuurinen tyyli tuo tullessaan. Komponenttien väliset suhteet mallinnetaan pitämällä vastuut erillään, suhteet mahdollisimman vähäisinä sekä käyttämällä hyödyksi piilottamista (architectural decomposition). Lopuksi pystytään luomaan skenaarioita ja testaamaan niiden avulla, että onko luotu arkkitehtuuri sopiva. Komponenttien määrittely mahdollistaa arkkitehtuurin rakenteen kuvaamisen ja siten järjestelmästä on mahdollista luoda erilaisia näkymiä erilaisille sidosryhmille. Rakennetta pystytään kuvaamaan N-tason -mallin avulla erittäin korkealla tasolla, jos halutaan tuoda esille juurikin näkökulma muokattavuuteen, mutta myös matalemmalla tasolla, kun ohjelmistokehittäjä haluaa ymmärtää miten komponentit kommunikoivat keskenään.

%\section{Ohjelmistojen laadulliset tekijät}


%\subsection{Laatuvaatimukset}
%\subsubsection{Toiminnalliset}
%\subsubsection{Ei-toiminnalliset vaatimukset}
%\subsection{Tradeoffit}
%\subsection{Arviointi}

\subsection{UML}

UML eli \textit{Unified Modeling Language} on visuaalinen formalisoitu mallinnuskieli näkymien luomiseen \citep{UML}, joka on muodostunut \textit{de facto}-standardiksi ohjelmistoarkkitehtuurin kuvauksessa ja luomisessa. UML:n avulla voidaan ohjelmistoa mallintaa kolmelta eri näkökulmalta: kehitystä täydentävät mallit, käyttäytymisen kuvaamiseen tarkoitetut mallit ja rakennetta kuvaavat mallit. Käytännössä sen avulla pystytään siis kuvaamaan esimerkiksi jokainen sekä 4+1 -mallin että \textit{Views and Beyond}-mallin näkymä käyttäen hyväksi UML:n tarjoamaa 13 erilaista kaaviota. Arkkitehtuurin kuvauksen kannalta relevanteimmat kaaviot ovat luokkakaavio ja komponenttikaavio, koska niiden avulla saadaan kuvattua erittäin tarkasti ja monipuolisesti järjestelmän rakennetta. Luokkakaaviossa huomio keskittyy konkreettisten luokkien ja niiden välisten suhteiden kuvaamiseen, kun taas komponenttikaavio kuvaa korkeammalla tasolla järjestelmää komponenteittain, joita yhdistävät niiden tarjoamat rajapinnat.   

UML sopii ominaisuuksiensa takia erittäin hyvin olio-pohjaisten ohjelmien kuvaamiseen tarjoamalla tuen muun muassa periytymisen ja rajapintojen kuvaamiseen. Tämän takia se on otettu tässä tutkimuksessa erityisasemaan järjestelmän ja sen arkkitehtuurin kuvaamisessa.


\section{Testattavuus laadullisena tekijänä} \label{testability_main}
Testattavuus luetaan kuuluvaksi ylläpidettävyyden alle \citep{ISO/IEC25010:2011} ja on täten yksi ohjelmistojärjestelmän laadullisista tekijöistä. Laatuvaatimuksena se ei kuitenkaan ole aina edes kovin näkyvä esimerkiksi asiakkaalle mutta ohjelmistokehittäjälle se tulee esille useassakin kontekstissa. Vaikeasti testattavaa järjestelmää on myös vaikea ylläpitää, ja ylläpidettävä järjestelmä on sekä asiakkaalle että kehittäjälle tärkeä ominaisuus.

% Yksikkö vs integraatio vs regressio testauksessa.
Ohjelmistojärjestelmään kohdistuva testaus voidaan jakaa moneen eri luokkaan, joista kaksi yleisintä ovat yksikkö -ja integraatiotestaus. Yksikkötestauksessa varmistetaan järjestelmän komponenttien kuten luokkien toiminnallisuutta itsenäisesti, kun taas integraatiotestauksessa testaus kohdistuu järjestelmän rajapintoihin ja komponenttien yhteistoiminnallisuuteen. Testauksen voidaan nähdä siis löytävän itse viat, mutta testattavuus taas löytää paikat, joissa viat voivat sijaita \citep[s. 19]{Voas:1995:STN:624607.625469}. Testattavuus tukee täten testausta ja testausprosessia, koska sen avulla voidaan määritellä, mikä on todennäköisyys sille, että järjestelmässä olevat viat löydetään \citep{voas_improving_1992}. 


\subsection{Testattavuuden arviointi} \label{contro_and_observ}

Testattavuuden arvioimisessa voidaan käyttää hyödyksi kolmea eri parametria \citep[s. 2]{baudry_measuring_2003}: havaittavuus (observability), hallittavuus (controllability) ja vaativuus, joka tarvitaan suorittamaan tietty testi. Havaittavuus määrittelee, kuinka mahdollista testien tuloksia on tarkastella, ja hallittavuus sitä, kuinka paljon testattavaan komponentin tilaan voidaan vaikuttaa. 

Havaittavuus voidaan myös nähdä arvona, joka kertoo kuinka helppo on määrittää vaikuttavatko tietyt syötteet testituloksiin, ja hallittavuus taas voidaan nähdä siitä kuinka helppo on tuottaa jokin tietty tulos syötteestä. %\citep[s. 554]{Freedman:1991:TSC:126218.126229}. 
Sen parametrisoimiseen on kehitetty \textit{domain-to-range} -arvo eli DRR, jonka avulla voidaan havaita implisiittistä tiedonkatoamista \citep{Voas:1995:STN:624607.625469}. DRR-arvo saadaan vertailemalla komponenttien mahdollisen tulosteen (ouput) joukon kokoa syötteen (input) kokoon. DRR-analyysi on hieman ongelmallinen, koska se vaatii ohjelmistojärjestelmän täydellisen lähdekoodin tuekseen ja lähdekoodi-analyysit ovat raskaita teettää käsin.

% hallittavuus???  



\subsection{Testattavuuden parantaminen}

%Hyvä testattavuus on järjestelmän laadulle hyvä ominaisuus \citep[s. 20]{Voas:1995:STN:624607.625469}. 

Hyvä testattavuus auttaa järjestelmän ylläpidossa, validoinnissa ja parantaa järjestelmien laatua \citep[s. 20]{Voas:1995:STN:624607.625469}. Se on siis tavoiteltava ominaisuus jokaisessa ohjelmistojärjestelmässä, mutta hyvän testattavuuden saavuttaminen on aina ohjelmistöjärjestelmäkohtaista. Tästä syystä onkin mielekkäämpää tarkastella, mikä luo yleisesti järjestelmissä hyvää testattavuutta. 

%Testattavan komponentin ominaisuudet: testitapaukset ovat pieniä ja helposti luotavia, testitapaukset eivät ole itseään toistavia, ongelmat on helppo jäljittää tiettyihin komponentteihin \citep[s. 554]{Freedman:1991:TSC:126218.126229}

%Jo suunnitteluvaiheessa voidaan kiinnittää huomiota testattavuuteen ja näin parantaa itse testausprosessia. Decomposition, moduulien korkeat DRR (domain/range -ratio), korkean DRR:n omaavat moduulit mah. pieniksi ja eriytetyiksi, hyvä rajapinta joka paljastaa tarpeeksi moduulin sisäistä tilaa \citep[s. 117]{voas_improving_1992}.


%Isolating modules with high DDR \citep[s. 23]{Voas:1995:STN:624607.625469}.

Freedman on määritellyt testattavan komponentin ominaisuuksiksi \citep{Freedman:1991:TSC:126218.126229}: komponentista luotavat testitapaukset pysyvät pieninä ja ovat helposti luotavissa; komponentin testitapaukset eivät ala toistamaan itseään; komponentin testauksen aikana havaitut ongelmat on helppo jäljittää tiettyihin komponentteihin. Näitä tukemaan voidaan jo arkkitehtuurin alkuvaiheessa kiinnittää huomiota tekijöihin, jotka saadaan DRR-arvoja analysoimalla \citep{voas_improving_1992} 

\begin{itemize}
	\item ymmärtää dekomposition mahdollisuus
	\item tunnistaa moduulit, joiden DRR-arvo on korkea ja tehdä ne mahdollisimman pieniksi ja yksinkertaisiksi
	\item tunnistaa rajapinta korkean DRR-arvon moduuleille siten, että rajapinta paljastaa tarpeeksi tietoa moduulien sisäisestä tilasta
	\item eriyttää korkean DRR-arvon moduulit toisistaan \citep[s. 23]{Voas:1995:STN:624607.625469}.
\end{itemize}


On siis todella tärkeää eriyttää komponentteja mahdollisimman paljon toisistaan ja tehdä kommunikaatio mahdollisimman kontrolloitavaksi hyvän testattavuuden aikaansaamiseksi. Varsinkin helposti isoiksi muodostuvien komponenttien pitäisi olla kytkentätasoltaan mahdollisimman kevyitä ja riippuvuuksien minimissään tai niistä luotavien testien tekeminen vaikeutuu ja testitapausten koko kasvaa erittäin suuriksi. Myös ison ja tärkeän toiminnallisuuden kerääntymistä vain muutaman komponentin vastuulle voi olla merkki liiallisista DRR-arvoista, joka pitäisi hoitaa välittömästi tai testaus voi vaikeutua huomattavan paljon.



\subsection{Testausta heikentävät ominaisuudet}

Tietyt ominaisuudet vaikuttavat yleisesti ohjelmistojärjestelmissä negatiivisesti testattavuuteen. Tiedon katoaminen on yksi näistä \citep{Voas:1995:STN:624607.625469} ja se voidaan jakaa implisiittisen ja eksplisiittisen tiedon katoamiseen. Implisiittisessä katoamisessa useat eri parametrit samaan kohteeseen tuottavat myös saman testituloksen, ja eksplisiittisessä tiedon katoamisessa tietoa piilotetaan ulkoiselta näkymältä. Tiedon piilottaminen on esimerkiksi hyvin yleinen ja suositeltava tapa olio-ohjelmoinnissa, mutta liiallinen tiedon piilotus tuottaakin vaikeuksia testauksessa, koska testauksen hallittavuus heikkenee. Ohjelmistojärjestelmä voidaan kuitenkin tarkoituksella suunnitella niin tiiviiksi, että sisäinen tila jää täysin tarkastelemattomaksi. Tällöin testauksen aikana syntyneessä virhetilanteessa on hyvin vaikea sanoa, että mistä päin virhe syntyi ja virheen paikallistaminen saattaa viedä aikaa.

Ongelmat syötteiden ja tulosten tarkastelussa tiedon katoamisen johdosta johtavat helposti tarpeettomiin testeihin, joita on vaikea ymmärtää, ja vaikeasti testattavan komponentin voidaankin sisältävän ulos- ja sisääntuloparametrien epäjohdonmukaisuuksia \citep{Voas:1995:STN:624607.625469}. Toisin sanoen vaikeasti testattava komponentti tuottaa eri tuloksia eri ajoilla tai ei ikinä tuota haluttua tulosta.   




\subsection{Testattavuuden mittaaminen} \label{testability_measure}


Koska suoraan hyvää tai huonoa testattavuutta on vaikeaa määritellä, on erilaisia testattavuuteen vaikuttavia mittareita tutkittu paljon. Mittareiden käyttäminen tuo myös konkretiaa analysoimiseen ja niiden avulla on helppo tehdä esimerkiksi staattista analyysia suorittavia erillisiä ohjelmia. 



Yksikkötestauksen näkökulmasta testattavuutta tutkii Bruntink ja van Deursen. He määrittelivät hyviä testattavuuden metriikoita Java-pohjaisiin ohjelmistojärjestelmiin, jossa tutkimuksen mittarina käytettiin testitapausten kasvua ja pituutta \citep{Bruntink:2004}. Khan ja Mustafa käyttivät taas neljää korkeamman tason metriikkaa laskeakseen testattavuutta ohjelmistojärjestelmissä \citep{Khan:2009:MBT:1507195.1507204}. Ne korreloivat vahvasti edellisiin metriikoihin ja ovat hyvin keskeisiä olio-ohjelmoinnin suunnitteluperiaatteita. Oliopohjaisista järjestelmistä voidaan havaita yleisesti tiettyjä testaukseen vaikuttavia mittareita, joiden suuri arvo korreloi vahvasti huonoon testattavuuteen \citep{Dubey:2011:AMM:2020976.2020983}. Määritetyt tekijät ovat negatiivisia asioita testauksen kannalta, koska esimerkiksi suuri metodien määrä on merkki luokan liiallisesta kompleksisuudesta ja se johtaa testauksen monimutkaistumiseen. Suuri kytkennän määrä vaikeuttaa luokan itsenäistä testaamista, koska luokka käyttää hyvin paljon hyväkseen muiden luokkien toiminnallisuutta. Suuri periytymisaste tuo taas luokalle mahdollisesti paljon perittyjä metodeja, jotka on toteutettu jossain muualla. Tilanne voi johtaa siihen, että luokka on riippuvainen erittäin paljon muiden luokkien toteutuksista ja luokan testaaminen vaatii käytännössä koko luokkahierarkien läpikäynnin. 

Edellämainituissa tutkimuksissa käytetyistä mittareista voidaan muodostaa seuraava taulukko, jossa jokaisen mittarin pääidea on kiteytetty ja suhteutettu neljään korkeantason yleismetriikkaan.

\begin{table}[ht]
\centering
	\setlength{\extrarowheight}{4pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{| m{3.5cm} | m{3.5cm} | m{6cm} |}
	\hline
	\textbf{Mittari} & \textbf{Korreloi} & \textbf{Ehdotettu}\\ \hline
	Ulkoiset viittaukset & Kytkentä, Koheesio & \citep{Bruntink:2004}\\ \hline
	Koko (rivit + metodit) & Enkapsulaatio & \citetext{\citealp{Bruntink:2004}; \citealp{Dubey:2011:AMM:2020976.2020983}}\\ \hline
	Luokkahierarkien aktivoituminen & Enkapsulaatio & \citep{Dubey:2011:AMM:2020976.2020983}\\ \hline
	Kytkennän määrä & Kytkentä & \citep{Dubey:2011:AMM:2020976.2020983}\\ \hline
	Periytymisaste & Uudelleenkäyttö & \citep{Dubey:2011:AMM:2020976.2020983}\\ \hline
\end{tabular}
		
	\caption{Mittarit ja niiden suhteet Khanin ja Mustafan esittämään neljään eri korkeantason ominaisuuteen. Ehdotettu-sarake kertoo, mistä lähteestä mittarin ideat ovat.}
	\label{tab:codeTestability}
	}
\end{table}



\noindent
Taulukkon \ref{tab:codeTestability} on kerätty mittareiden pääideat kaikista kolmesta lähteestä ja niistä voidaan kerätä yleisesti luokkien näkökulmasta muutama iso tekijä testattavuudessa: koko, itsenäinen toimiminen, riippuvuudet muista luokista ja periytyminen. Niistä on kuitenkin osa ominaisuuksiltaan sellaisia, joita voidaan mitata suurimmaksi osaksi vain lähdekoodin avulla ja ne ottavat kantaa testattavuuteen vain yhden luokan näkökulmasta. Se vaikeuttaa kokonaisuuden hahmottamista, vaikka tietenkin olisi mahdollista laskea jokaiselle luokalle erikseen kyseiset mittarit. Suuremman kokonaisuuden tarkasteleminen tai keskittyminen vain tiettyyn testausta vaikuttavaan osa-alueeseen vaatii kuitenkin muita keinoja.

\section{Testattavuus arkkitehtuurisella tasolla} \label{arch_testability_main}

Arkkitehtuurisella tasolla testattavuus vaikuttaa laajemmin ja arkkitehtuuristen ongelmien tutkimiseen on käytettävä eri keinoja, kuin kooditason analysoinnissa, koska lähdekoodia ei aina ole saatavilla. Testattavuutta voidaan tutkia esimerkiksi komponenttitasolla, jota tukevat hyvin UML-komponenttikaaviot. Tämä käy arkkitehtuurin arvioimiseen testattavuuden kannalta hyvin, koska testattavuus tulee ilmi korkealla tasolla muun muassa integraatiotestauksen aikana, kun sekä komponenttien rajapintojen toimivuus että komponenttien toimivuus pitää validoida \citep[s. 65]{Eickelmann:1996:MOS:243327.243602}. Toinen tapa tutkia testattavuutta arkkitehtuurisella tasolla on UML-luokkakaavioiden avulla. Luokkakaavioiden apuna voidaan käyttää hyväksi esimerkiksi niitä kappaleen \ref{testability_measure} metriikoita, jotka eivät tarvitse lähdekoodia tuekseen. 

Yksittäisten komponenttien, eli luokista koostuvien kokonaisuuksien testattavuutta, on analysoitu erilaisten mallien avulla ja näistä eräs on komponenttien pentagrammimalli \citep{gao_component_2005}. Sen avulla jokaista komponenttia voidaan tarkastella viideltä eri näkökulmalta: havaittavuus, hallittavuus, jäljitettävyys (traceability), tuki testivalmiudelle (test support capability) ja ymmärrettävyys (understandability). Näistä kaksi ensimmäistä ovat ideoiltaan samat kuin kappaleessa \ref{contro_and_observ} ja loput vastaavat muun muassa kysymyksiin: kuinka helppoa on tarkastella komponentin tilaa ulkopuolisena; kuinka hyvin komponentti tukee erilaisia testausstrategioita; kuinka hyvin komponentin tarkoitus ymmärretään, että testejä pystytään luomaan. 
 
On siis hyvä tarkastella kahdelta eri näkökulmalta testattavuutta arkkitehtuurisella tasolla: metriikoista koostuva analyysi ja yksittäisten komponenttien analyysi ilman metriikoita. Analyysi ilman metriikoita keskitetään enemmän kokonaisuuksien hahmottamiseen ja ongelmakohtien löytämiseen laadullisten ominaisuuksien pohjalta, kun taas metriikoiden kanssa analyysi on staattista ja painottaa enemmän määrällistä tutkimusta.


\subsection{Hyvä testattavuus arkkitehtuurissa} \label{good_testability}

 
Hyvää testattavuutta arkkitehtuureissa on vaikea määrittää, koska eri järjestelmillä on tiettyyn tarkoitukseen sopiva arkkitehtuuri. Tietyt arkkitehtuuriset tyylit tukevat kuitenkin tiettyjä testausstrategioita \citep{Eickelmann:1996:MOS:243327.243602}, joten on selvää että valittu arkkitehtuurinen tyyli vaikuttaa jollain tasolla positiivisesti testattavuuteen. Paljon mielekkäämpää on kuitenkin tarkastella  ominaisuuksia testattavalle arkkitehtuurille, jotta voitaisiin tarkastella enemmän sitä, mitkä tekijät tuovat testattavuutta arkkitehtuurille.

Oliopohjaisissa ohjelmistojärjestelmissä koetaan vähintään vastuiden jakamisen olevan  lähtökohta hyvälle testattavuudelle, koska se parantaa koko järjestelmän havaittavuutta ja hallittavuutta \citep{Binder:1994:DTO:182987.184077}. Suoraan rakenteelliselta tasolta voidaan taas painottaa esimerkiksi kapseloinnin, polymorfismin, perinnän ja kompleksisuuden tarkastelua. Jos järjestelmää halutaan suunnitella testauksen varalle eli luoda ohjelmistojärjestelmästä mahdollisimman testattava, on siihen olemassa erilaisia laadullisia ja metrisiä ominaisuuksia, joihin huomio pitäisi kiinnittää koko ohjelmistoprosessin ajan \citep{joshi_design_2014}. Mahdollisten ongelmien eliminoimiseen voidaan käyttää hyväksi järjestelmän modulaarista rakennetta, joka pitäisi olla myös vallitseva ominaisuus järjestelmässä koko sen elinkaaren ajan. Toinen apukeino on UML ja sen  muokkaaminen stereotyyppien avulla. UML-kaavioiden muokkaus voi tapahtua esimerkiksi luomalla uusia malleja nykyisten pohjalta tai käyttämällä UML:n geneerisiä laajennoskohtia, joiden avulla saadaan muokattua näkymää tiettyyn suuntaan.


%Järjestelmän tarkasteltavuus (monitorability) voidaan lukea ohjelmistojärjestelmän yhdeksi ominaisuudeksi, joka nostaa positiivisesti testattavuuden tasoa \citep{mari_impact_2003}. Tarkasteltavuus ohjelmistojärjestelmissä voidaan jakaa kolmeen eri luokkaan: komponentin sisäinen, komponenttien välinen sekä järjestelmätasoinen yhteistoiminnallisuus. Tarkasteltavuutta analysoitaessa huomio voidaan kiinnittää esimerkiksi siihen kuinka hyvin järjestelmän tilaa voidaan tarkastella, testien etenemistä, komponenttien interaktiota sekä testauksen hallinnoimista esimerkiksi tynkäluokkien (stub) avulla. 

%He esittävät 


\begin{table}[H]
	\centering
	\setlength{\extrarowheight}{10pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{|m{4cm}|m{7cm}|m{5cm}|}
	\hline 
	\textbf{Analyysimentelmä} & \textbf{Ominaisuus} & \textbf{Lähde} \\ 
	\hline 
	Laadullinen & Testausominaisuus, jäljitettävyys, vaatimusten tarkkuus, antipatternit, havaittavuus, hallittavuus & \citetext{\citealp{Binder:1994:DTO:182987.184077}; \citealp{joshi_design_2014}} \\ 
	\hline 
	Metrinen & Syklisten riippuvuuksien vähyys, kytkennän taso, koheesion taso &  \citep{joshi_design_2014} \\ 
	\hline 
	\end{tabular} 
	}
	\caption{Hyvään testattavuuteen vaikuttavat ominaisuudet jaoteltuna kahteen eri luokaan: laadulliset ja metriset.}
	\label{tab:goodArchTestability}
\end{table}

\noindent
Taulukossa \ref{tab:goodArchTestability} kootaan yhteen ominaisuudet, jotka ottavat kantaa laadullisiin tai mitattaviin ominaisuuksiin. On tärkeää tarkastella sekä komponenttien ulkoisia että sisäisiä ominaisuuksia, jotta voitaisiin muodostaa hyvä kuva testattavuuden tasosta. Kuitenkin suoraan rakenteellisuuden näkökulmasta esiin nousevat riippuvuudet, kytkentä ja koheesio. Näistä kaikki ovat mitattavia ominaisuuksia ja niitä varten onkin kehitetty konkreettisia mittareita havaitsemisen tueksi.  


\subsection{Arkkitehtuurin testattavuuden mittaaminen} \label{arch_testability_measurement}

Ylläpidettävyys on vaikuttava piirre testattavuuteen, joten on luonnollista tarkastella myös sen kautta järjestelmän testattavuutta. Ylläpidettävyyden näkökulmasta on tunnistettu erilaisia arkkitehtuurisen tason mittareita arkkitehtuurisille elementeille ja niiden avulla voidaan mitatata järjestelmän ominaisuuksia, kuten kytkennän ja koheesion tasoa \citep{bengtsson1998towards}.  

\iffalse


\begin{itemize}
	\item metodien määrä elementin rajapinnassa
	\item paikkamerkkien (placeholder) määrä arkkitehtuurisille elementeille, joiden avulla elementti parametrisoidaan
	\item elementistä lähtevien viestien määrä
	\item elementtityyppien määrä, joita tarkasteltava elementti toteuttaa (implement)
	\item elementtien määrä, jotka toteuttavat tarkasteltavan elementin tyypin
	\item saatavilla olevien metodien lukumäärä muista elementeistä, jotka ovat yhteydessä tarkasteltavaan elementtiin
	\item elementin metodien ja parametrien määrä
\end{itemize}
\fi


\begin{table}[H]
	\centering
	\setlength{\extrarowheight}{4pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{|m{10cm}|m{4cm}|}
	\hline 
	\textbf{Mittari} & \textbf{Tarkkuuden taso} \\ 
	\hline 
	Metodien määrä elementin rajapinnassa & Matala \\ 
	\hline 
	Elementin metodien ja parametrien määrä & Matala\\ \hline
	Saatavilla olevat metodit muualta & Matala\\ \hline
	Lähtevien viestien määrä & Matala/Korkea\\ \hline
	Paikkamerkkien (placeholder) määrä & Korkea\\ \hline
	Elementtityyppien määrä, joita tarkasteltava elementti toteuttaa & Korkea\\ \hline
	Elementtien määrä, jotka toteuttavat tarkasteltavan elementin tyypin & Korkea\\ \hline

	\end{tabular} 
	\caption{Mittarit, joiden avulla ylläpidettävyyttä voidaan mitata. Tarkkuuden taso on skaalattu arkkitehtuurin näkökulmasta matalasta korkeaan. Matala tarkoittaa, että kuvaus on lähellä ohjelmakoodia ja korkea, että mittaria pystytään käyttämään myös abstraktimmalla tasolla.}
	\label{tab:maintainMeters}
	}
\end{table}

\newpage

\noindent
Taulukkoon \ref{tab:maintainMeters} kootuista mittareista nähdään, että mittarit jakautuvat karkeasti kahteen eri tarkkuuden tasoon: matalaan ja korkeaan. Syy siihen on, että arkkitehtuurisen kuvauksen ollessa abstraktio ohjelmakoodista on luonnollista, että eri tarkkuuden tasoilla on mahdollista liikkua. Tunnistetuiden mittareiden ominaisuuksista taas nähdään samankaltaisuutta kappaleen \ref{testability_measure} määriteltyjen mittareiden kanssa, mutta tunnistetut mittarit tarkastelevat korkeampaa tasoa. Kytkentä ja koheesio, joita kummatkin mittarisarjat osittain mittaavat,  määriteltiin tavoiksi mitata järjestelmän testattavuutta. Kytkentää voidaan tutkia analysoimalla ohjelmistojärjestelmän komponenttien välisiä suhteita ja koheesiota tutkimalla kuinka itsenäisiä komponentit ovat.

\subsubsection{UML-kaaviot testattavuuden mittaamisessa} \label{uml_arch_test}

UML-luokkakaavio toimii hyvänä pohjana, kun halutaan mitata luokkien välisiä suhteita ja riippuvuuksia \citep{baudry_testability_2002} ja sen avulla voidaan määritellä testattavuuden antimalli (testability anti-pattern), joka on luokkakaavioiden avulla esille tuleva ilmiö \citep{baudry_measuring_2003}. Antimallissa kaksi suurta tekijää vaikuttavat testattavuuteen negatiivisesti: luokkien välinen suuri interaktio ja itsekäyttö, jossa luokka on riippuvainen rekursiivisesti itsestään. Syitä näiden kahden esiintymiselle voi olla luokkien välinen suuri kytkentätaso, riippuvuuksien syklimäisyys ja luokkien välinen suuri kommunikaatiotaso. Yhdessä nämä tekijät vaikeuttavat paljon vastuiden jakamista ja kasvattavat tarvittavien testitapausten määrää. 

Antimallin osatekijöiden löytyminen arkkitehtuurista on siis vihje siitä, että arkkitehtuuri saattaa sisältää testauttavia vaikeuttavaa rakennetta. Osatekijöitä voidaan tarkastella esimerkiksi UML:n avulla luotavalla erityisellä riippuvuusgraafilla \citep{baudry_testability_2002}. Riippuvuuksien vähentäminen on kytkennän kannalta tärkeää ja on mahdollista tarkastella testauksen kannalta kriittisten riippuvuuksien poistoa analysoimalla luokkakaaviosta saatavia ominaisuuksia \citep{Jungmayr:2002}. Riippuvuudeksi lasketaan mikä tahansa komponenttien välinen interaktio, jossa komponentti joutuu käyttämään toisen komponentin tarjoamia palveluita (usein metodeja) suorittaakseen toiminnallisuuttaan. 

Riippuvuuksiin littyviä tekijöitä voidaan havainnollistaa seuraavan taulukon avulla, jossa jokaiselle testautta vaikeuttavalle ominaisuudelle on annettu myös tapa, jolla ominaisuutta on mahdollista tarkastella helposti.


\begin{table}[H]
	\centering
	\setlength{\extrarowheight}{10pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabularx}{500pt}{|X|X|X|}
	\hline 
	\textbf{Ominaisuus} & \textbf{Tapa havaita} & \textbf{Lähde} \\ 
	\hline 
	Kompleksiset perintäsuhteet & Graafimalli & \citep{baudry_testability_2002} \\ 
	\hline 
	Abstraktien luokkien liikakäyttö rajapintojen sijasta & Graafimalli & \citep{baudry_testability_2002} \\ 
	\hline 
	Metriikat
	\begin{itemize}
		\item Riippuvuuksien määrä komponenteissa 
		\item Komponenttien määrä riippuvuussykleissä
		\item Feedback-riippuvuuksien määrä\footnote{Feedback-riippuvuus on syklinen riippuvuussuhde komponenttien välillä, josta poistamalla jokin riippuvuus saadaan sykli purettua täysin.}
	\end{itemize}	 
	& Graafimalli ja luokkakaavio & \citep{Jungmayr:2002}\\ \hline
	\end{tabularx} 
	\caption{Tekijöitä ongelmallisten riippuvuuksien syntymiselle.}
	\label{tab:problemDepend}
	}
\end{table}

\noindent
Taulukossa \ref{tab:problemDepend} olevista tekijöistä huomataan, että riippuvuuksien tarkastelu testattavuuden kannalta on mahdollista UML-kaavion ja graafimallin avulla. Varsinkin sykliset riippuvuudet tulevat ilmi testattavuutta heikentävänä tekijänä, joiden tarkastelu ei välttämättä tule ollenkaan ilmi kooditasolla.  

UML on auttanut työkaluna löytämään yhteydellisiä ominaisuuksia arkkitehtuurissa, joita tarkastellessa voidaan sanoa tarkasteltavan  kytkennän tasoa, kompleksisuutta ja riippuvuuksia. Komponenttien sekä yhteyksien tarkastelu oli myös luvussa \ref{ark} esitelty eräs näkemys ohjelmistoarkkitehtuuriin ja on järjestelmän todellisen testattavuuden määrittelemisen kannalta parempi, jos testattavuutta voidaan tarkastella myös korkealla tasolla. Liian tarkka kuvaus järjestelmästä vaikeuttaa todellisten ongelmien näkemistä, koska se vie aikaa ymmärtää ja keskittyy liian pikkutarkkoihin asioihin, jotka eivät kaikki välttämättä ole relevantteja testattavuuden analysoinnin kannalta. Ylätason kuvauksella on etuna myös se, että sen avulla pystytään löytämään helposti usein esiintyviä ongelmallisia tilanteita, joiden tunnistaminen auttaa järjestelmän testattavuuden hallinnassa.

 
%UML on mahdollistanut testattavuuden arvioimisen ohjelmistojärjestelmissä, koska löydetyistä mittareista huomataan, että ne mittaavat esimerkiksi komponenttien ominaisuuksia ja yhteyksiä, jotka tulevat esille kunnolla vasta arkkitehtuurisella tasolla. Komponenttien sekä yhteyksien tarkastelu oli myös luvussa \ref{ark} esitelty eräs näkemys ohjelmistoarkkitehtuuriin ja on järjestelmän todellisen testattavuuden määrittelemisen kannalta parempi, jos testattavuutta voidaan tarkastellaan korkealla tasolla. Liian tarkka kuvaus järjestelmästä vaikeuttaa todellisten ongelmien näkemistä, koska se vie aikaa ymmärtää ja keskittyy liian pikkutarkkoihin asioihin, jotka eivät kaikki välttämättä ole relevantteja testattavuuden analysoinnin kannalta. Ylätason kuvauksella on etuna myös se, että sen avulla pystytään löytämään helposti usein esiintyviä ongelmallisia tilanteita, joiden tunnistaminen ja välttäminen auttaa järjestelmän testattavuuden hallinnassa.

\subsection{Arkkitehtuuriset hajut ja testattavuus} \label{arch_smells_and_testability}

Arkkitehtuurisiin hajuihin on alettu kinnittää yhä enemmän huomiota ohjelmien monimutkaistuessa ja suunnittelun tulevan yhä tärkeämmäksi osaksi ohjelmistojen elinkaarta. Ne ovat sukua tutummalle käsitteelle koodihaju, mutta tulevat esille arkkitehtuurisella tasolla, kun koodihajut tulevat esille luokkatasolla ja vaativat melkein aina lähdekoodin tunnistamisen tueksi. Arkkitehtuuriset hajut ovat pääosin suunnittelupäätöksiä, jotka negatiivisesti vaikuttavat järjestelmän elinkaareen ja muun muassa testattavuuten sekä ylläpidettävyyteen. Niitä ei voi pitää välttämättä virheinä, mutta ne vaikuttavat vähintään aina negatiivisesti laatuun \citep{de_andrade_architectural_2014}. Syitä arkkitehtuurisille hajuille voidaan nähdä olevan muun muassa: suunnittelumalli väärässä kontekstissa;  suunnitteluabstrahoinnin (design abstraction) käyttö niin, että sillä on ei-toivottuja vaikutuksia; suunnitteluabstrahoinnin käyttö väärällä tarkkuuden tasolla. Tutkimiseen voidaan käyttää analyyttistä lähestymistapaa, koska arkkitehtuuristen hajujen lähtökohtana toimii joku virheellinen arkkitehtuurinen päätös.

%Testattavuus \citep{garcia_identifying_2009} yleisesti \citep{bertran_detecting_2011}.

Yleisesti on kuitenkin helpompi tutkia visuaalista informaatiota ja tämän avulla arkkitehtuuriin vaikuttavia hajuja. Arkkitehtuurisia hajuja voidaan löytää seuraavien metriikoiden avulla \citep{bertran_detecting_2011}

\begin{itemize}
	\item ei-haluttujen asiakas-komponenttien (client component) määrä
	\item komponentin vastuiden määrä
	\item komponentin konnektoreiden määrä
	\item komponentin erilaisten konnektoreiden määrä
	\item komponenttien välinen riippuvuuksien hajauma.
\end{itemize}

%\citep{HotSpot} arkkitehtuuriset hajut "hotspotit"\ 5kpl + kaikista altin virheille oli \citep[s. 57]{HotSpot} Unstable Interface \& Cross-Module Cycle.

\noindent
Näiden metriikoiden avulla sekä näkymällä moduulitasoon, olisi esimerkiksi hyvin mahdollistaa löytää yksi virhealttiillisin arkkitehtuurista löytyvä ongelmakohta \textit{Cross-Module Cycle} \citep[s. 57]{HotSpot}. \textit{Cross-Module Cycle} on olemassa arkkitehtuurissa silloin, kun siinä on syklinen riippuvuussuhde moduulitasolla. Se vaikeuttaa testattavuutta siten, että testauksen aikana yhden moduulin testaaminen vaatii käytännössä myös kaikkien muiden moduulien testauksen, jolloin testitapausten eriyttäminen vaikeutuu huomattavasti. Sykliset riippuvuudet todettiin olevan myös kappaleessa \ref{good_testability} yksi testattavuuteen vaikuttava tekijä, mutta arkkitehtuurisia hajuja, jotka suoraan vaikuttavat testattavuuteen, voidaan tunnistaa olevan ainakin kaksi lisää \citep{garcia_identifying_2009}:  \textit{Connector Envy} ja \textit{Scattered Parasitic Functionality}.

\textit{Connector Envy} on tilanne, jossa komponentti toteuttaa konnektorille kuuluvaa toiminnallisuutta eli toteuttaa esimerkiksi joko kommunikointia, koordinointia tai tiedon konversiota. Nämä toiminnallisuudet tulisi jättää konnektorin toteutettavaksi, koska komponentin toiminnallisuus ja interaktiot eivät ole enää erillään testattavia ominaisuuksia. Tilanteena se johtaa siihen, että ei pystytä enää varmasti sanomaan, että mikä kohta komponentissa oli virheellinen, jos se testauksen aikana hajoaa. \textit{Scattered Parasitic Functionality} syntyy, jos useammalla komponentilla on sama vastuu ja komponentit ovat itsenään vastuussa vielä jostain muusta vastuusta. Testattavuus kärsii tästä, koska esimerkiksi integraatiotestauksen aikana tapahtunut virhe vaikuttaa laajalla alueella ja vaikeuttaa vian alkuperän määrittämistä. 

\newpage
Testaukseen vaikuttavista arkkitehtuurisista hajusta voidaan huomata, että ne pyrkivät löytämään sykliset riippuvuudet, huonon koheesion ja mahdollisen riippuvuuksien jakautumisen turhan laajalle. Samat asiat jotka vaikuttavat luokkatasolla testattavuuteen vaikuttavat arkkitehtuurisella tasolla, mutta hieman eri tavalla. Arkkitehtuurisella tasolla tarkasteltavana voi olla usean eri luokan kokonaisuus eli komponentti, kun luokkatasolla tarkastelun alla voi olla yksittäiset luokat ja jopa yksittäiset metodit.


\subsubsection{Koodihajujen ja arkkitehtuuristen hajujen suhde}

Arkkitehtuurin ja ohjelmakoodin suhde on luonnollisesti hyvin vahva ja monissa metriikoissa nähdään samankaltaisuuksia. Tätä suhdetta selittämään on tuota käsite hybridihajut, jotka ovat sekoitus koodihajuja ja arkkitehtuurisia hajuja tuoden uuden näkökulman arkkitehtuuristen hajujen löytämiseksi myös testattavuuden kannalta. Koodipoikkeama (code anomaly) luetaan hybridihajuksi, jos sen vaikuttamat luokat ovat vastuussa arkkitehtuurisista elementeistä vaikuttamissa arkkitehtuurisissa elementeissä on arkkitehtuurisia ongelmia \citep{vale_bad_2014}. Hybridihajujen tunnistaminen on siis eräs keino helpottaa arkkitehtuuristen hajujen löytämistä. Löytämällä koodihajujen pohjalta arkkitehtuurisiin vaikuttavia ongelmallisia luokkia, voidaan tunnistaa arkkitehtuurisella tasolla vastaavat arkkitehtuuriset hajut ja elementit. Arkkitehtuuristen hajujen tunnistaminen saattaa taas antaa tärkeää tietoa pinnan alla piilevistä koodihajuista.

On tutkittu, että tietyt koodihajut ovat indikaattoreita arkkitehtuurisista hajuista aspektiorientoituneissa järjestelmissä ja tietyt ominaisuudet kooditasolla ovat syynä arkkitehtuurisiin hajuihin \citep{macia_impact_2011}. Seuraavassa taulukossa on lueteltu, että mitkä havaitut kooditason ongelmat löydettiin vaikuttavan arkkitehtuurisiin hajuihin. 

% EI SELITTÄMÄTTÖMIÄ OSIA


\begin{table}[ht]
	\centering
	\setlength{\extrarowheight}{1pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{| m{5cm} | m{7cm} |}
	\hline 
	\textbf{Arkkitehtuurinen haju} & \textbf{Syy kooditasolla} \\ \hline
	\textit{SPF} & Liikaa vastuita \\ \hline
	\textit{SPF, Connector Envy} & Liikaa suoria vastuita \\ \hline
	\textit{SPF} & Liikaa riippuvuuksia \\ \hline
	\textit{SPF} & Samankaltaista toiminnallisuutta \\ 
	\hline
	\end{tabular}
	}
	\caption{Arkkitehtuurinen haju ja syy sen esiintymiselle kooditasolla. Vastaava koodihaju on jätetty pois, koska niiden nimien tietäminen ei ole relevanttia tutkimuksen kannalta.}
	\label{tab:aspectSmells} 
\end{table}


%Koodi ja arkkitehtuuri-info. Detection strategies \citep[s. 179-182]{macia_enhancing_2013}

\noindent
Vaikka taulukon \ref{tab:aspectSmells} koodihajut eivät suoraan koske olio-pohjaisia järjestelmiä, niistä voidaan silti nähdä, että ongelmat tulevat liiallisista vastuista, liiallisista riippuvuuksista ja samankaltaisesta toiminnallisuudesta. Nämä ominaisuudet ovat nähtävissä hyvin tavallisissakin olio-pohjaisissa järjestelmissä ja on määritelty, että mitkä arkkitehtuuri-herkät koodipoikkeamat olisivat vastuussa arkkitehtuurisista hajuista puhtaissa olio-järjestelmissä \citep{macia_enhancing_2013}.

Seuraavassa taulukossa on muodostettu löydetyt koodihajut, jotka indikoivat pahemmasta ongelmasta arkkitehtuurisella tasolla.

% NÄÄ VOIS SELITTÄÄ ESIM ALAINDEKSISSÄ


\begin{table}[h]
	\centering
	\setlength{\extrarowheight}{1pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{| l | l | m{6cm} |}
	\hline
	\textbf{Koodihaju} & \textbf{Arkkitehtuurinen haju} & \textbf{Syy}\\ \hline
	\textit{God Class}\footnote{Luokka, joka tekee suuren osan järjestelmän toiminnallisuudesta.} & \textit{SPF, Connector Envy} &  Toiminnallisuus liian keskittynyttä, liialliset vastuut\\ \hline
	
	\textit{Misplaced Class}\footnote{Luokka, joka on väärässä moduulissa/komponentissa.} & \textit{Cyclic Dependencies, SPF} & Riippuvuuksia enemmän komponentin ulkopuolelle kuin sisäpuolelle\\ \hline
	\end{tabular}
	}
	\caption{Olioperäisten koodihajujen ja arkkitehtuuristen hajujen suhde, sekä niiden syyt.}
	\label{tab:codeSmells}
\end{table}


\noindent
Taulukon \ref{tab:codeSmells} suhteista nähdään hieman samanlaisuutta, kuin mitä taulukko \ref{tab:aspectSmells} näytti syinä sen koodihajuille. Suurimmat ongelmat olioperäisissäkin hajuissa tulivat liiallisista riippuvuuksista ja huonosta vastuiden jaosta, joka saattaa johtaa yksittäisten komponenttien paisumiseen. Yksittäisten komponenttien paisuminen taas luo helposti huonoa kompositiota, toistuvaa toiminnallisuutta ja komponentteja, joiden harteilla on iso osa toiminnallisuuden toteuttamisesta. Nämä ongelmat realisoituvat arkkitehtuurisiksi hajuiksi arkkitehtuuritasolla ja niiden tunnistaminen kooditasolta arkkitehtuuriselle tasolle ja arkkitehtuuriselta tasolta kooditasolle on tärkeää testattavuuden kannalta.


%Koodihajujen tunnistaminen arkkitehtuurisen degraation tunnistamiseksi \citep{fontana_towards_2015}. Vaikuttavat ylläpidettävyyteen. God Class, Data Class, Brain Method, Shotgun Surgery, Dispersed Coupling, Message Chains. Metriikoina käytettiin muun muassa: Tight Class Cohesion, Access to Foreign Data, Number of Public Attributes, Maximum Nesting Level, Coupling Intensity. Co-Occurence of smells. 

Tarkastelu voidaan keskittää myös enemmän aiheisiin kuten mistä koodihajut johtuvat tai mitkä tekijät koodihajuissa vaikuttavat arkkitehtuuristen hajujen esiintymiseen järjestelmissä. Tähän avuksi on luotu erityisen näkymä koodihajujen tunnistamiseksi ja sen avulla voidaan tunnistaa kytkentään ja koheesioon vaikuttavia koodihajuja \citep{fontana_towards_2015}. 

\begin{table}[H]
	\centering
	\setlength{\extrarowheight}{4pt}%
	\resizebox{\linewidth}{!}{
	\begin{tabular}{| m{4cm} | m{8cm} | m{4cm} |}
	\hline
		\textbf{Koodihaju} & \textbf{Vastuussa} & \textbf{Vaikuttaa}\\ \hline
		\textit{God Class} & Suuret luokat & Koheesio \& Kytkentä\\ \hline
		\textit{Long Method} & Pitkät metodit & Koheesio \& Kytkentä\\ \hline
		\textit{Dispersed Coupling} & Laajalle hajautunut kytkentä & Koheesio \& Kytkentä\\ \hline
		\textit{Shotgun Surgery} & Replikoituvasta muutoksen vaatimasta kohdealueesta & Koheesio\\ \hline
	\end{tabular}
	}
	\caption{Suoraan kytkentään ja koheesioon suhteessa olevat koodihajut. }
	\label{tab:coupAndCohes}
\end{table}


\noindent
Taulukon \ref{tab:coupAndCohes} tekijöistä nähdään, että ongelmat syntyvät, jos jokin luokka on liian suuri, sisältää riippuvuuksia paljon muihin luokkiin ja jonka toiminnallisuus on hajautunut niin laajalle, että sen muuttaminen vaatii usean muutoksen eri kohteisiin. Tätä samaa ideaa olisi mahdollista soveltaa myös arkkitehtuurisella tasolla ja tutkia komponenttien näkökulmalta samoja asioita. 

On edellisten tarkasteluiden nojalla selvää, että hyvä kytkennän ja koheesion taso ovat tavoteltavia ominaisuuksia sekä kooditasolla että arkkitehtuuritasolla. Testattavuuden kannalta voidaan arvioida mitkä tekijät aiheuttavat kahta mainittua testattavuuteen vaikuttavaa arkkitehtuurista hajua, josta tuloksena saatiin, että merkkittäviä tekijöitä olivat vastuut, riippuvuudet, koheesio, kytkentä. Tekijöiden mittaamisen apuna arkkitehtuuriselta tasolta voidaan muun muassa käyttää luvussa \ref{arch_testability_measurement} esiteltyjä mittareita. Hybridihajujen tunnistaminen on yleisesti tärkeää, koska ne saattavat toimia kriittisenä linkkinä arkkitehtuurin ja koodipohjaisten ongelmien välillä. 


\subsection{UML uusien näkymien tukena}


Standardi UML-kaavio ei itsessään riitä näyttämään kaikkia testattavuuden kannalta tärkeitä näkökulmia arkkitehtuurisella tasolla, mutta sen tueksi on luotu useita menetelmiä, jotka hyödyntävät esimerkiksi jo valmista UML-luokkakaaviota. Eräs näistä on \textit{class dependency graph model} \citep{baudry_testability_2002}, joka kappaleessa \ref{uml_arch_test} tuli esille. Sen avulla on mahdollista nähdä muun muassa luokkien välistä suurta interaktiota, itsekäyttöä, interaktioiden kompleksisuutta, pitkiä luokkahierarkisia haaraumia ja kompleksisia periytymisiä rajapintatasoilla.
Kaikista näistä olisi mahdollista luoda erilaisia metriikoita ja saada laskettua kytkennän, perinnän ja yleisen kompleksisuuden tasoa testattavuuden näkökulmalta. Mutta tämä tuottaa ongelmia, koska jotkut tulokset saattavat olla vääriä niiden sisältäessä virheellistä esiintymää (false-positive results). Tähän ongelmaan on ehdotettu UML-kaavion jatkamista stereotyyppien avulla. Uusia kytköksiä riippuvuuksille ehdotetaan 4 kappaletta \citep[s. 4]{baudry_measuring_2003}

\begin{itemize}
	\item \textit{create}, jos luokka A luo luokan B
	\item \textit{use}, jos luokka A voi kutsua kaikkia B:n metodeja, muttei luo sitä
	\item \textit{use\_consult}, jos A:n kutsumat metodit eivät muokkaa B:n sisäistä tilaa
	\item \textit{use\_def}, jos yksikin A:n kutsuma metodi muokkaa B:n sisäistä tilaa
\end{itemize}

\noindent
Kyseisten stereotyyppien avulla saadaan esille riippuvuudet ja niiden tyypit paremmin kaavioissa virheellisten tuloksien välttämiseksi. On esimerkiksi usein melko normaalia oliojärjestelmissä, että yksi luokka saattaa luoda useita riippuvuuksia muihin luokkiin, mutta tämä on tehty tarkoituksella eikä vahingossa kehittäjien toimesta. Näin on esimerkiksi tehdas-mallin (factory pattern) käytössä, jossa erikseen määritelty tehdas-olio on riippuvainen useiden eri luokkien synnystä. Se vähentää globaalisti riippuvuuksien määrää, mutta itse tehdas-oliot tuottaisivat metriikoiden mukaan paljon virheellisiä riippuvuusongelmia, jos jokainen riippuvuus olisi samanarvoinen.



%\subsection{Erilaiset menetelmät UML-kaavoiden tukena}
%Muita keinoja tutkia -> formulointi (Design Structure Matrix) \citep{mo_mapping_2013}

%Erilaisia skenaariopohjaisia menetelmiä ehdottaa \citep[s. 8-9]{mattsson2006software} testattavuuden kannalta: SAAM, ATAM, EBAE.

%Riippuvuuksien anti-pattern (7 kpl) ja niiden havaitseminen lähdekoodin avulla. Pystyisikö soveltamaan myös arkkitehtuurisella tasolla? \citep{binkley_dependence_2008} 

\subsection{Havaitut testattavuuteen vaikuttavat tekijät}

Seuraavalla sivulla olevan taulukkoon \ref{tab:conclusions} on kerätty tutkielman aikana löydetyt tekijät, jotka testattavuuteen vaikuttavat rakenteellisella tasolla eli tasolla, jossa rakennetta pystytään analysoimaan ja arvioimaan erilaisten näkökulmien silmin. Taulukkoon on pyritty keräämään vain keskeisiä asioita, joiden tarkastelu onnistuu sekä arkkitehtuurisella tasolla, että kooditasolla. Kooditasolla tarkastelu voidaan aloittaa tutkimalla löydettyjä ominaisuuksia yksittäisille luokille, jotka ovat sidoksissa vahvasti tärkeisiin arkkitehturaalisiin elementteihin, kun taas arkkitehtuurisella tasolla paino voidaan kiinnittää laajempiin kokonaisuuksiin, kuten komponetteihin ja mooduleihin.  

On kuitenkin huomattava, että ominaisuudet jakautuvat varsinkin järjestelmän tasolla laadullisiin ominaisuuksiin, joiden mittaaminen suoraan ei aina ole edes kovin mahdollista. Tällöin analyysin avuksi on otettava esimerkiksi dokumentaatiota järjestelmästä, komponenttien suunnittelusta vastuussa olevien ihmisiä, koko komponentin toteuttavaa ryhmää tai yleisesti koottua ryhmää, jonka kanssa komponentteja ja rakennetta tarkastellaan testattavuuden näkökulmasta. Näin pystytään muodostamaan hyvä kuva testattavuuden tasosta ilman metrisiä mittareita, jotka vaativat jotain formalismia taustalleen virheellisten tuloksien minimoimiseksi.

Jokainen määritelty ominaisuus on kuitenkin sekä laadullinen että mitattava ominaisuus. Tällöin ei voida suoraan sanoa, että olisi olemassa yksi tapa, jonka avulla 

Kuitenkin mittarit toimivat

\begin{sidewaystable}[htbp]
	\centering
	\captionsetup{width=\columnwidth}
	\setlength{\extrarowheight}{10pt}%
	
		\resizebox{\linewidth}{!}{
	
		\begin{tabular}{| m{5cm} | m{8cm} | m{6cm} | m{6cm} |}
		\hline
	\textbf{Tekijä} & \textbf{Tarkennus} & \textbf{Menetelmä} & \textbf{Lähde}\\ \hline
	
		Järjestelmän ominaisuudet & Komponenttien testattavuus, vastuut, vaatimukset, havaittavuus, hallittavuus, jäljitettävyys  & Analysointi, pentagrammimalli & \citet{Binder:1994:DTO:182987.184077, baudry_measuring_2003, gao_component_2005, joshi_design_2014}  \\ \hline	
	
		Kompleksisuus & Kompleksinen toteutus, kompleksiset perintäsuhteet & Metriikat, UML, Graafimalli & \citet{Binder:1994:DTO:182987.184077, baudry_testability_2002, baudry_measuring_2003, Dubey:2011:AMM:2020976.2020983} \\ \hline	
		
		Perintä & Ongelmalliset ja liialliset perintäsuhteet & Metriikat, UML, Graafimalli & \citet{baudry_testability_2002, Dubey:2011:AMM:2020976.2020983} \\ \hline	
		
		Kytkentä & Itsekäyttö, suuret kytkentätasot & Metriikat, UML, Graafimalli, hajut & \citet{Dubey:2011:AMM:2020976.2020983, joshi_design_2014} \\ \hline		
		
		Riippuvuudet & Syklimäisyys, määrä, antimalli & UML, graafimalli, hajut & \citet{baudry_testability_2002,Jungmayr:2002,joshi_design_2014} \\ \hline
		
		Koheesio & Toiminta huonosti keskitettyä & Metriikat, hajut, analysointi & \citet{garcia_identifying_2009, joshi_design_2014} \\ \hline
		
		Vastuut & Vastuut jakautuneet huonosti & Hajut, UML & \citet{garcia_identifying_2009} \\ \hline
		
		\end{tabular}
		}
		
		\caption{Testattavuuteen vaikuttavat tekijät arkkitehtuurisella tasolla. Tarkennus-sarake antaa lisätietoa menetelmästä ja Menetelmä-sarake kuvaa miten niitä voidaan havaita. Lähde-sarake kertoo mikä tutkimus on tutkinut aihetta ja mahdollisesti esittänyt jonkun menetelmistä.}
	
	\label{tab:conclusions}		
		
	\end{sidewaystable}

\newpage



\section{Pohdinta} \label{pondering}

Ensin metriikat sitten esim. pentagrammimallin avulla analysointia per komponentti.

Löydetyt samankaltaisuudet

Metriikat + riippuvuusgraph.

Onko arkkitehtuurin kuvaaminen visuaalisesti aina formaalia?

% muista Viittaukset kappaleisiin

\newpage

\section{Yhteenveto}

Tutkimuksessa on tehty katsaus ensin ohjelmistoarkkitehtuuriin käsitteenä ja luotu sen avulla katsaus siihen miten ohjelmistoarkkitehtuuria mallinnetaan. Ohjelmistoarkkitehtuuri on nähty tapana kuvata järjestelmän todellista rakennetta tavalla, joka kertoisi mahdollisimman selkeästi järjestelmän todellisen luonteen ilman tarvetta lähdekoodille. Katsauksen jälkeen on etsitty vastausta sille mitä on järjestelmän testattavuus. Testattavuudesta on jatkettu tarkastelua arkkitehtuuriselta näkökulmalta viimeisessä luvussa ja etsitty tapoja joiden avulla arkkitehtuurin mallinnus tuottaisia mahdollisimman paljon informaatiota järjestelmän testattavuudesta.

Tästä tutkimuksesta nähdään tutkimuskysymyksien valolla, että

\newpage

%Muistuttaa mieleen tutkimuskysymyksen, mainitsee tärkeimmät tulokset ja niiden perusteet. Keskittyy impaktiin ja esimerkiksi suosituksiin. Ei vain summeeraa luku kerrallaan aikaisempaa tekstiä.

% miten testattavuus näkyy ohjelmistojen arkkitehtuurisella tasolla

% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

%\bibliographystyle{babalpha-lf}
\bibliographystyle{apsr}
\bibliography{references-fi}


% --- Appendices ---

% uncomment the following

% \newpage
% \appendix
% 
% \section{Esimerkkiliite}

\end{document}
