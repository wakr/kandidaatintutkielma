% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage{amsmath}
\numberwithin{table}{section}


\usepackage[sort]{natbib} %uncomment for a harvard-style
%\usepackage[square,sort,comma,numbers]{natbib}

\usepackage{array}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:


% testattavuus & arkkitehtuuri
\title{Testattavuus ja ohjelmistoarkkitehtuuri}
\author{Kristian Wahlroos}
\date{\today}
\level{Kandidaatintutkielma}

% ; kenelle, miksi, millaisessa ympäristössä; tutkimuskysymys; tulokset; impakti)

\abstract{tiivistelmä (100-200 sanaa)}

% The following can be used to specify keywords and classification of the paper:

\keywords{ohjelmistoarkkitehtuuri, testattavuus, näkymä, näkökulma}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):" 
 
 \classification{
	Software and its engineering $\rightarrow$ System description languages 	\\
	Software and its engineering $\rightarrow$ Software defect analysis
 }
% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
%\numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}

% Write some science here.

%Esimerkkilause ja lähdeviite~\cite{esimerkki} ja \cite{esimerkki2}.
%jäsennelty asianmukaisesti (kenelle, miksi, millaisessa ympäristössä; ratkaisun lähestymistapa; tutkimuskysymys, tulokset ja impakti; loppulukujen roolitus).




%\section{Johdanto}
%purkaa auki teknisemmälle yleisölle samalla käsitteitä määritellen tutkimuskysymyksen, ratkaisuille ympäristöstä esiintulevat vaatimukset ja keskeiset käsitteet näiden asioiden esittelemiseksi.

%antaa riittävästi termistöä ja kysymyksenasetteluja, jotta myöhempänä teksissä on mahdollisuus analyysiin ja evaluointiin.
%Keskimmäiset luvut keskittyvät kukin "opettamaan" lukijalle yhden osakysymyksen tai näkökulman käsiteltävään asiaan. Lukujen työnjaon tulisi olla selkeä ja niillä tulee olla selkeä oma rakenteensa, jonka valintaperuste on lukijalle kerrottu.

%Viimeistä edellinen luku on varsinaisen kontribuution koti: vertailu, soveltaminen, osien synteesi ja mahdolliset evaluointimenetelmät ja -tulokset pääroolissa.

Ohjelmistoarkkitehtuuri on ohjelmistojen ymmärtämisen kannalta tärkeä konsepti, josta jokaisen ohjelmoijan pitäisi olla tietoinen, sillä jokaisella ohjelmistojärjestelmällä on oma arkkitehtuurinsa \citep[s. 4]{ieee_2000}. Suunnittelematon arkkitehtuuri eli niin sanottu \textit{Big Ball of Mud} saattaa pahimmassa tapauksessa olla yksi epäonnistuneen projektin tunnusmerkkejä, kun taas hyvin muodostettu arkkitehtuuri auttaa eri sidosryhmien välisessä kommunikaatiossa, tekee tuotettavasta ohjelmistojärjestelmästä helposti lähestyttävän, helpottaa sekä ohjelmiston testausta että validointia ja on yksi suurimmista onnistumistekijöistä projektin jatkon kannalta. 

Ohjelmistojen ylläpidettävyys lasketaan yhdeksi ei-toiminnalliseksi laatuvaatimukseksi, ja siihen kuuluu vahvasti ohjelmistojen testattavuus, joka taas vaatimuksena on lähempänä ohjelmoijaa kuin asiakasta. Testausta tapahtuu ohjelmistojärjestelmän elinaikana useita kertoja, joista  aikaisimmat jo projektin alkumetreillä, kun halutaan evaluoida järjestelmän toiminnallisuutta. Testattavuus taas määrittelee kuinka hyvin järjestelmään kohdistuva testaus löytää mahdolliset virheet ja kuinka helppo testitapauksia on luoda. Arkkitehtuurin ja testattavuuden yhteys on kuitenkin hieman häilyvä, vaikka monelle kehittäjälle ovatkin tuttuja hyvät käytänneet olio-ohjelmoinnissa. Suuriosa opituista käytänneistä kuitenkin ottaa kantaa vain lähdekooditasolla tapahtuviin ongelmakohtiin, jolloin arkkitehtuurinen puoli saattaa jäädä kokonaan huomioimatta. Testauksen aikana löytyneet arkkitehtuuriset ongelmat taas kuluttuvat turhaa aikaa ja hidastavat koko ohjelmistotuotantoprosessia, koska ne löydetään usein liian myöhään. Tämä tutkielma pyrkii selventämään ohjelmistojärjestelmän rakenteen ja testattavuuden suhdetta sekä sitä, miten testattavuus tulee ilmi ohjelmistoarkkitehtuurissa. 

\subsection{Tutkimuskysymys}
Tutkimus vastaa kysymykseen miten testattavuus näkyy ohjelmistojen arkkitehtuurisella tasolla. Itse kysymys voidaan jakaa vielä tarkentaviin kysymyksiin: mitä ylipäätänsä on testattavuus ohjelmistojärjestelmissä ja mitkä tekijät siihen vaikuttavat, miten arkkitehtuuria on mahdollista kuvata, miten ohjelmistojärjestelmän arkkitehtuurista luotu näkymä kertoo jotain järjestelmän testattavuudesta. 

\subsection{Tutkimusmenetelmä}
Tutkimuskysymykseen vastataan kirjallisuuskatsauksen avulla ja tutkimalla mitkä seikat tuovat testattavuutta ohjelmistojärjestelmään. Näiden perusteella pyritään tunnistamaan kriittisiä arkkitehtuurisia ominaisuuksia, joiden avulla testattavuuden tasoa olisi mahdollista tarkastella järjestelmässä. Testattavuuden havaitsemiseen etsitään näkymää nykyisistä menetelmistä kuvata arkkitehtuuria. Näitä menetelmiä ovat pääasiassa erilaisten näkymien ja näkökulmien joukko, joiden avulla on mahdollista tuoda ohjelmistojärjestelmästä esiin joitain sen erityispiirteitä.

Itse tutkimus on rajattu pääosin ainoastaan oliopohjaiseen arkkitehtuuriin ja sen erilaisiin kuvaamistapoihin. Testaustavoista on tuotu esille yksikkö -ja integraatiotestaus. Arkkitehtuurin mallintamisesta on jätetty ADL:t (architecture description languages) pois, koska ne eivät tarjoa visuaalista näkymää arkkitehtuuriin ja ovat harvemmin käytössä monimutkaisuutensa vuoksi. Myöskään erilaisia arkkitehtuurisia tyylejä ei vertailla tutkimuksessa testattavuuden kannalta, vaan tutkimus keskittyy nimenomaan ohjelmistojärjestelmän konkreettisen rakenteen arvioimiseen testattavuuden kannalta.

\subsection{Tutkimuksen rakenne}

Kappaleessa \ref{software_architecture_main} käydään läpi ohjelmistoarkkitehtuuria käsitteenä ja luodaan pohja eri kuvaustavoille ohjelmistoarkkitehtuuria varten. Samalla kuvataan miten ja mistä näkymä voidaan luoda ohjelmistojärjestelmälle. Kappale \ref{testability_main} tarkentaa testattavuutta laadullisena tekijänä ja pyrkii määrittelemään mitä on testattavuus ohjelmistojärjestelmissä. Kappale \ref{arch_testability_main} etsii arkkitehtuurin ja testattavuuden välistä suhdetta. Viimeinen kappale \ref{pondering} pyrkii käsittelmään asiaa kirjoittajan omin pohdinnoin ja tulemaan jonkinlaiseen johtopäätökseen tutkielman aiheesta.  


\section{Ohjelmistoarkkitehtuuri} \label{software_architecture_main}
Arkkitehtuuri ohjelmistojärjestelmissä on käsite, joka ei ole kovin yksiselitteinen eikä siitä ole yksimielistä määritelmää \citep[s. 363]{solms_what_2012}. 
Ohjelmistoarkkitehtuuri kuitenkin kuvaa vähintään aina abstraktilla tasolla toteutettavaa ohjelmistojärjestelmää niin, että on mahdollista keskittyä vain suppeaan alueeseen jättämällä pois eri sidosryhmien kannalta epärelevantteja asioita. Arkkitehtuurin kuvaaminen tapahtuu usein visuaalisella tavalla, koska visuaalisesta mallista on nopea ja helppo saada ulos tarvittava informaatio. Visuaalisen mallin avulla voidaan ohjelmistojärjestelmästä myös nähdä uutta informaatioita, joka muuten olisi piilotettu lähdekoodiin kehittäjän omina ajatuksina.   

\subsection{Ohjelmistojen arkkitehtuuri käsitteenä} \label{ark}
Ohjelmistoarkkitehtuuri voidaan nähdä karkeasti neljästä eri näkökulmasta  \citep[s. 2-7]{gorton_understanding_2011}:  ohjelmiston rakenteen kuvaajana, kuvaajana ohjelmiston komponenttien välisille suhteille, ei-toiminnalliset (non-functional) vaatimukset huomioon ottavana mallina ja yleisenä abstraktiona. 
% kappaleessa selitetään myös riippuvuuksien vähentämisestä

%Rakenteen kuvaajana arkkitehtuuri määrittelee ohjelmistojärjestelmän sisäistä rakennetta, joka koostuu useista komponenteista sekä moduuleista, jotka yhdistävät ja ryhmittelet komponentteja. Erilaiset moduulit tarjoavat aina tietyn toiminnallisuuden ja tämän kautta erilaiset vastuut on jaettu ohjelmistojärjestelmän sisällä loogiisiin kokoelmiin.
% kappaleessa myös patterneja

%Komponenttien välisen kommunikaation mallintaminen tapahtuu, kun ohjelmistojärjestelmää jaetaan erilaisiin komponentteihin. Tavoitteena on kertoa mallintamalla, että mitkä komponentit tai moduulit ovat vuorovaikutuksessa toistensa kanssa ja millä tavoin. Yleisin kommunikaatiotapa on esimerkiksi suorat funktiokutsut komponenttien välillä, joiden mallinnus selventää esimerkiksi informaation kulkua järjestelmässä.  
% kappaleessa ei-toiminnallisten vaatimuksien jako kolmeen eri luokkaan

%Ei-toiminnaliset vaatimukset tulevat kunnolla esille vasta arkkitehtuurin avulla ja arkkitehtuurin mallinnuksen avulla voidaan määrittää miten ohjelma suorittaa sille määrättyä tehtävää sen sijasta, että mallinnettaisiin ainoastaan mitä ohjelma tekee. 
% lähteitä lisää?

%Arkkitehtuurin avulla on mahdollista abstrahoida
%sidosryhmille ohjelmistojärjestelmää helpommin lähestyttäväksi, jolloin kommunikaatio eri osapuolten välillä helpottuu. Abstrahoinnin avulla pystytään yksinkertaistamaan järjestelmän konkreettista toteutusta ja suorittamaan arkkitehtuurista erittelyä (architectural decomposition), jossa muodostetaan epärelevanteista komponenteista mustia laatikoita (black boxes). Mustien laatikoiden ideana on piilottaa komponenttien sisäistä toteutusta eri abstraktiotasoilla, jolloin arkkitehtuurista voidaan muodostaa eri tarkkuustason malleja. 

Hieman samanlainen jaottelu on määritelty myös Solmsin tutkimuksessa \citep{solms_what_2012}. Siinä ohjelmistoarkkitehtuuri-määritelmä jaetaan kolmeen eri luokkaan: korkean tason abstraktioon ohjelmistojärjestelmästä, rakenteita sekä ulkoisia ominaisuuksia korostavaan määritelmään ja käsitteistöön sekä rajoitteisiin, joiden puitteissa ohjelmistojärjestelmää kehitetään. Näistä kaksi ensimmäistä määritelmää vastaavat samoja kuin \cite{gorton_understanding_2011} ja niitä voidaan mallintaa seuraavasti

\begin{itemize}
	\item korkean tason abstraktioita mallinnetaan erilaisten näkymien kautta tai käyttämällä IEEE:n määrittelemiä käytänteitä
	\item rakenteita korostavassa mallinnuksessa käytetään usein UML-kaavioita ja niiden tuomia keinoja abstrahoida järjestelmää.
	
\end{itemize}

% IEEE:stä voisi kirjoittaa enemmän    
%Rakenteita korostettaessa mallinnuksessa käytetään usein UML-kaavioita, koska UML määrittelee ohjelmiston arkkitehtuuria osina, joita pystytään rekursiivisesti tarkentamaan haluttaessa. Tarkennuksen avulla osat pystytään kuvaamaan kommunikoivan keskenään erilaisten rajapintojen kautta, osia yhdistäviä suhteita pystytään tarkastelemaan ja erilaisia rajoitteita pystytään luomaan osien välille. 
% järjestelmien välinen kommunikaatio se lähde.

%Kolmas määritelmä on paljon laajempi näkemys ohjelmistoarkkitehtuurista, koska se kuvaa ohjelmistojärjestelmän käsitteistön ja ominaisuudet siinä ympäristössä, jossa ne ilmenevät elementtien, suhteiden ja suunnittelun periaatteiden kautta. Peruskäsitteistö tarjoaa sen käsitteistön, jonka avulla sovelluslogiikka voidaan määritellä, joten esimeriksi määrittelemällä, että jokin komponentti toteuttaa palvelimen toiminnallisuutta, saadaan asiat lokeroitua käsitteellisesti erilleen toisistaan. Ominaisuudet liittyvät ohjelmistojärjestelmän laadullisiin ominaisuuksiin. Periaatteet voidaan nähdä järjestelmän keskeisinä suunnittelurajoitteina (core design constraints), joiden kokonaisuus muodostaa järjestelmän arkkitehtuurisen tyylin. Ohjelmistojärjestelmän arkkitehtuurin tyyli voi koostua esimerkiksi väylistä ja suodattimista (pipes and filters). % lisää


Näistä kahdesta eri jaottelusta ohjelmistoarkkitehtuuri-käsitteen välillä voidaan nähdä merkittävinä tarpeina kuvata ohjelmistojärjestelmän rakenteellisuutta, komponenttien välistä kommunikaatiota ja laadullisia vaatimuksia. Kaikki nämä edellämainitut ominaisuudet on saatava  upotettua ohjelmistojärjestelmästä luotavaan arkkitehtuuriseen malliin niin, että ne vastaavat muunmuassa seuraaviin kysymyksiin \citep[s. 31 - 33]{Rozanski:2011:SSA:2072649} 

\begin{itemize}
	\item mitkä ovat arkkitehtuurin toiminnalliset elementit
	\item miten nämä elementit kommunikoivat keskenään ja ulkomaailman kanssa
	\item mitä tietoa käsitellään, talletetaan ja esitetään
	\item mitä fyysisiä ja ohjelmallisia elementtejä tarvitaan tukemaan näitä  elementtejä
\end{itemize}

Arkkitehtuurista luotava malli ei saisi olla monoliittinen malli, joka pyrkii kuvamaan kaiken yhdessä mallissa, koska arkkitehtuuria ei ole mahdollista kuvata vain yhden mallin avulla \citep{Rozanski:2011:SSA:2072649}. Tämä johtuu siitä, että monoliittinen malli paisuu liian suureksi, jolloin sitä on vaikea kenenkään osapuolen enää ymmärtää ja siitä on vaikeaa löytää arkkitehtuurin tärkeimmät ominaisuudet. Monoliittinen malli on usein myös puutteellinen, jäljessä eikä vastaa enää nykyistä ohjelmistojärjestelmää.  


\subsection{Arkkitehtuurin kuvaus}

Ratkaisu monoliittiseen malliin on jakaa arkkitehtuurin kuvaus useisiin toisiinsa liittyviin näkymiin (views), jotka esittävät jokainen yhden näkökulman (viewpoint) järjestelmän arkkitehtuuriin keräämällä yhteen sekä toiminnalliset piirteet että laadulliset ominaisuudet \citetext{\citealp[s. 33-34]{Rozanski:2011:SSA:2072649}; \citealp[s. 8-9]{gorton_understanding_2011}; \citealp{Ran:1998:ASV:288408.288438}}.

Useiden erilaisten näkymien avulla on helpompi kommunikoida eri sidosryhmien välillä ja ne mahdollistavat järjestelmän tarkastelun vain niiltä osin, jotka tietty sidosryhmä kokee tärkeiksi. Yleisesti voidaan sanoa, että erilaiset näkymät auttavat jakamaan arkkitehtuurin vastuista pienempiin palasiin \citep[s. 2]{Galster:2011:DTC:2031759.2031761}. Vastuiden ja näkymien jakaminen taas auttaa jokaista ohjelmistoarkkitehtuuriin liittyvää prosessia tehden ohjelmistoarkkitehtuurin tarkastelusta, suunnittelusta ja toteutuksesta modulaarisempaa.

%Arkkitehtuurin kuvaaminen sallii myös kommunikoinnin eri sidosryhmien välille ja mahdollistaa järjestelmän tarkastelemisen vain niiltä osin, jotka tiettyä sidosryhmää kiinnostavat \citetext{\citealp[s. 329]{ARaHVeSCiSDu}; \citealp[s. 60]{Brondum:2010:TAV:1833335.1833344}}. Kuvaaminen tapahtuu näkymien avulla, jotka auttavat erottelemaan (separation of concerns) arkkitehtuuria pienempiin palasiin \citep[s. 2]{Galster:2011:DTC:2031759.2031761}. Itse näkymät luodaan käyttämällä ennaltamäärättyjä näkökulmia, jotka edustavat tiettyä tai useampaa sidosryhmälle tärkeää asiaa. 

\subsubsection{Näkymät}
Arkkitehtuuristen näkymien tehtävänä on kuvata tietylle asialle olevat merkitykselliset näkökulmat arkkitehtuurista. Yksi tunnetuimmista määritelmistä arkkitehtuuriselle näkymälle on Krutchenin 4+1 näkymämalli (4+1 View Model) \citep[s.7-8]{gorton_understanding_2011}. 

4+1 -mallissa arkkitehtuuri kuvataan neljän näkymän ja yhden tekstuaalisen kuvauksen avulla 

\begin{itemize}
	\item looginen, joka kuvailee järjestelmän rakennetta ja suhteita
	\item prosessinen, joka keskittyy suorituksen kuvaamiseen
	\item fyysinen, joka esittää miten komponentit kuvautuvat fyysiselle laitteistolle
	\item kehityksellinen, joka kuvailee järjestelmän sisäistä toteutusta
	\item skenaariollinen, jonka avulla näkymät liitetään yhteen.
\end{itemize}

%Looginen näkymä kuvailee esimerkiksi luokkakaavioiden avulla ohjelmistojärjestelmän elementtejä ja niiden välisiä suhteita tarkentaen järjestelmän rakennetta, prosessinäkymä keskittyy ajonaikaisen suorituksen kuvaamiseen tarkentamalla muunmuassa miten samanaikaisuuden hallinta tapahtuu järjestelmässä, fyysinen näkymä keskittyy siihen miten järjestelmän eri komponentit kuvautuvat fyysiselle laitteistolle jossa komponenttia ajetaan ja lopuksi kehitysnäkymä (development view) keskittyy järjestelmän sisäiseen toteutukseen tarkemmalla tasolla kuvailemalla sisäkkäisia pakkauksia tai luokkahierarkiaa. Jokainen näkymä voidaan liittää osaksi toista näkymää skenaarioiden avulla, jotka heijastelevat järjestelmälle asetettuja vaatimuksia, jolloin skenaariot voidaan nähdä ikäänkuin liimana muuten erillisille näkymille. 

Muita näkymämalleja arkkitehtuuriin on useita, joista jokainen kuitenkin tuo esille vähintään jollain tavalla ohjelmistojärjestelmän rakennetta ja yhteyksiä. Tästä esimerkkinä tunnettu \textit{Views and Beyond} -malli \citep[s.8]{gorton_understanding_2011}. Siinä arkkitehtuurinen malli kuvataan kolmella eri näkymällä

\begin{itemize}
	\item moduuli, joka on rakenteellinen näkymä järjestelmään
	\item komponentit ja konnektorit, jotka kuvailevat järjestelmän toiminnallista puolta ja yhteyksiä
	\item allokaatio, joka kuvaa miten prosessit kuvautuvat laitteistotasolla.
\end{itemize}

 %moduuli, joka on järjestelmän rakenteellinen näkymä kuvaten muunmuassa luokkia, pakkauksia, moduulien eriyttämistä (decomposition) sekä periytymistä; komponentti ja konnektori, joka kuvailee järjestelmän toiminnallista puolta sekä miten komponentit ovat yhteydessä toisiinsa; allokaatio, joka kuvailee miten prosessit kuvautuvat laitteistotasolla  ja miten ne kommunikoivat keskenään. 

Näiden kahden esitellyn mallin lisäksi on olemassa joukko eri tarkoituksiin sopivia näkymämalleja, joilla on omat vahvuutensa ja heikkoutensa. Kuitenkin edellä mainitusta kahdestakin mallista jo nähdään, että kummatkin haluavat kuvata järjestelmän rakennetta ja rakenteessa ilmeneviä suhteita, joita muunmuassa komponenttien sekä moduulien välillä on.

%Yhteensä viittä eri mallia vertailtiin Mayn tutkimuksessa \citep{may2005survey}. Siinä kartoitettiin mahdollisimman laajaa näkymien muodostamaa näkökulmien joukkoa, jotka kattaisivat mahdollisimman laajalti ohjelmistoarkkitehtuurin aluetta (domain). Vertailtavat arkkitehtuurit olivat 4+1-malli, SEI:n (Software Engineering Institute) \textit{Views and Beyond}-malli, ISO:n (International Organization for Standardization) \textit{Reference Model of Open Distributed Processing}, Siemensin \textit{Four View Model} ja \textit{Rational Architecture Description Specification}. Malleja vertailtiin tutkimalla kuinka niiden tarjoamat näkökulmat painottavat kolmeen eri kategoriaan liittyviä asioita: sidosryhmät, laadulliset tekijät ja rakenteelliset ominaisuudet. Lopulliseen valintaan, joka painotti mahdollisimman laajasti jokaisen osa-alueen ominaisuuksia, otettiin mukaan \textit{Views and Beyond} -mallin kaikki kolme näkymää ja \textit{Rational ADS}:n vaatimukset-näkökulma (requirements viewpoint). Syy, miksi juuri nämä valittiin oli se, että \textit{Views and Beyond} sopii erittäin hyvin mallin pohjaksi, koska se kuvaa järjestelmän rakennetta kattavasti, sen näkökulmat ovat itsenäisiä ja se limittyy kokonaisuudessaan hyvin 4+1-mallin sekä Siemens'n mallin kanssa. Se ei kuitenkaan sisällä tarvittavia näkymiä kuvaamaan eri sidosryhmille tärkeitä asioita esimerkiksi loppukäyttäjiä varten oleva näkymä puuttuu kokonaan. Tämän takia mukaan on otettu \textit{Rational ADS}, jonka vaatimukset-näkökulma koostuu neljästä eri näkymästä: ei-toiminnalliset vaatimukset, alue (domain), käyttötapaus ja käyttökokemus. 



\subsubsection{Näkökulmat}
Rozanskin ja Woods \citep[s. 36-42]{Rozanski:2011:SSA:2072649} määrittelevät, että näkökulmat liittyvät vahvasti arkkitehtuurisiin näkymiin. Näkökulma voidaan määritellä olevan kokoelma malleja (patterns), templaatteja sekä konventioita, joiden avulla näkymä pystytään rakentamaan.  Näkökulmien joukko taas voidaan jakaa seitsemään eri osaan: kontekstuaalinen, funktionaalinen, informaatiollinen, samanaikaisuudellinen, tuotannollinen, käyttöönotollinen ja operationaalinen. Näistä keskitytään tämän tutkimuksen myöhemmässä vaiheessa tuotannollisen sekä funktionaalisuuden näkökulmaan. Tuotannollinen näkökulma on tärkeä siksi, että se ottaa huomioon niiden sidosryhmien asiat, jotka ovat mukana järjestelmän kehityksessä, testauksessa, ylläpidossa ja parantamisessa. Funktionaalinen näkökulma taas painottaa muunmuassa järjestelmän suorituksenaikaisia komponentteja ja niiden rajapintoja.

% 4210 ISO
IEEE:n virallinen määritelmä näkokulmalle on \textit{a specification of the conventions for constructing and using a view. A pattern or template
from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis} \citep[s. 4]{ieee_2000}. Se on määritelmä, jota tullaan käyttämään myös tässä tutkimuksessa.


\subsection{Näkymän luominen} % aika turha kappale

Ohjelmistoarkkitehtuuri toimii siltana ohjelmakoodin ja ohjelmalle asetettujen vaatimusten välillä \citep[s. 94]{Garlan:2000:SAR:336512.336537}, joten on luonnollista, että näkymä luodaan näiden pohjalta. Sitä luodessa on myös otettava huomioon kenelle näkymä on tarkoitettu, minkälaisia asioita halutaan näkymän painottavan ja millä abstraktiotasolla näkymän tulisi olla. 


Luotavan näkymän perimmäinen tarkoitus voi esimerkiksi olla, että mahdollisimman paljon halutaan nähdä arkkitehtuurisia ominaisuuksia katsomatta lähdekoodia, koska lähdekoodi joko ei ole saatavilla tai se on kehittäjälle liian monimutkaista ja aikaavievää käydä kokonaan läpi ajatuksen kanssa. Tällaiseen näkymän tarpeeseen sopivat esimerkiksi UML:n avulla luodut kaaviot järjestelmän rakenteeesta, joiden avulla erilaisten suhteiden ja rakenteellisten ominaisuuksien tarkastelu helpottuu huomattavasti.

%Chapt. 7 & 8 + Arch views -paperi + What is an architectural description?
%Jos järjestelmää ei ole vielä olemassa lainkaan, voidaan järjestelmän arkkitehtuuria lähteä ensin rakentamaan iteratiivisesti kolmen eri vaiheen kautta \citep[s. 97-115]{gorton_understanding_2011}: määritellään arkkitehtuuriset vaatimukset; luodaan rakenne, joka tukee näitä vaatimuksia; testataan, että rakenne tukee vaatimuksia. Arkkitehtuurille asetetut vaatimukset syntyvät toiminnallisten ja sidosryhmien asettamien vaatimusten tuloksena, koska ne yhdessä luovat tärkeimmät vaatimukset ja rajoitukset ohjelmistojärjestelmälle. Esimerkkinä järjestelmälle asetettavista vaatimuksista saattaa olla, että sen on pystyttävä tukemaan useita eri käyttöliittymiä. Tämä vaatimus voidaan taas ryhmittää tiettyyn laatuvaatimukseen, kuten useat muutkin järjestelmälle asetetut vaatimukset \citep[s. 117]{Ran:1998:ASV:288408.288438}. Tässä tapauksessa vaatimus ryhmitettäisiin muokattavuus-laatuvaatimuksen alle. Seuraavassa vaiheessa valitaan tätä laatuvaatimusta tukeva tyyli (architectural style), jota koko järjestelmä joutuu noudattamaan. Esimerkiksi N-tason -malli tukee muokattavuutta hyvin \citep[s. 103]{gorton_understanding_2011}. Tämän jälkeen järjestelmän keskeisimmät komponentit suunnitellaan ja sijoitetaan ne oikeisiin alueisiin, jotka valittu arkkitehtuurinen tyyli tuo tullessaan. Komponenttien väliset suhteet mallinnetaan pitämällä vastuut erillään, suhteet mahdollisimman vähäisinä sekä käyttämällä hyödyksi piilottamista (architectural decomposition). Lopuksi pystytään luomaan skenaarioita ja testaamaan niiden avulla, että onko luotu arkkitehtuuri sopiva. Komponenttien määrittely mahdollistaa arkkitehtuurin rakenteen kuvaamisen ja siten järjestelmästä on mahdollista luoda erilaisia näkymiä erilaisille sidosryhmille. Rakennetta pystytään kuvaamaan N-tason -mallin avulla erittäin korkealla tasolla, jos halutaan tuoda esille juurikin näkökulma muokattavuuteen, mutta myös matalemmalla tasolla, kun ohjelmistokehittäjä haluaa ymmärtää miten komponentit kommunikoivat keskenään.

%\section{Ohjelmistojen laadulliset tekijät}


%\subsection{Laatuvaatimukset}
%\subsubsection{Toiminnalliset}
%\subsubsection{Ei-toiminnalliset vaatimukset}
%\subsection{Tradeoffit}
%\subsection{Arviointi}

\subsection{UML}

UML eli \textit{Unified Modeling Language} on visuaalinen formalisoitu mallinnuskieli näkymien luomiseen \citep{UML}, joka on muodostunut \textit{de facto}-standardiksi ohjelmistoarkkitehtuurin kuvauksessa ja luomisessa. UML:n avulla voidaan ohjelmistoa mallintaa kolmelta eri näkökulmalta: kehitystä täydentävät mallit, käyttäytymisen kuvaamiseen tarkoitetut mallit ja rakennetta kuvaavat mallit. Käytännössä sen avulla pystytään siis kuvaamaan esimerkiksi jokainen sekä 4+1 -mallin että \textit{Views and Beyond}-mallin näkymä käyttäen hyväksi UML:n tarjoamaa 13 erilaista kaaviota. Arkkitehtuurin kuvauksen kannalta relevanteimmat kaaviot ovat luokkakaavio ja komponenttikaavio, koska niiden avulla saadaan kuvattua erittäin tarkasti ja monipuolisesti järjestelmän rakennetta. Luokkakaaviossa huomio keskittyy konkreettisten luokkien ja niiden välisten suhteiden kuvaamiseen, kun taas komponenttikaavio kuvaa korkeammalla tasolla järjestelmää komponenteittain, joita yhdistävät niiden tarjoamat rajapinnat.   

UML sopii ominaisuuksiensa takia erittäin hyvin olio-pohjaisten ohjelmien kuvaamiseen tarjoamalla tuen muunmuassa periytymisen ja rajapintojen kuvaamiseen. Tämän takia se on otettu tässä tutkimuksessa erityisasemaan järjestelmän ja sen arkkitehtuurin kuvaamisessa.


\section{Testattavuus laadullisena tekijänä} \label{testability_main}
Testattavuus luetaan kuuluvaksi ylläpidettävyyden alle \citep{ISO/IEC25010:2011} ja on täten yksi ohjelmistojärjestelmän laadullisista tekijöistä. Laatuvaatimuksena se ei kuitenkaan ole aina edes kovin näkyvä esimerkiksi asiakkaalle mutta ohjelmistokehittäjälle se tulee esille useassakin kontekstissa. Vaikeasti testattavaa järjestelmää on myös vaikea ylläpitää, ja ylläpidettävä järjestelmä on sekä asiakkaalle että kehittäjälle tärkeä ominaisuus.

% Yksikkö vs integraatio vs regressio testauksessa.
Ohjelmistojärjestelmään kohdistuva testaus voidaan jakaa moneen eri luokkaan, joista kaksi yleisintä ovat yksikkö -ja integraatiotestaus. Yksikkötestauksessa varmistetaan järjestelmän komponenttien kuten luokkien toiminnallisuutta itsenäisesti, kun taas integraatiotestauksessa testaus kohdistuu järjestelmän rajapintoihin ja komponenttien yhteistoiminnallisuuteen. Testauksen voidaan nähdä siis löytävän itse viat, mutta testattavuus taas löytää paikat, joissa viat voivat sijaita \citep[s. 19]{Voas:1995:STN:624607.625469}. Testattavuus tukee täten testausta ja testausprosessia, koska sen avulla voidaan määritellä, mikä on todennäköisyys sille, että järjestelmässä olevat viat löydetään \citep{voas_improving_1992}. 


\subsection{Testattavuuden arviointi} \label{contro_and_observ}

Testattavuuden arvioimisessa voidaan käyttää hyödyksi kolmea eri parametria \citep[s. 2]{baudry_measuring_2003}: havaittavuus (observability), hallittavuus (controllability) ja vaativuus, joka tarvitaan suorittamaan tietty testi. Havaittavuus määrittelee, kuinka mahdollista testien tuloksia on tarkastella, ja hallittavuus sitä, kuinka paljon testattavaan komponentin tilaan voidaan vaikuttaa. 

Havaittavuus voidaan myös nähdä arvona, joka kertoo kuinka helppo on määrittää vaikuttavatko tietyt syötteet testituloksiin, ja hallittavuus taas voidaan nähdä siitä kuinka helppo on tuottaa jokin tietty tulos syötteestä. %\citep[s. 554]{Freedman:1991:TSC:126218.126229}. 
Sen parametrisoimiseen on kehitetty \textit{domain-to-range} -arvo eli DRR, jonka avulla voidaan havaita implisiittistä tiedonkatoamista \citep{Voas:1995:STN:624607.625469}. DRR-arvo saadaan vertailemalla komponenttien mahdollisen tulosteen (ouput) joukon kokoa syötteen (input) kokoon. DRR-analyysi on hieman ongelmallinen, koska se vaatii ohjelmistojärjestelmän täydellisen lähdekoodin tuekseen ja lähdekoodi-analyysit ovat raskaita teettää käsin.

% hallittavuus???  



\subsection{Testattavuuden parantaminen}

%Hyvä testattavuus on järjestelmän laadulle hyvä ominaisuus \citep[s. 20]{Voas:1995:STN:624607.625469}. 

Hyvä testattavuus auttaa järjestelmän ylläpidossa, validoinnissa ja parantaa järjestelmien laatua \citep[s. 20]{Voas:1995:STN:624607.625469}. Se on siis tavoiteltava ominaisuus jokaisessa ohjelmistojärjestelmässä, mutta hyvän testattavuuden saavuttaminen on aina ohjelmistöjärjestelmäkohtaista. Tästä syystä onkin mielekkäämpää tarkastella, mikä luo yleisesti järjestelmissä hyvää testattavuutta. 

%Testattavan komponentin ominaisuudet: testitapaukset ovat pieniä ja helposti luotavia, testitapaukset eivät ole itseään toistavia, ongelmat on helppo jäljittää tiettyihin komponentteihin \citep[s. 554]{Freedman:1991:TSC:126218.126229}

%Jo suunnitteluvaiheessa voidaan kiinnittää huomiota testattavuuteen ja näin parantaa itse testausprosessia. Decomposition, moduulien korkeat DRR (domain/range -ratio), korkean DRR:n omaavat moduulit mah. pieniksi ja eriytetyiksi, hyvä rajapinta joka paljastaa tarpeeksi moduulin sisäistä tilaa \citep[s. 117]{voas_improving_1992}.


%Isolating modules with high DDR \citep[s. 23]{Voas:1995:STN:624607.625469}.

Freedman on määritellyt testattavan komponentin ominaisuuksiksi \citep{Freedman:1991:TSC:126218.126229}: komponentista luotavat testitapaukset pysyvät pieninä ja ovat helposti luotavissa; komponentin testitapaukset eivät ala toistamaan itseään; komponentin testauksen aikana havaitut ongelmat on helppo jäljittää tiettyihin komponentteihin. Näitä tukemaan voidaan jo arkkitehtuurin alkuvaiheessa kiinnittää huomiota seuraaviin tekijöihin \citep{voas_improving_1992} 

\begin{itemize}
	\item ymmärtää dekomposition mahdollisuus
	\item tunnistaa moduulit, joiden DRR-arvo on korkea ja tehdä ne mahdollisimman pieniksi ja yksinkertaisiksi
	\item tunnistaa rajapinta korkean DRR-arvon moduuleille siten, että rajapinta paljastaa tarpeeksi tietoa moduulien sisäisestä tilasta
	\item eriyttää korkean DRR-arvon moduulit toisistaan \citep[s. 23]{Voas:1995:STN:624607.625469}.
\end{itemize}


On siis todella tärkeää eriyttää komponentteja mahdollisimman paljon toisistaan ja tehdä kommunikaatio mahdollisimman kontrolloitavaksi hyvän testattavuuden aikaansaamiseksi. Varsinkin helposti isoiksi muodostuvien komponenttien pitäisi olla kytkentätasoltaan mahdollisimman kevyitä ja riippuvuuksien minimissään tai niistä luotavien testien tekeminen vaikeutuu ja testitapausten koko kasvaa erittäin suuriksi. Myös ison ja tärkeän toiminnallisuuden kerääntymistä vain muutaman komponentin vastuulle voi olla merkki liiallisista DRR-arvoista, joka pitäisi hoitaa välittömästi tai testaus voi vaikeutua huomattavan paljon.



\subsection{Testausta heikentävät ominaisuudet}

Tietyt ominaisuudet vaikuttavat yleisesti ohjelmistojärjestelmissä negatiivisesti testattavuuteen. Tiedon katoaminen on yksi näistä \citep{Voas:1995:STN:624607.625469} ja se voidaan jakaa implisiittisen ja eksplisiittisen tiedon katoamiseen. Implisiittisessä katoamisessa useat eri parametrit samaan kohteeseen tuottavat myös saman testituloksen, ja eksplisiittisessä tiedon katoamisessa tietoa piilotetaan ulkoiselta näkymältä. Tiedon piilottaminen on esimerkiksi hyvin yleinen ja suositeltava tapa olio-ohjelmoinnissa, mutta liiallinen tiedon piilotus tuottaakin vaikeuksia testauksessa, koska testauksen hallittavuus heikkenee. Ohjelmistojärjestelmä voidaan kuitenkin tarkoituksella suunnitella niin tiiviiksi, että sisäinen tila jää täysin tarkastelemattomaksi. Tällöin testauksen aikana syntyneessä virhetilanteessa on hyvin vaikea sanoa, että mistä päin virhe syntyi ja virheen paikallistaminen saattaa viedä aikaa.

Ongelmat syötteiden ja tulosten tarkastelussa tiedon katoamisen johdosta johtavat helposti tarpeettomiin testeihin, joita on vaikea ymmärtää, ja vaikeasti testattavan komponentin voidaankin sisältävän ulos- ja sisääntuloparametrien epäjohdonmukaisuuksia \citep{Voas:1995:STN:624607.625469}. Toisin sanoen vaikeasti testattava komponentti tuottaa eri tuloksia eri ajoilla tai ei ikinä tuota haluttua tulosta.   




\subsection{Testattavuuden mittaaminen} \label{testability_measure}


Koska suoraan hyvää tai huonoa testattavuutta on vaikeaa määritellä, on erilaisia testattavuuteen vaikuttavia mittareita tutkittu paljon.
Yksikkötestauksen näkökulmasta sitä on tutkinut Bruntink ja van Deursen \citep{Bruntink:2004}. He tutkivat hyviä testattavuuden metriikoita Java-pohjaisiin ohjelmistojärjestelmiin. Tutkimuksen testitapausten kasvuun ja pituuteen vaikuttivat eniten luokan 

\begin{itemize}
	\item toisten luokkien määrä, joita luokka kutsuu tai jonka kenttiin se viittaa
	\item koko (rivien määrä)
	\item omien metodien määrä ja muiden luokkien metodien määrä, joita omat metodit käyttävät.
\end{itemize} 

Khan ja Mustafa käyttävät taas seuraavaa neljää metriikkaa laskeakseen testattavuutta ohjelmistojärjestelmissä \citep{Khan:2009:MBT:1507195.1507204}. 

\begin{itemize}
	\item enkapsulaation taso, jota mitataan metodien määrällä
	\item uudelleenkäytön taso, jota mitataan luokkahierarkioiden koolla
	\item kytkennän taso, jota mitataan luokkien välisten suhteiden määrällä
	\item koheesion taso, jota mitataan metodien sukulaisuuden (relatedness) avulla.
\end{itemize}   

\noindent
Ne korreloivat vahvasti edellisiin metriikoihin ja niistä voidaan nähdä, että ne ottavat kantaa neljään olio-ohjelmoinnin keskeiseen suunnitteluperiaatteisiin.

Oliopohjaisista järjestelmistä voidaan havaita yleisesti seuraavat testaukseen vaikuttavat tekijät, joiden suuri arvo korreloi vahvasti huonoon testattavuuteen \citep{Dubey:2011:AMM:2020976.2020983}

\begin{itemize}
	\item metodien määrä luokassa
	\item metodien määrä luokkahierarkiassa, jotka suoritetaan, kun luokan metodi suoritetaan
	\item luokkien määrä, johon luokalla on kytkentää
	\item periytymisaste
\end{itemize}

\noindent
Nämä tekijät ovat negatiivisia asioita testauksen kannalta, koska suuri metodien määrä on merkki luokan liiallisesta kompleksisuudesta ja se johtaa testauksen monimutkaistumiseen. Suuri kytkennän määrä vaikeuttaa luokan itsenäistä testaamista, koska luokka käyttää hyvin paljon hyväkseen muiden luokkien toiminnallisuutta. Suuri periytymisaste tuo taas luokalle mahdollisesti paljon perittyjä metodeja, jotka on toteutettu jossain muualla. Tilanne voi johtaa siihen, että luokka on riippuvainen erittäin paljon muiden luokkien toteutuksista ja luokan testaaminen vaatii käytännössä koko luokkahierarkien läpikäynnin. 

Esitellyistä mittareista nähdään paljon samanlaisuutta ja niistä voidaan kerätä yleisesti luokkien näkökulmasta muutama iso tekijä testattavuudessa; koko, itsenäinen toimiminen, riippuvuudet muista luokista ja periytyminen.  
Osa edellämainituista mittareista on kuitenkin ominaisuuksiltaan sellaisia, että niitä voidaan suurimmaksi osaksi mitata vain lähdekoodin avulla ja ne ottavat kantaa pelkästään testattavuuteen vain yhden luokan näkökulmasta. 
Tietenkin olisi mahdollista laskea jokaiselle luokalle erikseen kyseiset mittarit, mutta kokonaisuuden tarkasteleminen tai keskittyminen vain tiettyyn testausta vaikuttavaan osa-alueeseen vaatii muita keinoja.

\section{Testattavuus arkkitehtuurisella tasolla} \label{arch_testability_main}

Arkkitehtuurisella tasolla testattavuus vaikuttaa laajemmin ja arkkitehtuuristen ongelmien tutkimiseen on käytettävä eri keinoja, kuin kooditason analysoinnissa, koska lähdekoodia ei aina ole saatavilla. Testattavuutta voidaan tutkia esimerkiksi komponenttitasolla, jota tukevat hyvin UML-komponenttikaaviot. Tämä käy arkkitehtuurin arvioimiseen testattavuuden kannalta hyvin, koska testattavuus tulee ilmi korkealla tasolla muunmuassa integraatiotestauksen aikana, kun sekä komponenttien rajapintojen toimivuus että komponenttien toimivuus pitää validoida \citep[s. 65]{Eickelmann:1996:MOS:243327.243602}. Toinen tapa tutkia testattavuutta arkkitehtuurisella tasolla on UML-luokkakaavioiden avulla. Niiden apuna voidaan käyttää hyväksi esimerkiksi kaikkia kappaleen \ref{testability_measure} metriikoita, jotka eivät tarvitse lähdekoodia tuekseen. 

Yksittäisten komponenttien, eli luokista koostuvien kokonaisuuksien testattavuutta, on analysoitu erilaisten mallien avulla ja näistä eräs on Goan ja Shihn \citep{gao_component_2005} esittämä pentagrammimalli. Sen avulla jokaista komponenttia voidaan tarkastella viideltä eri näkökulmalta: havaittavuus, hallittavuus, jäljitettävyys (traceability), tuki testivalmiudelle (test support capability) ja ymmärrettävyys (understandability). Näistä kaksi ensimmäistä ovat ideoiltaan samat kuin kappaleessa \ref{contro_and_observ} ja loput vastaavat muunmuassa kysymyksiin: kuinka helppoa on tarkastella komponentin tilaa ulkopuolisena; kuinka hyvin komponentti tukee erilaisia testausstrategioita; kuinka hyvin komponentin tarkoitus ymmärretään, että testejä pystytään luomaan. 
 
On siis hyvä tarkastella kahdelta eri näkökulmalta testattavuutta arkkitehtuurisella tasolla: metriikoista koostuva analyysi ja yksittäisten komponenttien analyysi ilman metriikoita. Analyysi ilman metriikoita keskitetään enemmän kokonaisuuksien hahmottamiseen ja ongelmakohtien löytämiseen laadullisten ominaisuuksien pohjalta.


\subsection{Hyvä testattavuus arkkitehtuurissa} \label{good_testability}

 
Eicklemann on määritellyt tiettyjen arkkitehtuuristen tyylien sopivan tietyille testausstrategioille \citep{Eickelmann:1996:MOS:243327.243602}, joten on selvää että valittu arkkitehtuurinen tyyli vaikuttaa jollain tasolla positiivisesti testattavuuteen. Paljon mielekkäämpää on kuitenkin tarkastella muita ominaisuuksia testattavalle arkkitehtuurille, jotta voitaisiin tarkastella enemmän, että mitkä tekijät tuovat testattavuutta arkkitehtuurille.

Oliopohjaisissa ohjelmistojärjestelmissä koetaan vähintään vastuiden jakamisen olevan  lähtökohta hyvälle testattavuudelle, koska se parantaa koko järjestelmän havaittavuutta ja hallittavuutta \citep{Binder:1994:DTO:182987.184077}. Binder määrittelee myös muita ominaisuuksia testattavalle järjestelmälle, kuten sisäänrakennettu testausominaisuus (built-in test) ja järjestelmän jäljitettävyys, jonka avulla testien esille tuomat viat on helppo paikallistaa. Suoraan rakenteelliselta tasolta hän painottaa kapseloinnin, polymorfismin, perinnän ja kompleksisuuden tarkastelua.

%Järjestelmän tarkasteltavuus (monitorability) voidaan lukea ohjelmistojärjestelmän yhdeksi ominaisuudeksi, joka nostaa positiivisesti testattavuuden tasoa \citep{mari_impact_2003}. Tarkasteltavuus ohjelmistojärjestelmissä voidaan jakaa kolmeen eri luokkaan: komponentin sisäinen, komponenttien välinen sekä järjestelmätasoinen yhteistoiminnallisuus. Tarkasteltavuutta analysoitaessa huomio voidaan kiinnittää esimerkiksi siihen kuinka hyvin järjestelmän tilaa voidaan tarkastella, testien etenemistä, komponenttien interaktiota sekä testauksen hallinnoimista esimerkiksi tynkäluokkien (stub) avulla. 

Joshi ja Sardana ovat tutkineet ominaisuuksia, joita järjestelmän pitäisi painottaa, jos järjestelmää halutaan suunnitella testauksen varalle eli luoda ohjelmistojärjestelmästä mahdollisimman testattava. Näitä testattavuuteen korkealla tasolla vaikuttavia ominaisuuksia järjestelmässä löydettiin olevan \citep{joshi_design_2014}
	
\begin{itemize}
	\item vaatimusten tarkkuus
	\item sykliset riippuvuudet
	\item kytkennän taso
	\item koheesion taso
	\item antipatternien esiintyminen
	\item järjestelmän jäljitettävyys (traceability)
	\item havaittavuus ja hallittavuus.
\end{itemize}

%\noindent
%He esittävät mahdollisten ongelmien eliminoimiseen järjestelmän modulaarista rakennetta ja UML:n muokkaamista sekä UML-stereotyyppien käyttöä. UML kaavioiden muokkaus voi tapahtua esimerkiksi luomalla uusia malleja nykyisten pohjalta tai käyttämällä UML:n geneerisiä laajennoskohtia, joiden avulla saadaan muokattua näkymää tiettyyn suuntaan.

Edellä olevien tutkimusten tuloksista voidaan nähdä kaksi ryhmää; mitattavat ja laadulliset ominaisuudet. On tärkeää tarkastella sekä komponenttien ulkoisia että sisäisiä ominaisuuksia, jotta voitaisiin muodostaa hyvä kuva testattavuuden tasosta. Kuitenkin suoraan rakenteellisuuden näkökulmasta esiin nousevat: kapselointi, perintä, kompleksisuus, riippuvuudet, kytkentä ja koheesio.  


\subsection{Arkkitehtuurin testattavuuden mittaaminen} \label{arch_testability_measurement}

Bengtsson on määritellyt osan arkkitehtuurisen tason mittareita, jotka määrittelevät järjestelmän ylläpidettävyyttä. Ylläpidettävyys on taas vaikuttava piirre testattavuuteen, joten on luonnollista tarkastella myös sen kautta järjestelmän testattavuutta. Tunnistetut mittarit ovat arkkitehtuurisille elementeille \citep{bengtsson1998towards}

\begin{itemize}
	\item metodien määrä elementin rajapinnassa
	\item paikkamerkkien (placeholder) määrä arkkitehtuurisille elementeille, joiden avulla elementti parametrisoidaan
	\item elementistä lähtevien viestien määrä
	\item elementtityyppien määrä, joita tarkasteltava elementti toteuttaa (implement)
	\item elementtien määrä, jotka toteuttavat tarkasteltavan elementin tyypin
	\item saatavilla olevien metodien lukumäärä muista elementeistä, jotka ovat yhteydessä tarkasteltavaan elementtiin
	\item elementin metodien ja parametrien määrä
\end{itemize}

On melko selvää, että nämä mittarit ovat osittain hyvin samankaltaisia kuin kappaleessa \ref{testability_measure} määritellyt mittarit testattavuuden mittaamiseen, mutta osa niistä kattaa korkeamman tason, jossa vaikutukset näkyvät paremmin. Edellisistä mittareista nähdään myös, että moni pyrkii jossain määrin määrittelemään esimerkiksi kytkennän tasoa. Kytkentä määriteltiin kappaleessa \ref{testability_measure} yhdeksi tavaksi mitata testattavuutta ja sitä voidan havaita tutkimalla ohjelmistojärjestelmän komponenttien välisiä suhteita.

\subsubsection{UML-kaaviot testattavuuden mittaamisessa} \label{uml_arch_test}

UML-luokkakaavio toimii hyvänä pohjana, kun halutaan mitata luokkien välisiä suhteita ja riippuvuuksia \citep{baudry_testability_2002}. 
Baudry ym. määrittelee testattavuuden anti-mallin (testability anti-pattern) luokkakaavioiden avulla tulevaksi ilmiöksi \citep{baudry_measuring_2003}. Anti-mallissa kaksi suurta tekijää vaikuttavat testattavuuteen negatiivisesti: luokkien välinen suuri interaktio ja itsekäyttö, jossa luokka on riippuvainen rekursiivisesti itsestään. Syitä näiden kahden esiintymiselle voi olla luokkien välinen suuri kytkentätaso, riippuvuuksien syklimäisyys ja luokkien välinen suuri kommunikaatiotaso. Yhdessä nämä tekijät vaikeuttavat paljon vastuiden jakamista ja kasvattavat tarvittavien testitapausten määrää. 

% UML \citep{baudry_testability_2002}

UML:n avulla luotavalla erityisellä riippuvuusgraafilla, esittävät Baudry, Troan ja Sunye testattavuuteen negatiivisesti vaikuttaviksi asioiksi \citep{baudry_testability_2002}

\begin{itemize} 
	\item kompleksiset perintäsuhteet
	\item abstraktien luokkien liikakäyttö rajapintojen sijasta.
\end{itemize}


Näiden lisäksi Jungmayr käsittelee testauksen kannalta kriittisten riippuvuuksien poistoa. Riippuvuudeksi lasketaan mikä tahansa komponenttien välinen interaktio, jossa komponentti joutuu käyttämään toisen komponentin tarjoamia palveluita (usein metodeja) suorittaakseen toiminnallisuuttaan.  Luokkakaaviosta saatavia mittareita tunnistetaan kolme kappaletta, joiden korkeat arvot korreloivat järjestelmän huonon testattavuuden kanssa \citep{Jungmayr:2002} 

\begin{itemize}
	\item komponenttien keskimääräinen riippuvuuksien määrä
	\item komponenttien määrä riippuvuussykleissä
	\item \textit{feedback-riippuvuuksien\footnote{\textit{Feedback-riippuvuus} on syklinen riippuvuussuhde komponenttien välillä, josta poistamalla jokin riippuvuus saadaan sykli purettua täysin.}}  määrä 
\end{itemize}

UML on mittareiden mukaan auttanut työkaluna löytämään yhteydellisiä ominaisuuksia arkkitehtuurissa, joita tarkastellessa voidaan sanoa tarkasteltavan  kytkennän tasoa, kompleksisuutta ja riippuvuuksia. Komponenttien sekä yhteyksien tarkastelu oli myös luvussa \ref{ark} esitelty eräs näkemys ohjelmistoarkkitehtuuriin ja on järjestelmän todellisen testattavuuden määrittelemisen kannalta parempi, jos testattavuutta voidaan tarkastellaan korkealla tasolla. Liian tarkka kuvaus järjestelmästä vaikeuttaa todellisten ongelmien näkemistä, koska se vie aikaa ymmärtää ja keskittyy liian pikkutarkkoihin asioihin, jotka eivät kaikki välttämättä ole relevantteja testattavuuden analysoinnin kannalta. Ylätason kuvauksella on etuna myös se, että sen avulla pystytään löytämään helposti usein esiintyviä ongelmallisia tilanteita, joiden tunnistaminen ja välttäminen auttaa järjestelmän testattavuuden hallinnassa.

 
%UML on mahdollistanut testattavuuden arvioimisen ohjelmistojärjestelmissä, koska löydetyistä mittareista huomataan, että ne mittaavat esimerkiksi komponenttien ominaisuuksia ja yhteyksiä, jotka tulevat esille kunnolla vasta arkkitehtuurisella tasolla. Komponenttien sekä yhteyksien tarkastelu oli myös luvussa \ref{ark} esitelty eräs näkemys ohjelmistoarkkitehtuuriin ja on järjestelmän todellisen testattavuuden määrittelemisen kannalta parempi, jos testattavuutta voidaan tarkastellaan korkealla tasolla. Liian tarkka kuvaus järjestelmästä vaikeuttaa todellisten ongelmien näkemistä, koska se vie aikaa ymmärtää ja keskittyy liian pikkutarkkoihin asioihin, jotka eivät kaikki välttämättä ole relevantteja testattavuuden analysoinnin kannalta. Ylätason kuvauksella on etuna myös se, että sen avulla pystytään löytämään helposti usein esiintyviä ongelmallisia tilanteita, joiden tunnistaminen ja välttäminen auttaa järjestelmän testattavuuden hallinnassa.

\subsection{Arkkitehtuuriset hajut ja testattavuus} \label{arch_smells_and_testability}

Arkkitehtuurisiin hajuihin on alettu kinnittää yhä enemmän huomiota ohjelmien monimutkaistuessa ja suunnittelun tulevan yhä tärkeämmäksi osaksi ohjelmistojen elinkaarta. Ne ovat sukua tutummalle käsitteelle koodihaju, mutta tulevat esille arkkitehtuurisella tasolla, kun koodihajut tulevat esille luokkatasolla ja vaativat melkein aina lähdekoodin tunnistamisen tueksi. Arkkitehtuuriset hajut ovat pääosin suunnittelupäätöksiä, jotka negatiivisesti vaikuttavat järjestelmän elinkaareen ja muunmuassa testattavuuten sekä ylläpidettävyyteen. Niitä ei voi pitää välttämättä virheinä, mutta ne vaikuttavat vähintään aina negatiivisesti laatuun \citep{de_andrade_architectural_2014}. Syitä arkkitehtuurisille hajuille voidaan nähdä olevan muunmuassa 

\begin{itemize}
	\item suunnittelumalli väärässä kontekstissa
	\item suunnitteluabstrahoinnin (design abstraction) käyttö niin, että sillä on ei-toivottuja vaikutuksia
	\item suunnitteluabstrahoinnin käyttö väärällä tarkkuuden tasolla.
\end{itemize} 

%Testattavuus \citep{garcia_identifying_2009} yleisesti \citep{bertran_detecting_2011}.

Yleisesti arkkitehtuuriin vaikuttavia hajuja voidaan löytää arkkitehtuurisella tasolla seuraavien metriikoiden avulla \citep{bertran_detecting_2011}

\begin{itemize}
	\item ei-haluttujen asiakas-komponenttien (client component) määrä
	\item komponentin vastuiden määrä
	\item komponentin konnektoreiden määrä
	\item komponentin erilaisten konnektoreiden määrä
	\item komponenttien välinen riippuvuuksien hajauma.
\end{itemize}

%\citep{HotSpot} arkkitehtuuriset hajut "hotspotit"\ 5kpl + kaikista altin virheille oli \citep[s. 57]{HotSpot} Unstable Interface \& Cross-Module Cycle.

\noindent
Näiden metriikoiden avulla sekä näkymällä moduulitasoon, olisi esimerkiksi hyvin mahdollistaa löytää yksi virhealttiillisin arkkitehtuurista löytyvä ongelmakohta \citep[s. 57]{HotSpot} \textit{Cross-Module Cycle}.

\paragraph{\textit{Cross-Module Cycle}} tilanne arkkitehtuurissa, jossa on olemassa syklinen riippuvuussuhde moduulitasolla. Se vaikeuttaa testattavuutta, siten, että testauksen aikana yhden moduulin testaaminen vaatii käytännössä myös kaikkien muiden moduulien testauksen, jolloin testitapausten eriyttäminen vaikeutuu huomattavasti. Sykliset riippuvuudet todettiin olevan myös kappaleessa \ref{good_testability} yksi testattavuuteen vaikuttava tekijä.
\\

Arkkitehtuurisia hajuja, jotka vaikuttavat suoraan testattavuuteen voidaan tunnistaa olevan ainakin kaksi \citep{garcia_identifying_2009}
\paragraph{\textit{Connector Envy}} tilanne, jossa komponentti toteuttaa konnektorille kuuluvaa toiminnallisuutta eli toteuttaa esimerkiksi joko kommunikointia, koordinointia tai tiedon konversiota. Nämä tulisi jättää konnektorin toteutettavaksi, koska komponentin toiminnallisuus ja interaktiot eivät ole enää erillään testattavia ominaisuuksia ja tilanteena johtaa siihen, että ei pystytä enää varmasti sanomaan, että mikä kohta komponentissa oli virheellinen, jos se testauksen aikana tuli esille.

\paragraph{\textit{Scattered Parasitic Functionality}} tilanne, jossa useammalla komponentilla on sama vastuu ja ne ovat vastuussa myös jostain muusta vastuusta. Testattavuus kärsii tästä, koska esimerkiksi integraatiotestauksen aikana tapahtunut virhe vaikuttaa laajalla alueella ja vaikeuttaa vian alkuperän määrittämistä. 

\noindent
\\Testaukseen vaikuttavista arkkitehtuurisista hajusta voidaan huomata, että ne pyrkivät löytämään sykliset riippuvuudet, huonon koheesion ja mahdollisen riippuvuuksien jakautumisen turhan laajalle. Samat asiat siis, jotka vaikuttavat luokkatasolla vaikuttavat myös jollain keinolla arkkitehtuuriin. Tämän kannalta on hyvä yrittää löytää, että onko luokkatasoisemmilla koodihajuilla ja arkkitehtuurisilla hajuilla jotain yhtettä toisiinsa. 


\subsubsection{Koodihajujen ja arkkitehtuuristen hajujen suhde}

Vale ym. ovat myös tutkimuksessaan tuoneet esille hybridihajut, jotka ovat sekoitus koodihajuja ja arkkitehtuurisia hajuja tuoden uuden näkökulman arkkitehtuuristen hajujen löytämiseksi myös testattavuuden kannalta. Koodipoikkeama (code anomaly) luetaan hybridihajuksi, jos \citep{vale_bad_2014}

\begin{itemize}
	\item sen vaikuttamat luokat ovat vastuussa arkkitehtuurisista elementeistä
	\item vaikuttammissa arkkitehtuurisissa elementeissä on arkkitehtuurisia ongelmia.
\end{itemize}

\noindent
Hybridihajujen tunnistaminen saattaa siis helpottaa arkkitehtuuristen hajujen löytämistä. Löytämällä esimerkiksi koodihajujen pohjalta arkkitehtuurisiin vaikuttavia ongelmallisia luokkia, voidaan tunnistaa arkkitehtuurisella tasolla vastaavat arkkitehtuuriset hajut ja elementit.

Lisää arkkitehtuuristen sekä koodihajujen yhteyksistä on tutkinut Macia ym. \citep{macia_impact_2011}. He löysivät, että tietyt koodihajut ovat indikaattoreita arkkitehtuurisista hajuista. Kahteen aiemmin mainittuun testattavuutta huonontaviin hajuihin he lukivat seuraavat vastaavat koodihajut aspekti-orientoituneissa järjestelmissä

% EI SELITTÄMÄTTÖMIÄ OSIA

\begin{center}
\begin{table}[ht]
	\begin{tabular}{| l | l | m{3.2cm} |}
	\hline 
	\textbf{Koodihaju} & \textbf{Arkkitehtuurinen haju} & \textbf{Syy} \\ \hline
	\textit{God Aspect} & \textit{SPF} & Liikaa vastuita \\ \hline
	\textit{God Pointcut} & \textit{SPF, Connector Envy} & Liikaa suoria vastuita \\ \hline
	\textit{Composition Bloat} & \textit{SPF} & Liikaa riippuvuuksia \\ \hline
	\textit{Duplicate Pointcut} & \textit{SPF} & Samankaltaista toiminnallisuutta \\ 
	\hline
	\end{tabular}
	\caption{Aspekti-orientoituneiden koodihajujen suhde arkkitehtuurisiin hajuihin ja syyt hajujen esiintymisille.}
	\label{tab:aspectSmells} 
\end{table}
\end{center}

%Koodi ja arkkitehtuuri-info. Detection strategies \citep[s. 179-182]{macia_enhancing_2013}

\noindent
Vaikka taulukon \ref{tab:aspectSmells} koodihajut eivät suoraan koske juuri olio-pohjaisia järjestelmiä, niistä voidaan silti nähdä, että ongelmat tulevat liiallisista vastuista, liiallisista riippuvuuksista ja samankaltaisesta toiminnallisuudesta. Nämä ominaisuudet ovat nähtävissä hyvin tavallisissakin olio-pohjaisissa järjestelmissä ja tätä faktaa tukee Macia ym. jatkotutkimus hieman samasta aiheesta, jossa tutkittiin arkkitehtuuri-herkkiä koodipoikkeamia \citep{macia_enhancing_2013}. He tulivat testattavuuden kannalta seuraaviin päätelmiin

% NÄÄ VOIS SELITTÄÄ ESIM ALAINDEKSISSÄ

\begin{center}
\begin{table}[h]
	\begin{tabular}{| l | l | m{3.5cm} |}
	\hline
	\textbf{Koodihaju} & \textbf{Arkkitehtuurinen haju} & \textbf{Syy}\\ \hline
	\textit{God Class} & \textit{SPF, Connector Envy} &  Toiminnallisuus liian keskittynyttä, liialliset vastuut\\ \hline
	\textit{Misplaced Class} & \textit{Cyclic Dependencies, SPF} & Riippuvuuksia enemmän komponentin ulkopuolelle kuin sisäpuolelle\\ \hline
	\end{tabular}
	\caption{Olioperäisten koodihajujen ja arkkitehtuuristen hajujen suhde sekä niiden syyt.}
	\label{tab:codeSmells}
\end{table}
\end{center} 

\noindent
Taulukon \ref{tab:codeSmells} suhteista nähdään samanlaisuutta, kuin mitä taulukko \ref{tab:aspectSmells} näytti syinä sen koodihajuille. Suurimmat ongelmat kooditasollakin tulivat liiallisista riippuvuuksista ja huonosta vastuiden jaosta, joka saattaa johtaa yksittäisten komponenttien paisumiseen. Yksittäisten komponenttien paisuminen taas luo helposti huonoa kompositiota, toistuvaa toiminnallisuutta ja komponentteja, joiden harteilla on iso osa toiminnallisuuden toteuttamisesta. Nämä ongelmat realisoituvat arkkitehtuurisiksi hajuiksi arkkitehtuuritasolla ja niiden tunnistaminen kooditasolta arkkitehtuuriselle tasolle ja arkkitehtuuriselta tasolta kooditasolle on tärkeää myös testattavuuden kannalta.


%Koodihajujen tunnistaminen arkkitehtuurisen degraation tunnistamiseksi \citep{fontana_towards_2015}. Vaikuttavat ylläpidettävyyteen. God Class, Data Class, Brain Method, Shotgun Surgery, Dispersed Coupling, Message Chains. Metriikoina käytettiin muunmuassa: Tight Class Cohesion, Access to Foreign Data, Number of Public Attributes, Maximum Nesting Level, Coupling Intensity. Co-Occurence of smells. 

Tarkastelu voidaan keskittää myös enemmän aiheisiin kuten mistä koodihajut johtuvat tai mitkä tekijät koodihajuissa vaikuttavat arkkitehtuuristen hajujen esiintymiseen järjestelmissä. Tähän avuksi Fontana, Ferme ja Zanoni loivat erityisen näkymän koodihajujen tunnistamiseksi ja tunnistivat kytkentään ja koheesioon vaikuttavia koodihajuja \citep{fontana_towards_2015}. Kytkentään vaikuttivat koodihajut, jotka olivat suoraan vastuussa muunmuassa

% SELITÄ TAI POISTA

\begin{itemize}
	\item suurista luokista (\textit{God Class})
	\item pitkistä metodeista (\textit{Long Method})
	\item laajalle hajautuneesta kytkennästä (\textit{Dispersed Coupling})
	\item replikoituvasta muutoksen vaatimasta kohdealueesta (\textit{Shotgun Surgery})
\end{itemize}

\noindent
Koheesioon vaikuttivat kolme ensimmäistä samaa tekijää. Näistä löydetyistä tekijöistä arkkitehtuuritasolla kiinnostavimmat olisivat suuret luokat ja komponentit, joiden vastuualue on hajautunut liian laajalle sekä joiden toimintaa on vaikea muuttaa ilman muuttamatta muita komponentteja.

On siis edellisten tutkimusten nojalla selvää, että hyvä kytkennän ja koheesion taso ovat tavoteltavia ominaisuuksia sekä kooditasolla että arkkitehtuuritasolla. Testattavuuden kannalta voidaan arvioida mitkä tekijät aiheuttavat kahta mainittua testattavuuteen vaikuttavaa arkkitehtuurista hajua, josta tuloksena saatiin, että merkkittäviä tekijöitä olivat vastuut, riippuvuudet, koheesio, kytkentä. Tekijöiden mittaamisen apuna arkkitehtuuriselta tasolta voidaan muunmuassa käyttää luvussa \ref{arch_testability_measurement} esiteltyjä mittareita ja tämän luvun pääluvun alussa esiteltyjä metriikoita arkkitehtuurisille hajuille.  

%\subsection{Sunnittelumallien vaikutus testaukseen}

%Mitä on? Miten vaikuttaa rakenteeseen? Mitä  hyötyä? \citep{baudry_measuring_2003}.


%Composition-patternin analyysi -> kansio sisältää useita tiedostoja ja kansioita -> sykli. Voidaan helpottaa lisäämällä rajoite (constraint) tai rajapinta mielummin kuin abstraktiluokka. 

%Vaikeita patterneita testata: Mediator (similar to Observer) \& Visitor.

\subsection{UML uusien näkymien tukena}


Standardi UML-kaavio ei itsessään riitä näyttämään kaikkia testattavuuden kannalta tärkeitä näkökulmia arkkitehtuurisella tasolla, mutta sen tueksi on luotu useita menetelmiä, jotka hyödyntävät esimerkiksi jo valmista UML-luokkakaaviota. Eräs näistä on \textit{class dependency graph model} \citep{baudry_testability_2002}, joka kappaleessa \ref{uml_arch_test} tuli esille. Sen avulla on mahdollista nähdä 

\begin{itemize}
	\item luokkien välistä suurta interaktiota
	\item itsekäyttöä
	\item interaktioiden kompleksisuutta
	\item pitkiä luokkahierarkisia haaraumia
	\item kompleksisia rajapinta periytymiä.
\end{itemize}


Tämä tuottaa tosin ongelmia, koska jotkut tulokset saattavat olla vääriä niiden sisältäessä virheellistä esiintymää (false-positive results). Tähän ongelmaan on ehdotettu UML-kaavion jatkamista stereotyyppien avulla. Uusia kytköksiä riippuvuuksille määritellään 4 kappaletta \citep[s. 4]{baudry_measuring_2003}

\begin{itemize}
	\item \textit{create}, jos luokka A luo luokan B
	\item \textit{use}, jos luokka A voi kutsua kaikkia B:n metodeja, muttei luo sitä
	\item \textit{use\_consult}, jos A:n kutsumat metodit eivät muokkaa B:n sisäistä tilaa
	\item \textit{use\_def}, jos yksikin A:n kutsuma metodi muokkaa B:n sisäistä tilaa
\end{itemize}

\noindent
Näiden sterotyyppien avulla saadaan riippuvuudet ja niiden tyypit paremmin esille kaavioissa virheellisten tuloksien välttämiseksi. On esimerkiksi usein melko normaalia oliojärjestelmissä, että yksi luokka saattaa luoda useita riippuvuuksia muihin luokkiin, mutta tämä on tehty tarkoituksella eikä vahingossa kehittäjien toimesta. Näin on esimerkiksi tehdas-mallin (factory pattern) käytössä, jossa erikseen määritelty tehdas-olio on riippuvainen useiden eri luokkien synnystä. Se vähentää globaalisti riippuvuuksien määrää, mutta itse tehdas-oliot tuottaisivat metriikoiden mukaan paljon virheellisiä riippuvuusongelmia, jos jokainen riippuvuus olisi samanarvoinen.


\subsection{Erilaiset menetelmät UML-kaavoiden tukena}



\subsection{Havaitut testattavuuteen vaikuttavat tekijät}
Tähän kootusti kaikki löydöt.

Muita keinoja tutkia -> formulointi (Design Structure Matrix) \citep{mo_mapping_2013}

Erilaisia skenaariopohjaisia menetelmiä ehdottaa \citep[s. 8-9]{mattsson2006software} testattavuuden kannalta: SAAM, ATAM, EBAE.

Riippuvuuksien anti-pattern (7 kpl) ja niiden havaitseminen lähdekoodin avulla. Pystyisikö soveltamaan myös arkkitehtuurisella tasolla? \citep{binkley_dependence_2008} 

\section{Pohdinta} \label{pondering}

Ensin metriikat sitten esim. pentagrammimallin avulla analysointia per komponentti.

Löydetyt samankaltaisuudet

Metriikat + riippuvuusgraph.

Onko arkkitehtuurin kuvaaminen visuaalisesti aina formaalia?

% muista Viittaukset kappaleisiin

\section{Yhteenveto}

Tutkimuksessa on tehty katsaus ensin ohjelmistoarkkitehtuuriin käsitteenä ja luotu sen avulla katsaus siihen miten ohjelmistoarkkitehtuuria mallinnetaan. Ohjelmistoarkkitehtuuri on nähty tapana kuvata järjestelmän todellista rakennetta tavalla, joka kertoisi mahdollisimman selkeästi järjestelmän todellisen luonteen ilman tarvetta lähdekoodille. Katsauksen jälkeen on etsitty vastausta sille mitä on järjestelmän testattavuus. Testattavuudesta on jatkettu tarkastelua arkkitehtuuriselta näkökulmalta viimeisessä luvussa ja etsitty tapoja joiden avulla arkkitehtuurin mallinnus tuottaisia mahdollisimman paljon informaatiota järjestelmän testattavuudesta.

Tästä tutkimuksesta nähdään tutkimuskysymyksien valolla, että

%Muistuttaa mieleen tutkimuskysymyksen, mainitsee tärkeimmät tulokset ja niiden perusteet. Keskittyy impaktiin ja esimerkiksi suosituksiin. Ei vain summeeraa luku kerrallaan aikaisempaa tekstiä.

% miten testattavuus näkyy ohjelmistojen arkkitehtuurisella tasolla

% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

%\bibliographystyle{babalpha-lf}
\bibliographystyle{apsr}
\bibliography{references-fi}


% --- Appendices ---

% uncomment the following

% \newpage
% \appendix
% 
% \section{Esimerkkiliite}

\end{document}
