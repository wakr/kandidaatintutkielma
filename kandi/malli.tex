% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage[sort]{natbib} %uncomment for a harvard-style
%\usepackage[square,sort,comma,numbers]{natbib}


% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:


% testattavuus & arkkitehtuuri
\title{Testattavuuden ilmeneminen ohjelmistoarkkitehtuurissa}
\author{Kristian Wahlroos}
\date{\today}
\level{Kandidaatintutkielma}

% ; kenelle, miksi, millaisessa ympäristössä; tutkimuskysymys; tulokset; impakti)

\abstract{tiivistelmä (100-200 sanaa)}

% The following can be used to specify keywords and classification of the paper:

\keywords{ohjelmistoarkkitehtuuri, testattavuus, näkymä, näkökulma}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):" 
 
 \classification{
	Software and its engineering $\rightarrow$ System description languages 	\\
	Software and its engineering $\rightarrow$ Software defect analysis
 }
% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
%\numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}

% Write some science here.

%Esimerkkilause ja lähdeviite~\cite{esimerkki} ja \cite{esimerkki2}.
%jäsennelty asianmukaisesti (kenelle, miksi, millaisessa ympäristössä; ratkaisun lähestymistapa; tutkimuskysymys, tulokset ja impakti; loppulukujen roolitus).




%\section{Johdanto}
%purkaa auki teknisemmälle yleisölle samalla käsitteitä määritellen tutkimuskysymyksen, ratkaisuille ympäristöstä esiintulevat vaatimukset ja keskeiset käsitteet näiden asioiden esittelemiseksi.

%antaa riittävästi termistöä ja kysymyksenasetteluja, jotta myöhempänä teksissä on mahdollisuus analyysiin ja evaluointiin.
%Keskimmäiset luvut keskittyvät kukin "opettamaan" lukijalle yhden osakysymyksen tai näkökulman käsiteltävään asiaan. Lukujen työnjaon tulisi olla selkeä ja niillä tulee olla selkeä oma rakenteensa, jonka valintaperuste on lukijalle kerrottu.

%Viimeistä edellinen luku on varsinaisen kontribuution koti: vertailu, soveltaminen, osien synteesi ja mahdolliset evaluointimenetelmät ja -tulokset pääroolissa.

Ohjelmistoarkkitehtuuri on ohjelmistojen ymmärtämisen kannalta tärkeä konsepti, josta jokaisen ohjelmoijan pitäisi olla tietoinen, sillä jokaisella ohjelmistojärjestelmällä on oma arkkitehtuurinsa \citep[s. 4]{ieee_2000}. Suunnittelematon arkkitehtuuri eli niin sanottu \textit{Big Ball of Mud} saattaa pahimmassa tapauksessa olla yksi epäonnistuneen projektin tunnusmerkkejä, kun taas hyvin muodostettu arkkitehtuuri auttaa eri sidosryhmien välisessä kommunikaatiossa, tekee tuotettavasta ohjelmistojärjestelmästä helposti lähestyttävän, helpottaa sekä ohjelmiston testausta että validointia ja on yksi suurimmista onnistumistekijöistä projektin jatkon kannalta. 

Ohjelmistojen ylläpidettävyys lasketaan yhdeksi ei-toiminnalliseksi laatuvaatimukseksi, ja siihen kuuluu vahvasti ohjelmistojen testattavuus, joka taas vaatimuksena on lähempänä ohjelmoijaa kuin asiakasta. Testausta tapahtuu ohjelmistojärjestelmän elinaikana useita kertoja, joista  aikaisimmat jo projektin alkumetreillä, kun halutaan evaluoida järjestelmän toiminnallisuutta. Testattavuus taas määrittelee kuinka hyvin järjestelmään kohdistuva testaus löytää mahdolliset virheet ja kuinka helppo testitapauksia on luoda. Arkkitehtuurin ja testattavuuden yhteys on kuitenkin hieman häilyvä, vaikka arkkitehtuuri koskee jokaista kehittäjää. Tämä tutkimus pyrkii selventämään arkkitehtuurin ja testattavuuden suhdetta ja sitä, miten testattavuus tulee ilmi ohjelmistoarkkitehtuurissa. 

\subsection{Tutkimuskysymys}
Tutkimus vastaa kysymykseen miten testattavuus näkyy ohjelmistojen arkkitehtuurissa. Itse kysymys voidaan jakaa vielä tarkentaviin kysymyksiin: mitä on testattavuus ohjelmistojärjestelmissä, miten arkkitehtuuria voidaan kuvata, miten ohjelmistojärjestelmästä luotu näkymä kertoo jotain järjestelmän testattavuudesta. 

\subsection{Tutkimusmenetelmä}
Tutkimuskysymykseen vastataan kirjallisuuskatsauksen avulla ja tutkimalla mitkä arkkitehtuuriset päätökset ja elementit ovat sekä hyvän että huonon testattavuuden tekijöitä. Testattavuuden havaitsemiseen etsitään näkymää nykyisistä menetelmistä kuvata arkkitehtuuria. Näitä menetelmiä ovat pääasiassa erilaisten näkymien ja näkökulmien joukko, joiden avulla saadaan abstrahoitua järjestelmän lähdekoodia arkkitehtuurisempaan muotoon.

Itse tutkimus on rajattu pääosin ainoastaan oliopohjaisen arkkitehtuuriin ja sen kuvaamistapoihin. Testaustavoista on tuotu esille yksikkö -ja integraatiotestaus. Arkkitehtuurin mallintamisesta on jätetty ADL:t (architecture description languages) pois, koska ne eivät tarjoa visuaalista näkymää arkkitehtuuriin. Myöskään erilaisia arkkitehtuurisia tyylejä ei vertailla tutkimuksessa testattavuuden kannalta, vaan tutkimus keskittyy nimenomaan ohjelmistojärjestelmän konkreettisen rakenteen arvioimiseen testattavuuden kannalta.

\subsection{Tutkimuksen rakenne}

Kappaleessa 2 käydään läpi ohjelmistoarkkitehtuuria käsitteenä ja luodaan pohja eri kuvaustavoille ohjelmistoarkkitehtuuria varten. Samalla kuvataan miten ja mistä näkymä voidaan luoda ohjelmistojärjestelmälle. Kappale 3 keskittyy ohjelmistolle asetettaviin laadullisiin vaatimuksiin, joista kappale 4 tarkentaa testattavuutta. Kappale 5 etsii arkkitehtuurin ja testattavuuden välistä suhdetta.


\section{Ohjelmistoarkkitehtuuri}
Arkkitehtuuri ohjelmistoissa on käsite, josta moni kehittäjä on tietoinen mutta joka ei ole kovin yksiselitteinen eikä siitä ole yksimielistä määritelmää \citep[s. 363]{solms_what_2012}. 
Se kuvaa vähintään aina abstraktilla tasolla toteutettavaa ohjelmistojärjestelmää niin, että on mahdollista keskittyä vain suppeaan alueeseen jättämällä pois eri sidosryhmien kannalta epärelevantteja asioita. Kuvaus tapahtuu usein visuaalisella tavalla, koska visuaalisesta mallista on nopea ja helppo saada ulos tarvittava informaatio.   

\subsection{Ohjelmistojen arkkitehtuuri käsitteenä} \label{ark}
Ohjelmistoarkkitehtuuri voidaan nähdä karkeasti neljästä eri näkökulmasta  \citep[s. 2-7]{gorton_understanding_2011}:  ohjelmiston rakenteen kuvaajana, kuvaajana ohjelmiston komponenttien välisille suhteille, ei-toiminnalliset (non-functional) vaatimukset huomioon ottavana mallina ja yleisenä abstraktiona. 
% kappaleessa selitetään myös riippuvuuksien vähentämisestä

%Rakenteen kuvaajana arkkitehtuuri määrittelee ohjelmistojärjestelmän sisäistä rakennetta, joka koostuu useista komponenteista sekä moduuleista, jotka yhdistävät ja ryhmittelet komponentteja. Erilaiset moduulit tarjoavat aina tietyn toiminnallisuuden ja tämän kautta erilaiset vastuut on jaettu ohjelmistojärjestelmän sisällä loogiisiin kokoelmiin.
% kappaleessa myös patterneja

%Komponenttien välisen kommunikaation mallintaminen tapahtuu, kun ohjelmistojärjestelmää jaetaan erilaisiin komponentteihin. Tavoitteena on kertoa mallintamalla, että mitkä komponentit tai moduulit ovat vuorovaikutuksessa toistensa kanssa ja millä tavoin. Yleisin kommunikaatiotapa on esimerkiksi suorat funktiokutsut komponenttien välillä, joiden mallinnus selventää esimerkiksi informaation kulkua järjestelmässä.  
% kappaleessa ei-toiminnallisten vaatimuksien jako kolmeen eri luokkaan

%Ei-toiminnaliset vaatimukset tulevat kunnolla esille vasta arkkitehtuurin avulla ja arkkitehtuurin mallinnuksen avulla voidaan määrittää miten ohjelma suorittaa sille määrättyä tehtävää sen sijasta, että mallinnettaisiin ainoastaan mitä ohjelma tekee. 
% lähteitä lisää?

%Arkkitehtuurin avulla on mahdollista abstrahoida
%sidosryhmille ohjelmistojärjestelmää helpommin lähestyttäväksi, jolloin kommunikaatio eri osapuolten välillä helpottuu. Abstrahoinnin avulla pystytään yksinkertaistamaan järjestelmän konkreettista toteutusta ja suorittamaan arkkitehtuurista erittelyä (architectural decomposition), jossa muodostetaan epärelevanteista komponenteista mustia laatikoita (black boxes). Mustien laatikoiden ideana on piilottaa komponenttien sisäistä toteutusta eri abstraktiotasoilla, jolloin arkkitehtuurista voidaan muodostaa eri tarkkuustason malleja. 

Hieman samanlainen jaottelu on määritelty myös Solmsin tutkimuksessa \citep[s. 368-369]{solms_what_2012}. Siinä ohjelmistoarkkitehtuuri-määritelmä jaetaan kolmeen eri luokkaan: korkean tason abstraktioon ohjelmistojärjestelmästä, rakenteita sekä ulkoisia ominaisuuksia korostavaan määritelmään ja käsitteistöön sekä rajoitteisiin, joiden puitteissa ohjelmistojärjestelmää kehitetään. Näistä kaksi ensimmäistä määritelmää vastaavat samoja kuin \cite{gorton_understanding_2011} ja niitä voidaan mallintaa seuraavasti

\begin{itemize}
	\item korkean tason abstraktioita mallinnetaan erilaisten näkymien kautta tai käyttämällä IEEE:n määrittelemiä käytänteitä \citep[s. 4-5]{ieee_2000}
	\item rakenteita korostavassa mallinnuksessa käytetään usein UML-kaavioita ja niiden tuomia keinoja abstrahoida järjestelmää.
	
\end{itemize}

% IEEE:stä voisi kirjoittaa enemmän    
%Rakenteita korostettaessa mallinnuksessa käytetään usein UML-kaavioita, koska UML määrittelee ohjelmiston arkkitehtuuria osina, joita pystytään rekursiivisesti tarkentamaan haluttaessa. Tarkennuksen avulla osat pystytään kuvaamaan kommunikoivan keskenään erilaisten rajapintojen kautta, osia yhdistäviä suhteita pystytään tarkastelemaan ja erilaisia rajoitteita pystytään luomaan osien välille. 
% järjestelmien välinen kommunikaatio se lähde.

\noindent
Kolmas määritelmä on paljon laajempi näkemys ohjelmistoarkkitehtuurista, koska se kuvaa ohjelmistojärjestelmän käsitteistön ja ominaisuudet siinä ympäristössä, jossa ne ilmenevät elementtien, suhteiden ja suunnittelun periaatteiden kautta. Peruskäsitteistö tarjoaa sen käsitteistön, jonka avulla sovelluslogiikka voidaan määritellä, joten esimeriksi määrittelemällä, että jokin komponentti toteuttaa palvelimen toiminnallisuutta, saadaan asiat lokeroitua käsitteellisesti erilleen toisistaan. Ominaisuudet liittyvät ohjelmistojärjestelmän laadullisiin ominaisuuksiin. Periaatteet voidaan nähdä järjestelmän keskeisinä suunnittelurajoitteina (core design constraints), joiden kokonaisuus muodostaa järjestelmän arkkitehtuurisen tyylin. Ohjelmistojärjestelmän arkkitehtuurin tyyli voi koostua esimerkiksi väylistä ja suodattimista (pipes and filters). % lisää
\\

Näistä kahdesta eri jaottelusta ohjelmistoarkkitehtuuri-käsitteen välillä voidaan nähdä merkittävinä tarpeina kuvata ohjelmistojärjestelmän rakenteellisuutta, komponenttien välistä kommunikaatiota ja laadullisia vaatimuksia. Kaikki nämä edellämainitut ominaisuudet on saatava  upotettua ohjelmistojärjestelmästä luotavaan arkkitehtuuriseen malliin niin, että ne vastaavat muunmuassa seuraaviin kysymyksiin \citep[s. 31 - 33]{Rozanski:2011:SSA:2072649} 

\begin{itemize}
	\item mitkä ovat arkkitehtuurin toiminnalliset elementit
	\item miten nämä elementit kommunikoivat keskenään ja ulkomaailman kanssa
	\item mitä tietoa käsitellään, talletetaan ja esitetään
	\item mitä fyysisiä ja ohjelmallisia elementtejä tarvitaan tukemaan näitä  elementtejä
\end{itemize}

Arkkitehtuurista luotava malli ei kuitenkaan saisi olla monoliittinen malli, joka pyrkii kuvamaan kaiken yhdessä mallissa, koska arkkitehtuuria ei ole mahdollista kuvata vain yhden mallin avulla \citep{Rozanski:2011:SSA:2072649}. Tämä johtuu siitä, että monoliittinen malli paisuu liian suureksi, jolloin sitä on vaikea kenenkään osapuolen enää ymmärtää ja siitä on vaikeaa löytää arkkitehtuurin tärkeimmät ominaisuudet. Monoliittinen malli on usein myös puutteellinen, jäljessä eikä vastaa enää nykyistä ohjelmistojärjestelmää.  


\subsection{Arkkitehtuurin kuvaus}

Ratkaisu monoliittiseen malliin on jakaa arkkitehtuurin kuvaus useisiin toisiinsa liittyviin näkymiin (views), jotka esittävät jokainen yhden näkökulman (viewpoint) järjestelmän arkkitehtuuriin keräämällä yhteen sekä toiminnalliset piirteet että laadulliset ominaisuudet \citetext{\citealp[s. 33-34]{Rozanski:2011:SSA:2072649}; \citealp[s. 8-9]{gorton_understanding_2011}; \citealp[s. 117]{Ran:1998:ASV:288408.288438}}.

Arkkitehtuurin kuvaaminen sallii myös kommunikoinnin eri sidosryhmien välille ja mahdollistaa järjestelmän tarkastelemisen vain niiltä osin, jotka tiettyä sidosryhmää kiinnostavat \citetext{\citealp[s. 329]{ARaHVeSCiSDu}; \citealp[s. 60]{Brondum:2010:TAV:1833335.1833344}}. Kuvaaminen tapahtuu näkymien avulla, jotka auttavat erottelemaan (separation of concerns) arkkitehtuuria pienempiin palasiin \citep[s. 2]{Galster:2011:DTC:2031759.2031761}. Itse näkymät luodaan käyttämällä ennaltamäärättyjä näkökulmia, jotka edustavat tiettyä tai useampaa sidosryhmälle tärkeää asiaa. 

%Hyvä kommunikointi sidosryhmien kanssa on aina tärkeää, joista ääripäinä ovat kehittäjät ja asiakkaat. Kehittäjät haluavat usein todella tarkkaa usean eri tason ja näkökulman abstraktia kuvausta luotavasta järjestelmästä \citep[s. 120]{Ran:1998:ASV:288408.288438} tai ymmärtääkseen jo valmiiksi luotua järjestelmää \cite{ARaHVeSCiSDu}, kun taas asiakkaat haluavat nähdä järjestelmän toiminnallisuuden juuri heitä koskevien asioiden kannalta ja usein mahdollisimman korkealla tasolla.

\subsubsection{Näkymät}
Arkkitehtuuristen näkymien tehtävänä on kuvata tietylle asialle olevat merkitykselliset näkökulmat arkkitehtuurista, joita näkymä haluaa painottaa \citetext{\citealp[s. 34]{Rozanski:2011:SSA:2072649}; \citealp[s. 15]{may2005survey}}. Yksi tunnetuimmista määritelmistä arkkitehtuuriselle näkymälle on Krutchenin 4+1 näkymämalli (4+1 View Model) \citep[s.7-8]{gorton_understanding_2011}. 

4+1 -mallissa arkkitehtuuri kuvataan neljän näkymän ja yhden tekstuaalisen kuvauksen avulla 

\begin{itemize}
	\item looginen, joka kuvailee järjestelmän rakennetta ja suhteita
	\item prosessinen, joka keskittyy suorituksen kuvaamiseen
	\item fyysinen, joka esittää miten komponentit kuvautuvat fyysiselle laitteistolle
	\item kehityksellinen, joka kuvailee järjestelmän sisäistä toteutusta
	\item skenaariollinen, jonka avulla näkymät liitetään yhteen.
\end{itemize}

%Looginen näkymä kuvailee esimerkiksi luokkakaavioiden avulla ohjelmistojärjestelmän elementtejä ja niiden välisiä suhteita tarkentaen järjestelmän rakennetta, prosessinäkymä keskittyy ajonaikaisen suorituksen kuvaamiseen tarkentamalla muunmuassa miten samanaikaisuuden hallinta tapahtuu järjestelmässä, fyysinen näkymä keskittyy siihen miten järjestelmän eri komponentit kuvautuvat fyysiselle laitteistolle jossa komponenttia ajetaan ja lopuksi kehitysnäkymä (development view) keskittyy järjestelmän sisäiseen toteutukseen tarkemmalla tasolla kuvailemalla sisäkkäisia pakkauksia tai luokkahierarkiaa. Jokainen näkymä voidaan liittää osaksi toista näkymää skenaarioiden avulla, jotka heijastelevat järjestelmälle asetettuja vaatimuksia, jolloin skenaariot voidaan nähdä ikäänkuin liimana muuten erillisille näkymille. 

Muita näkymämalleja arkkitehtuuriin on useita, joista jokainen kuitenkin tuo esille vähintään jollain tavalla ohjelmistojärjestelmän rakennetta ja yhteyksiä. Tästä esimerkkinä tunnettu \textit{Views and Beyond} -malli \citep[s.8]{gorton_understanding_2011}. Siinä arkkitehtuurinen malli kuvataan kolmella eri näkymällä

\begin{itemize}
	\item moduuli, joka on rakenteellinen näkymä järjestelmään
	\item komponentit ja konnektorit, jotka kuvailevat järjestelmän toiminnallista puolta
	\item allokaatio, joka kuvaa miten prosessit kuvautuvat laitteistotasolla.
\end{itemize}

 %moduuli, joka on järjestelmän rakenteellinen näkymä kuvaten muunmuassa luokkia, pakkauksia, moduulien eriyttämistä (decomposition) sekä periytymistä; komponentti ja konnektori, joka kuvailee järjestelmän toiminnallista puolta sekä miten komponentit ovat yhteydessä toisiinsa; allokaatio, joka kuvailee miten prosessit kuvautuvat laitteistotasolla  ja miten ne kommunikoivat keskenään. 

Näiden kahden esitellyn mallin lisäksi on olemassa joukko eri tarkoituksiin sopivia näkymämalleja, joilla on omat vahvuutensa ja heikkoutensa. Yhteensä viittä eri mallia vertailtiin Mayn tutkimuksessa \citep{may2005survey}. Siinä kartoitettiin mahdollisimman laajaa näkymien muodostamaa näkökulmien joukkoa, jotka kattaisivat mahdollisimman laajalti ohjelmistoarkkitehtuurin aluetta (domain). Vertailtavat arkkitehtuurit olivat 4+1-malli, SEI:n (Software Engineering Institute) \textit{Views and Beyond}-malli, ISO:n (International Organization for Standardization) \textit{Reference Model of Open Distributed Processing}, Siemensin \textit{Four View Model} ja \textit{Rational Architecture Description Specification}. Malleja vertailtiin tutkimalla kuinka niiden tarjoamat näkökulmat painottavat kolmeen eri kategoriaan liittyviä asioita: sidosryhmät, laadulliset tekijät ja rakenteelliset ominaisuudet. Lopulliseen valintaan, joka painotti mahdollisimman laajasti jokaisen osa-alueen ominaisuuksia, otettiin mukaan \textit{Views and Beyond} -mallin kaikki kolme näkymää ja \textit{Rational ADS}:n vaatimukset-näkökulma (requirements viewpoint). Syy, miksi juuri nämä valittiin oli se, että \textit{Views and Beyond} sopii erittäin hyvin mallin pohjaksi, koska se kuvaa järjestelmän rakennetta kattavasti, sen näkökulmat ovat itsenäisiä ja se limittyy kokonaisuudessaan hyvin 4+1-mallin sekä Siemens'n mallin kanssa. Se ei kuitenkaan sisällä tarvittavia näkymiä kuvaamaan eri sidosryhmille tärkeitä asioita esimerkiksi loppukäyttäjiä varten oleva näkymä puuttuu kokonaan. Tämän takia mukaan on otettu \textit{Rational ADS}, jonka vaatimukset-näkökulma koostuu neljästä eri näkymästä: ei-toiminnalliset vaatimukset, alue (domain), käyttötapaus ja käyttökokemus. 



\subsubsection{Näkökulmat}
Rozanskin ja ym. \citep[s. 36-42]{Rozanski:2011:SSA:2072649} määrittelevät, että näkökulmat liittyvät vahvasti arkkitehtuurisiin näkymiin. Näkökulma voidaan määritellä olevan kokoelma malleja (patterns), templaatteja sekä konventioita, joiden avulla näkymä pystytään rakentamaan.  Näkökulmien joukko taas voidaan jakaa seitsemään eri osaan: kontekstuaalinen, funktionaalinen, informaatiollinen, samanaikaisuudellinen, tuotannollinen, käyttöönotollinen ja operationaalinen. Näistä keskitytään tämän tutkimuksen myöhemmässä vaiheessa tuotannollisen sekä funktionaalisuuden näkökulmaan. Kehittämisen näkökulma on tärkeä siksi, että se ottaa huomioon niiden sidosryhmien asiat, jotka ovat mukana järjestelmän kehityksessä, testauksessa, ylläpidossa ja parantamisessa. Funktionaalinen näkökulma taas painottaa muunmuassa järjestelmän suorituksenaikaisia komponentteja ja niiden rajapintoja.

% 4210 ISO
IEEE:n virallinen määritelmä näkokulmalle on \textit{a specification of the conventions for constructing and using a view. A pattern or template
from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis} \citep[s. 4]{ieee_2000}. Se on määritelmä, jota tullaan käyttämään myös tässä tutkimuksessa.




%onko testatavuus missäkin tapauksessa eri näkymien yli menevä vai voiko tai kannattaako sille jossain tilanteessa olla ihan oma näkymänsä, ja jos niin millainen se sitten olisi

\subsection{Näkymän luominen}

Ohjelmistoarkkitehtuuri toimii siltana ohjelmakoodin ja ohjelmalle asetettujen vaatimusten välillä \citep[s. 94]{Garlan:2000:SAR:336512.336537}, joten on luonnollista, että näkymä luodaan näiden pohjalta. Sitä luodessa on myös otettava huomioon kenelle näkymä on tarkoitettu, minkälaisia asioita halutaan näkymän painottavan ja millä abstraktiotasolla näkymän tulisi olla. 

Esimerkiksi ohjelmakoodin kautta luotava malli saattaa olla näkymä projektin rakenteeseen uusia ohjelmoijia varten, jotta voitaisiin helposti esittää kyseisen ohjelmistojärjestelmän päärajapinnat. Tällaisen mallin päätarkoitus on kuvata ohjelmistojärjestelmän rakennetta ja toisaalta abstrahoida pois kaikki turhan tarkat kuvaukset komponenteista, joilla ei ole juuri sillä hetkellä merkitystä. 

Toiselta näkökulmalta katsottuna taas voi olla, että juuri mahdollisimman paljon halutaan nähdä katsomatta lähdekoodia, koska se joko ei ole saatavilla tai se on kehittäjälle liian monimutkaista ja aikaavievää käydä kokonaan läpi. Tähän tarkoitukseen sopii UML:n avulla luodut kaaviot järjestelmän rakenteeesta, josta pystytään näkemään erilaisia ohjelmistojärjestelmän attribuutteja esimerkiksi kuinka testattava järjestelmä on.

%Chapt. 7 & 8 + Arch views -paperi + What is an architectural description?
%Jos järjestelmää ei ole vielä olemassa lainkaan, voidaan järjestelmän arkkitehtuuria lähteä ensin rakentamaan iteratiivisesti kolmen eri vaiheen kautta \citep[s. 97-115]{gorton_understanding_2011}: määritellään arkkitehtuuriset vaatimukset; luodaan rakenne, joka tukee näitä vaatimuksia; testataan, että rakenne tukee vaatimuksia. Arkkitehtuurille asetetut vaatimukset syntyvät toiminnallisten ja sidosryhmien asettamien vaatimusten tuloksena, koska ne yhdessä luovat tärkeimmät vaatimukset ja rajoitukset ohjelmistojärjestelmälle. Esimerkkinä järjestelmälle asetettavista vaatimuksista saattaa olla, että sen on pystyttävä tukemaan useita eri käyttöliittymiä. Tämä vaatimus voidaan taas ryhmittää tiettyyn laatuvaatimukseen, kuten useat muutkin järjestelmälle asetetut vaatimukset \citep[s. 117]{Ran:1998:ASV:288408.288438}. Tässä tapauksessa vaatimus ryhmitettäisiin muokattavuus-laatuvaatimuksen alle. Seuraavassa vaiheessa valitaan tätä laatuvaatimusta tukeva tyyli (architectural style), jota koko järjestelmä joutuu noudattamaan. Esimerkiksi N-tason -malli tukee muokattavuutta hyvin \citep[s. 103]{gorton_understanding_2011}. Tämän jälkeen järjestelmän keskeisimmät komponentit suunnitellaan ja sijoitetaan ne oikeisiin alueisiin, jotka valittu arkkitehtuurinen tyyli tuo tullessaan. Komponenttien väliset suhteet mallinnetaan pitämällä vastuut erillään, suhteet mahdollisimman vähäisinä sekä käyttämällä hyödyksi piilottamista (architectural decomposition). Lopuksi pystytään luomaan skenaarioita ja testaamaan niiden avulla, että onko luotu arkkitehtuuri sopiva. Komponenttien määrittely mahdollistaa arkkitehtuurin rakenteen kuvaamisen ja siten järjestelmästä on mahdollista luoda erilaisia näkymiä erilaisille sidosryhmille. Rakennetta pystytään kuvaamaan N-tason -mallin avulla erittäin korkealla tasolla, jos halutaan tuoda esille juurikin näkökulma muokattavuuteen, mutta myös matalemmalla tasolla, kun ohjelmistokehittäjä haluaa ymmärtää miten komponentit kommunikoivat keskenään.

%\section{Ohjelmistojen laadulliset tekijät}


%\subsection{Laatuvaatimukset}
%\subsubsection{Toiminnalliset}
%\subsubsection{Ei-toiminnalliset vaatimukset}
%\subsection{Tradeoffit}
%\subsection{Arviointi}


\section{Testattavuus laadullisena tekijänä}
Testattavuus luetaan kuuluvaksi ylläpidettävyyden alle \citep{ISO/IEC25010:2011} ja on täten yksi laatuvaatimuuksista. Laatuvaatimuksena se ei kuitenkaan ole aina edes kovin näkyvä esimerkiksi asiakkaalle mutta ohjelmistokehittäjälle se tulee esille useassakin kontekstissa. Vaikeasti testattavaa järjestelmää on myös vaikea ylläpitää, ja ylläpidettävä järjestelmä on sekä asiakkaalle että kehittäjälle tärkeä ominaisuus.

% Yksikkö vs integraatio vs regressio testauksessa.
Ohjelmistojärjestelmään kohdistuva testaus voidaan jakaa moneen eri luokkaan, joista kaksi yleisintä ovat yksikkö -ja integraatiotestaus. Yksikkötestauksessa varmistetaan järjestelmän komponenttien toiminnallisuutta itsenäisesti, kun taas integraatiotestauksessa testaus kohdistuu järjestelmän rajapintoihin ja komponenttien yhteistoiminnallisuuteen. Testauksen voidaan nähdä siis löytävän itse viat, mutta testattavuus taas löytää paikat, joissa viat voivat sijaita \citep[s. 19]{Voas:1995:STN:624607.625469}. Testattavuus tukee täten testausta ja testausprosessia, koska sen avulla voidaan määritellä, mikä on todennäköisyys sille, että järjestelmässä olevat viat löydetään \citep[s. 114]{voas_improving_1992}. 


\subsection{Testattavuuden arviointi} \label{contro_and_observ}

Testattavuuden arvioimisessa voidaan käyttää hyödyksi kolmea eri parametria \citep[s. 2]{baudry_measuring_2003}: havaittavuus (observability), hallittavuus (controllability) ja vaativuus, joka tarvitaan suorittamaan tietty testi. Havaittavuus määrittelee, kuinka mahdollista testien tuloksia on tarkastella, ja hallittavuus sitä, kuinka paljon testattavaan komponentin tilaan voidaan vaikuttaa. Havaittavuus voidaan myös nähdä arvona, joka kertoo kuinka helppo on määrittää vaikuttavatko tietyt syötteet testituloksiin, ja hallittavuus taas voidaan nähdä siitä kuinka helppo on tuottaa jokin tietty tulos syötteestä \citep[s. 554]{Freedman:1991:TSC:126218.126229}. 

%Domain-to-range indicates observability by comparing the size of the output range of a component to size of its input domain \citep[s. 2]{Jungmayr:2002} \citep[s. 20-21]{Voas:1995:STN:624607.625469}

Havaittavuuden parametrisoimiseen on kehitetty \textit{domain-to-range} -arvo eli DRR, jonka avulla voidaan sekä havaita implisiittistä tiedonkatoamista \citep[s. 20-22]{Voas:1995:STN:624607.625469} että arvioida järjestelmän havaittavuutta \citep[s. 1]{Jungmayr:2002}. DRR-arvo saadaan vertailemalla komponenttien mahdollisen tulosteen (ouput) joukon kokoa syötteen (input) kokoon.  



\subsection{Hyvä testattavuus}

%Hyvä testattavuus on järjestelmän laadulle hyvä ominaisuus \citep[s. 20]{Voas:1995:STN:624607.625469}. 

Hyvä testattavuus auttaa järjestelmän ylläpidossa, validoinnissa ja parantaa järjestelmien laatua \citep[s. 20]{Voas:1995:STN:624607.625469}. Se on siis tavoiteltava ominaisuus jokaisessa ohjelmistojärjestelmässä, mutta hyvän testattavuuden saavuttaminen on aina ohjelmistöjärjestelmäkohtaista. Tästä syystä onkin mielekkäämpää tarkastella, mikä luo yleisesti järjestelmissä hyvää testattavuutta. 

%Testattavan komponentin ominaisuudet: testitapaukset ovat pieniä ja helposti luotavia, testitapaukset eivät ole itseään toistavia, ongelmat on helppo jäljittää tiettyihin komponentteihin \citep[s. 554]{Freedman:1991:TSC:126218.126229}

%Jo suunnitteluvaiheessa voidaan kiinnittää huomiota testattavuuteen ja näin parantaa itse testausprosessia. Decomposition, moduulien korkeat DRR (domain/range -ratio), korkean DRR:n omaavat moduulit mah. pieniksi ja eriytetyiksi, hyvä rajapinta joka paljastaa tarpeeksi moduulin sisäistä tilaa \citep[s. 117]{voas_improving_1992}.


%Isolating modules with high DDR \citep[s. 23]{Voas:1995:STN:624607.625469}.

\citep[s. 554]{Freedman:1991:TSC:126218.126229} on määritellyt testattavan komponentin ominaisuuksiksi: komponentista luotavat testitapaukset pysyvät pieninä ja ovat helposti luotavissa; komponentin testitapaukset eivät ala toistamaan itseään; komponentin testauksen aikana havaitut ongelmat on helppo jäljittää tiettyihin komponentteihin. Näitä tukemaan voidaan jo arkkitehtuurin alkuvaiheessa kiinnittää huomiota seuraaviin tekijöihin \citep[s. 117]{voas_improving_1992} 

\begin{itemize}
	\item dekomposition mahdollisuus
	\item tunnistaa moduulit, joiden DRR-arvo on korkea ja tehdä ne mahdollisimman pieniksi ja yksinkertaisiksi
	\item rajapinta korkean DRR-arvon moduuleille siten, että rajapinta paljastaa tarpeeksi tietoa
	\item eriyttää korkean DRR-arvon moduulit toisistaan \citep[s. 23]{Voas:1995:STN:624607.625469}.
\end{itemize}






\subsection{Huono testattavuus}

Tietyt ominaisuudet vaikuttavat yleisesti ohjelmistojärjestelmissä negatiivisesti testattavuuteen. Tiedon katoaminen on yksi näistä \citep[s. 20-22]{Voas:1995:STN:624607.625469} ja se voidaan jakaa implisiittisen ja eksplisiittisen tiedon katoamiseen. Implisiittisessä katoamisessa useat eri parametrit samaan kohteeseen tuottavat myös saman testituloksen, ja eksplisiittisessä tiedon katoamisessa tietoa piilotetaan ulkoiselta näkymältä. Tiedon piilottaminen on hyvin yleinen tapa olio-ohjelmoinnissa, ja liiallinen tiedon piilotus tuottaakin vaikeuksia testauksessa, koska hallittavuus heikkenee. 

Ongelmat syötteiden ja tulosten tarkastelussa tiedon katoamisen johdosta johtavat helposti tarpeettomiin testeihin, joita on vaikea ymmärtää \citep[s. 554]{Freedman:1991:TSC:126218.126229}, ja vaikeasti testattavan komponentin voidaankin sisältävän ulos- ja sisääntuloparametrien epäjohdonmukaisuuksia. Toisin sanoen vaikeasti testattava komponentti tuottaa eri tuloksia eri ajoilla tai ei ikinä tuota haluttua tulosta.   




\subsection{Testattavuuden mittaaminen} \label{testability_measure}

% Koskee UML-kaaviota -> Testability anti-patterns välttäminen (huono ratkaisu) suunnitteluvaiheessa\citep{baudry_measuring_2003}. \textbf{Jakaa} tämän kahtia: luokkien A ja B välinen interaktio jossa A:sta 2 tai useampi yhteys B:hen; itsekäyttö luokalla A on silloin, jos A:sta on yhteys itseensä. \textbf{Syitä}: suuri kytkentätaso, riippuvuuksissa syklejä, paljon mahdollisia vuorovaikuttavia komponentteja (viidakko). \textbf{Aiheuttaa}: vastuiden määrittely vaikeutuu ja testaus vaikeutuu, koska testicasejen määrittely vaikeutuu ja määrä kasvaa. \textbf{Estetään}: identifioimalla epäselvät suhteet.


Koska suoraan hyvää tai huonoa testattavuutta on vaikeaa määritellä, on erilaisia testattavuuteen vaikuttavia mittareita tutkittu paljon. Olio-pohjaisista järjestelmistä voidaan havaita seuraavat testaukseen vaikuttavat tekijät, joiden suuri arvo korreloi vahvasti huonoon testattavuuteen \citep[s. 5]{Dubey:2011:AMM:2020976.2020983}:

\begin{itemize}
	\item metodien määrä luokassa
	\item metodien määrä luokkahierarkiassa, jotka suoritetaan, kun luokan metodi suoritetaan
	\item luokkien määrä, johon luokalla on kytkentää
	\item periytymisaste
\end{itemize}

\noindent
Nämä tekijät ovat negatiivisia asioita testauksen kannalta, koska suuri metodien määrä on merkki luokan liiallisesta kompleksisuudesta ja se johtaa testauksen monimutkaistumiseen. Suuri kytkennän määrä vaikeuttaa luokan itsenäistä testaamista, ja suuri periytymisaste tuo luokalle mahdollisesti paljon perittyjä metodeja, jotka on toteutettu jossain muualla, jolloin luokka on riippuvainen erittäin paljon muiden luokkien toteutuksista. 

\citep[s. 3-4]{Khan:2009:MBT:1507195.1507204} käyttää taas seuraavaa neljää metriikkaa laskeakseen testattavuutta järjestelmissä, jotka vahvasti korreloivat edellisiin metriikoihin 

\begin{itemize}
	\item enkapsulaation taso
	\item uudelleenkäytön taso
	\item kytkennän taso
	\item koheesion taso.
\end{itemize}   

% Testattavuuden mittareita lisää \citep{Bruntink:2004}.

Lisää testattavuuden mittareita yksikkötestauksen näkökulmasta on määritelty \citep[s. 9]{Bruntink:2004}. Siinä testitapausten kasvuun ja pituuteen vaikuttivat luokan 

\begin{itemize}
	\item toisten luokkien määrä, joita luokka kutsuu tai jonka kenttiin se viittaa
	\item koko (rivien määrä)
	\item omien metodien määrä ja muiden luokkien metodien määrä, joita omat metodit käyttävät.
\end{itemize} 

Nämä kaikki edellämainitut mittarit ovat ominaisuuksiltaan sellaisia, että niitä voidaan suurimmaksi osaksi mitata vain lähdekoodin avulla. Usein ohjelmistokehittäjät joutuvat tilanteisiin, joissa ainoa järkevä näkymä järjestelmään on abstraktilla tasolla oleva luokkakaavio.

\subsection{UML-kaavio testattavuuden havaitsemisessa}

UML-luokkakaavio on todella yleisesti käytössä oleva mallinnustapa, ja juuri sen avulla nähdään hyvin järjestelmän rakennetta. Se toimii hyvänä pohjana, kun halutaan mitata luokkien välisiä suhteita ja riippuvuuksia \citep{baudry_testability_2002}. 

%Luokkakaavion avulla on myös mahdollista nähdä eri asioita kuin suoraan lähdekoodista, koska se toimii abstraktiivisena näkymänä peilaten lähdekoodissa olevia asioita. Tämän avulla se tuo hieman korkeamman tason näkymän järjestelmään, mutta ilman liiallista tiedon piilottamista. 

\citep[s. 3]{baudry_measuring_2003} määrittelee testattavuuden anti-mallin (testability anti-pattern) luokkakaavioiden avulla. Anti-mallissa kaksi suurta tekijää vaikuttavat testattavuuteen negatiivisesti: luokkien välinen suuri interaktio ja itsekäyttö, jossa luokka on riippuvainen rekursiivisesti itsestään. Syitä näiden kahden esiintymiselle voi olla luokkien välinen suuri kytkentätaso, riippuvuuksien syklimäisyys ja luokkien välinen suuri kommunikaatiotaso. Yhdessä nämä tekijät vaikeuttavat paljon vastuiden jakamista ja kasvattavat tarvittavien testitapausten määrää. 

% UML \citep{baudry_testability_2002}

UML:n avulla luotavalla riippuvuusgraafilla, esittävät testattavuuteen negatiivisesti vaikuttaviksi asioiksi \citep{baudry_testability_2002}

\begin{itemize} 
	\item kompleksiset perintäsuhteet
	\item abstraktien luokkien liikakäyttö rajapintojen sijasta.
\end{itemize}


Näiden lisäksi \citep{Jungmayr:2002} käsittelee testauksen kannalta kriittisten riippuvuuksien poistoa. Luokkakaaviosta saatavia mittareita tunnistetaan kolme kappaletta 

\begin{itemize}
	\item komponenttien keskimääräinen riippuvuuksien määrä
	\item komponenttien määrä riippuvuussykleissä
	\item \textit{feedback-riippuvuuksien\footnote{\textit{Feedback-riippuvuus} on syklinen riippuvuussuhde komponenttien välillä, josta poistamalla jokin riippuvuus saadaan sykli purettua täysin.}}  määrä 
\end{itemize}


%\subsection{Design for testability}

%Järjestelmä voidaan suunnitella tukemaan hyvää testattavuutta \citep[s. 20]{Voas:1995:STN:624607.625469}. 

 
Löydetyistä mittareista huomataan, että ne tarkastelevat korkeammalla tasolla testattavuutta, kuin aiemmat lähdekoodi-tasoiset mittarit. Ne mittaavat esimerkiksi komponenttien ominaisuuksia ja yhteyksiä, jotka tulevat esille kunnolla vasta arkkitehtuurisella tasolla. Komponenttien ja yhteyksien tarkastelu oli myös luvussa \ref{ark} esitelty eräs näkemys ohjelmistoarkkitehtuuriin. On järjestelmän todellisen testattavuuden määrittelemisen kannalta parempi, jos sitä tarkastellaan korkeammalla tasolla, koska liian tarkka kuvaus järjestelmästä vaikeuttaa todellisten ongelmien näkemistä.  

\section{Testattavuus arkkitehtuurisella tasolla}

Arkkitehtuurisella tasolla testattavuus vaikuttaa laajemmin ja arkkitehtuuristen ongelmien tutkimiseen on käytettävä eri keinoja, kuin kooditason analysoinnissa \citep[s. 186]{kazman_case_2015}. Testattavuutta voidaan tutkia kuitenkin esimerkiksi komponenttitasolla, jota tukevat hyvin UML-komponenttikaaviot. Tämä käy arkkitehtuurin arvioimiseen testattavuuden kannalta hyvin, koska testattavuus tulee ilmi korkealla tasolla muunmuassa integraatiotestauksen aikana, kun sekä komponenttien rajapintojen toimivuus että komponenttien toimivuus pitää validoida \citep[s. 65]{Eickelmann:1996:MOS:243327.243602}. 

Komponenttien testattavuutta on analysoitu muun muassa erilaisten mallien avulla ja näistä eräs on komponenttien testattavuus malli (component testability model) \citep[s. 6]{gao_component_2005}. Sen avulla jokaista komponenttia tarkastellaan viideltä eri näkökulmalta: havaittavuus, hallittavuus, jäljitettävyys (traceability), tuki testivalmiudelle (test support capability) ja ymmärrettävyys (understandability). Näistä kaksi ensimmäistä ovat ideoiltaan samat kuin kappaleessa \ref{contro_and_observ} ja loput vastaavat muunmuassa kysymyksiin: kuinka helppoa on tarkastella komponentin tilaa ulkopuolisena; kuinka hyvin komponentti tukee erilaisia testausstrategioita; kuinka hyvin komponentin tarkoitus ymmärretään, että testejä pystytään kehittämään.

% \citep{Binder:1994:DTO:182987.184077}
%Testattavuus olio-perustaisissa ohjelmissa Separation of Concerns [parantaa controllability ja observability], Built-in Test [stubit yms.], Structure (Polymorfismi, enkapsulaatio, perintä [Number of Root Classes, FIN, Number Of Children, Depth of Inheritance Tree], kompleksisuus [Coupling Between Objects, koko]).

%Koodi vs arkkitehtuurinen eri ongelmat ja ne voidaan havaita eri tekniikoilla, muttei samalla. Arkkitehtuurinen velka yleistä \citep[s. 186]{kazman_case_2015}.


 

\subsection{Hyvä testattavuus arkkitehtuurissa}

%Tietyt arkkitehtuuriset tyylit sopivat tiettyihin testaustapoihin (critical module, sandwich, top-down, bottom-up, thread, big bang) \citep{Eickelmann:1996:MOS:243327.243602}. Kolmeen ensimmäiseen liittyvät vahvasti stubit ja test driverit. 

%Testattavuuden parantaminen erillisen patternin avulla \citep{coelho_improving_2005}.

Hyvään testattavuuteen arkkitehtuurisella tasolla vaikuttaa paljon oikean tyylin valitseminen oikeaan tilanteeseen ja tyylien tuomien rajoitteiden oikeaoppinen noudattaminen \citep[s. 66]{Eickelmann:1996:MOS:243327.243602}. Arkkitehtuuri on myös pitänyt dokumentoida jollain tavalla, jotta testattavuutta pystyttäisiin arvioimaan \citep[s. 6]{mari_impact_2003}, koska sen avulla pystytään luomaan kehys, joka määrittelee järjestelmän arkkitehtuurisia päätöksiä ja rajoitteita. Se helpottaa vikojen paikallistamista ja testauksen painopisteiden määrittelyä kehittäjille, jos dokumentoinnissa on eksplisiittisesti kerrottu, että mitkä komponentit kuuluvat esimerkiksi kolmikerrosarkkitehtuurin eri tasoille. 

%Testien isolaation mahdollistaminen sekä hallittavuus ja havaittavuus, jotka ovat myös ohjelmakooditasolla tärkeitä, ovat merkkejä hyvästä testattavuudesta arkkitehtuurisella tasolla.
Oliopohjaisissa ohjelmistojärjestelmissä vastuiden jakamisen koetaan olevan hyvä lähtökohta testattavuuden määrittelemisessä, koska se parantaa koko järjestelmän havaittavuutta ja hallittavuutta \citep{Binder:1994:DTO:182987.184077}. Binder määrittelee myös muita ominaisuuksia testattavalle järjestelmälle, kuten sisäänrakennettu testausominaisuus (built-in test) ja järjestelmän jäljitettävyys. Rakenteelliselta tasolta hän painottaa kapselointia, polymorfismia, perintää ja kompleksisuuden tarkastelua, jotka vaikuttavat vahvasti järjestelmän testattavuuden arviointiin.



Järjestelmän tarkasteltavuus (monitorability) on yksi osatekijä ylläpidettävyydessä vaikuttaen positiivisesti testattavuuteenkin \citep[s. 4]{mari_impact_2003}. Se voidaan jakaa kolmeen eri luokkaan: komponentin sisäinen, komponenttien välinen sekä järjestelmätasoinen yhteistoiminnallisuus ja on testattavuuden kannalta hyvä, jos komponenteista löytyy myös aputoiminnallisuutta testausprosessia varten. Tämä toiminnallisuus voi koostua muunmuassa ylimääräisistä testausrajapinnoista tai komponenteista, jotka tukevat jotain edellämainitusta kolmesta tarkasteltavuuden luokasta. Yksi todella yleinen käytänne on esimerkiksi erilaisten tynkäluokkien (stub) käyttö, joissa testausta varten voidaan polymorfismia käyttää hyödyksi niin, että luokan ongelmalliset komponenttiriippuvuudet saadaan korvattua testien ajaksi jollain yksinkertaisemmalla toteutuksella. Tämän toteuttaminen vaatii järjestelmältä löyhiä riippuvuuksia rajapintojen muodossa.

\citep[s. 591-592]{joshi_design_2014} tunnistaa DFT:n (Design for Testability). Vaikuttavat mittarit + yleistä. 




\subsection{Arkkitehtuurin testattavuuden mittaaminen}

Koska testattavuus kuuluu ylläpidettävyyteen, sitä voidaan mitata arkkitehtuurisella tasolla analysoimalla näkymää, josta nähdään järjestelmän rakennetta korkealla tasolla. Seuraavat mittarit on luotu arvioimaan ylläpidettävyyttä arkkitehtuurisella tasolla koskien arkkitehtuurisia elementtejä \citep[s. 3-4]{bengtsson1998towards}:

\begin{itemize}
	\item metodien määrä elementin rajapinnassa
	\item paikkamerkkien (placeholder) määrä arkkitehtuurisille elementeille, joiden avulla elementti parametrisoidaan
	\item elementistä lähtevien viestien määrä
	\item elementtityyppien määrä, joita tarkasteltava elementti toteuttaa (implement)
	\item elementtien määrä, jotka toteuttavat tarkasteltavan elementin tyypin
	\item saatavilla olevien metodien lukumäärä muista elementeistä, jotka ovat yhteydessä tarkasteltavaan elementtiin
	\item elementin metodien ja parametrien määrä
\end{itemize}

On melko selvää, että nämä mittarit ovat osittain hyvin samankaltaisia kuin kappaleessa \ref{testability_measure} määritellyt mittarit testattavuuden mittaamiseen. Tämä samankaltaisuus johtuu siitä, että asiat, jotka vaikuttavat järjestelmän arkkitehtuurin ylläpidettävyyteen, vaikuttavat myös järjestelmän testattavuuteen. Edellisistä mittareista myös nähdään, että moni pyrkii jossain määrin määrittelemään esimerkiksi kytkennän tasoa. Kytkentä järjestelmä-tasolla on ollut tutkimuksen kohteena jo paljon aikaisemminkin \citep{Rosane:1981} ja se määriteltiin kappaleessa \ref{testability_measure} yhdeksi tavaksi mitata testattavuutta. 

Komponenttien huonoa modulaarisuutta CLIO:n avulla. Cyclic Dependency, Code Clone, Poor inheritance hierarchy, unnamed coupling. \citep{wong_detecting_2011}. DSM:n käyttö. 

\subsection{Arkkitehtuuriset hajut}

Mittareiden ohella arkkitehtuurisiin hajuihin on alettu kinnittää yhä enemmän huomiota ohjelmien monimutkaistuessa ja suunnittelun tulevan yhä tärkeämmäksi osaksi ohjelmistojen elinkaarta. Ne ovat sukua tutummalle käsitteelle koodihaju, mutta tulevat esille arkkitehtuurisella tasolla, kun koodihajut tulevat esille luokkatasolla. Arkkitehtuuriset hajut ovat pääosin suunnittelupäätöksiä, jotka negatiivisesti vaikuttavat järjestelmän elinkaareen ja muunmuassa testattavuuten sekä ylläpidettävyyteen negatiivisesti. Niitä ei voi pitää välttämättä virheinä, mutta ne vaikuttavat vähintään aina negatiivisesti laatuun \citep{de_andrade_architectural_2014}. Syitä arkkitehtuurisille hajuille voidaan nähdä olevan muunmuassa 

\begin{itemize}
	\item suunnittelumalli väärässä kontekstissa
	\item suunnitteluabstrahoinnin (design abstraction) käyttö niin, että sillä on ei-toivottuja vaikutuksia
	\item suunnitteluabstrahoinnin käyttö väärällä tarkkuuden tasolla 
\end{itemize} 

%Testattavuus \citep{garcia_identifying_2009} yleisesti \citep{bertran_detecting_2011}.

Yleisesti arkkitehtuuriin vaikuttavia hajuja voidaan löytää arkkitehtuurisella tasolla seuraavien metriikoiden avulla \citep[s. 1093]{bertran_detecting_2011}

\begin{itemize}
	\item ei-haluttujen asiakas-komponenttien (client component) määrä
	\item komponentin vastuiden määrä
	\item komponentin konnektoreiden määrä
	\item komponentin erilaisten konnektoreiden määrä
	\item komponenttien välinen riippuvuuksien hajauma.
\end{itemize}

%\citep{HotSpot} arkkitehtuuriset hajut "hotspotit"\ 5kpl + kaikista altin virheille oli \citep[s. 57]{HotSpot} Unstable Interface \& Cross-Module Cycle.

\noindent
Näiden metriikoiden avulla sekä näkymällä moduulitasoon, olisi esimerkiksi hyvin mahdollistaa löytää yksi virhealttiillisin arkkitehtuurista löytyvä ongelmakohta \citep[s. 57]{HotSpot} \textit{Cross-Module Cycle}. \textit{Cross-Module Cycle} johtuu, jos on olemassa syklinen riippuvuussuhde moduulitasolla.


Itse arkkitehtuurisia hajuja, jotka vaikuttavat suoraan testattavuuteen voidaan tunnistaa olevan ainakin \citep{garcia_identifying_2009}

\begin{itemize}
	\item \textit{Connector Envy}
	\item \textit{Scattered Parasitic Functionality}.
\end{itemize}

\noindent
\textit{Connector envy} on tilanne, jossa komponentti toteuttaa konnektorille kuuluvaa toiminnallisuutta eli toteuttaa esimerkiksi joko kommunikointia, koordinointia tai tiedon konversiota. Nämä tulisi jättää konnektorin toteutettavaksi, koska komponentin toiminnallisuus ja interaktiot eivät ole enää erillään testattavia ominaisuuksia. Tämä tilanne johtaa siihen, että ei pystytä enää varmasti sanomaan, että mikä kohta komponentissa oli virheellinen, jos se testauksen aikana tuli esille. \textit{Scattered Parasitic Functionality} taas johtuu, jos useammalla komponentilla on sama vastuu ja ne ovat vastuussa myös jostain muusta vastuusta. Testattavuus kärsii tästä, koska esimerkiksi integraatiotestauksen aikana tapahtunut virheen havaitseminen vaikuttaa laajalla alueella ja vaikeuttaa vian alkuperän määrittämistä. 

% Connector envyn havaitseminen jne. 

Architecture sensitive analysis (code metrics) \citep[s. 185]{macia_enhancing_2013} $\rightarrow$ God Classes were related to Connector Envy, Scattered Functionality. Misplaced Class were related to Cyclic Dependencies, Scattered Functionality.


Arkkitehtuurisia hajuja + Hybridi hajuja (koodi ja arkk.) ohjelmistojen product lineissa \citep{vale_bad_2014}

Tietyt koodihajut voivat olla merkki arkkitehtuuristen hajujen olemassaolosta (aspect oriented architecture + should be others too) \citep[s. 47]{macia_impact_2011}. SPF -> CB (Composition Bloat), GA (God Aspect related to God Class/God Interface), GP (God Pointcut), DP (Duplicate Pointcut). CEn -> GP. 


Koodi ja arkkitehtuuri-info. Detection strategies \citep[s. 179-182]{macia_enhancing_2013}


Koodihajujen tunnistaminen arkkitehtuurisen degraation tunnistamiseksi \citep{fontana_towards_2015}. Vaikuttavat ylläpidettävyyteen. God Class, Data Class, Brain Method, Shotgun Surgery, Dispersed Coupling, Message Chains. Metriikoina käytettiin muunmuassa: Tight Class Cohesion, Access to Foreign Data, Number of Public Attributes, Maximum Nesting Level, Coupling Intensity. Co-Occurence of smells. "Code Smells Relation View" diagrammi \citep[s. 5]{fontana_towards_2015}. Koodihajut vaikeuttavat Coupling on kaikki, koodihajut vaikeuttavat koheesiota on GC, BM, DC. 




%Software Product Line Arch. smells -> \citep{de_andrade_architectural_2014}. Maintainability. Case: Notepad SPL. Komponenttimalli + arkkitehtuurin malli. \textbf{1} testability connector envy: Combining product construction capabilities and connector responsibilities represent a reduction in testability because application functionalities and interaction functionalities cannot be seperately tested. \textbf{2}: Ambiguous interfaces 1kpl. \textbf{3}: Feature Concentration -> paljon toiminnallisuutta yhteen komponenttiin sidottuna -> vaikeuttaa maintainability.  



\subsection{Sunnittelumallien vaikutus testaukseen}

Mitä on? Miten vaikuttaa rakenteeseen? Mitä  hyötyä? \citep{baudry_measuring_2003}.


Composition-patternin analyysi -> kansio sisältää useita tiedostoja ja kansioita -> sykli. Voidaan helpottaa lisäämällä rajoite (constraint) tai rajapinta mielummin kuin abstraktiluokka. 

Vaikeita patterneita testata: Mediator (similar to Observer) \& Visitor.

\subsection{UML uusien näkymien tukena}

%UML + graph model to compute all possible anti-patterns that affect testability \citep{baudry_testability_2002}.

UML-kaavio ei itsessään riitä näyttämään kaikkia testattavuuden kannalta tärkeitä näkökulmia arkkitehtuurisella tasolla, mutta sen tueksi on luotu useita menetelmiä, jotka hyödyntävät esimerkiksi jo valmista UML-luokkakaaviota. Eräs näistä on \textit{class dependency graph model} \citep[s. 4]{baudry_testability_2002}. Sen avulla on mahdollista nähdä 

\begin{itemize}
	\item luokkien välistä suurta interaktiota
	\item itsekäyttöä
	\item interaktioiden kompleksisuutta
	\item pitkiä luokkahierarkisia haaraumia
	\item kompleksisia rajapinta periytymiä.
\end{itemize}

%UML:n parantaminen uusilla notaatioilla \citep[s. 4]{baudry_measuring_2003}. \textbf{create}  luokka A luo luokan B, \textbf{use}  luokka A voi kutsua mitä tahansa, paitsi B:n konstruktoria. \textbf{use\_consult}  kutsumat metodit, jotka eivät koskaan muokkaa B:n sisäistä tilaa, \textbf{use\_def} -> jos vähintään yksi metodi muokkaa B:n tilaa.


Tämä tuottaa tosin ongelmia, koska jotkut tulokset saattavat olla vääriä niiden sisältäessä virheellistä esiintymää (false-positive results). Tähän ongelmaan on ehdotettu UML-kaavion jatkamista stereotyyppien avulla. Uusia kytköksiä määritellään 4 kappaletta \citep[s. 4]{baudry_measuring_2003}

\begin{itemize}
	\item create, jos luokka A luo luokan B
	\item use, jos luokka A voi kutsua kaikkia B:n metodeja, muttei luo sitä
	\item use\_consult, jos A:n kutsumat metodit eivät muokkaa B:n sisäistä tilaa
	\item use\_def, jos yksikin A:n kutsuma metodi muokkaa B:n sisäistä tilaa
\end{itemize}

\noindent
Näiden avulla saadaan riippuvuudet ja niiden tyypit paremmin esille kaavioissa. 





\section{Pohdinta}

Metriikat + riippuvuusgraph.

Muita keinoja tutkia -> formulointi (Design Structure Matrix) \citep{mo_mapping_2013}

Erilaisia skenaariopohjaisia menetelmiä ehdottaa \citep[s. 8-9]{mattsson2006software} testattavuuden kannalta: SAAM, ATAM, EBAE.

Riippuvuuksien anti-pattern (7 kpl) ja niiden havaitseminen lähdekoodin avulla. Pystyisikö soveltamaan myös arkkitehtuurisella tasolla? \citep{binkley_dependence_2008} 

\section{Yhteenveto}
"puoli sivua"

Yleensä hieman johdantoa lyhyempi.

Muistuttaa mieleen tutkimuskysymyksen, mainitsee tärkeimmät tulokset ja niiden perusteet. Keskittyy impaktiin ja esimerkiksi suosituksiin. Ei vain summeeraa luku kerrallaan aikaisempaa tekstiä.



% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

%\bibliographystyle{babalpha-lf}
\bibliographystyle{apsr}
\bibliography{references-fi}


% --- Appendices ---

% uncomment the following

% \newpage
% \appendix
% 
% \section{Esimerkkiliite}

\end{document}
