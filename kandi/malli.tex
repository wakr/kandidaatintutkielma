% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage[sort]{natbib} %uncomment for a harvard-style
%\usepackage[square,sort,comma,numbers]{natbib}


% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:


% testattavuus & arkkitehtuuri
\title{Testattavuuden ilmeneminen ohjelmistoarkkitehtuurissa}
\author{Kristian Wahlroos}
\date{\today}
\level{Kandidaatintutkielma}

\abstract{tiivistelmä (100-200 sanaa; kenelle, miksi, millaisessa ympäristössä; tutkimuskysymys; tulokset; impakti)}

% The following can be used to specify keywords and classification of the paper:

\keywords{ohjelmistoarkkitehtuuri, testattavuus, näkymä}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):"
% \classification{}
% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
%\numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}

% Write some science here.

%Esimerkkilause ja lähdeviite~\cite{esimerkki} ja \cite{esimerkki2}.
%jäsennelty asianmukaisesti (kenelle, miksi, millaisessa ympäristössä; ratkaisun lähestymistapa; tutkimuskysymys, tulokset ja impakti; loppulukujen roolitus).




%\section{Johdanto}
%purkaa auki teknisemmälle yleisölle samalla käsitteitä määritellen tutkimuskysymyksen, ratkaisuille ympäristöstä esiintulevat vaatimukset ja keskeiset käsitteet näiden asioiden esittelemiseksi.

%antaa riittävästi termistöä ja kysymyksenasetteluja, jotta myöhempänä teksissä on mahdollisuus analyysiin ja evaluointiin.
%Keskimmäiset luvut keskittyvät kukin "opettamaan" lukijalle yhden osakysymyksen tai näkökulman käsiteltävään asiaan. Lukujen työnjaon tulisi olla selkeä ja niillä tulee olla selkeä oma rakenteensa, jonka valintaperuste on lukijalle kerrottu.

%Viimeistä edellinen luku on varsinaisen kontribuution koti: vertailu, soveltaminen, osien synteesi ja mahdolliset evaluointimenetelmät ja -tulokset pääroolissa.

Ohjelmistoarkkitehtuuri on ohjelmistojen ymmärtämisen kannalta tärkeä konsepti, josta jokaisen ohjelmoijan pitäisi olla tietoinen, sillä jokaisella ohjelmistojärjestelmällä on oma arkkitehtuurinsa \citep[s. 4]{ieee_2000}. Suunnittelematon arkkitehtuuri eli niin sanottu \textit{Big Ball of Mud} saattaa pahimmassa tapauksessa olla yksi epäonnistuneen projektin tunnusmerkkejä, kun taas hyvin muodostettu arkkitehtuuri auttaa eri sidosryhmien välisessä kommunikaatiossa, tekee tuotettavasta ohjelmistojärjestelmästä helposti lähestyttävän, helpottaa ohjelmiston testausta sekä validointia ja on yksi suurimmista onnistumistekijöistä projektin jatkon kannalta. 

Ohjelmistojen ylläpidettävyys lasketaan yhdeksi ei-toiminnalliseksi laatuvaatimukseksi ja siihen kuuluu vahvasti ohjelmistojen testattavuus, joka taas vaatimuksena on lähempänä ohjelmoijaa, kuin asiakasta. Testausta tapahtuu ohjelmistojärjestelmän elinaikana useita kertoja, joista  aikaisimmat jo projektin alkumetreillä, kun halutaan evaluoida järjestelmän toiminnallisuutta. Testattavuus taas määrittelee, että kuinka helppoa järjestelmää on ylipäätänsä testata. Kuitenkin arkkitehtuurin ja testattavuuden yhteys on hieman häilyvä, vaikka arkkitehtuuri koskee jokaista kehittäjää. Tämä tutkimus pyrkii selventämään arkkitehtuurin ja testattavuuden suhdetta ja sitä, miten testattavuus tulee ilmi ohjelmistoarkkitehtuurissa. 

\subsection{Tutkimuskysymys}
Tutkimus vastaa kysymykseen \textit{miten testattavuus näkyy ohjelmistojen arkkitehtuurissa}. Itse kysymys voidaan jakaa vielä tarkentaviin kysymyksiin: \textit{mitä on testattavuus ohjelmistojärjestelmissä, miten arkkitehtuuria voidaan kuvata, miten arkkitehtuurista luotu näkymä kertoo jotain järjestelmän testattavuudesta}. 

\subsection{Tutkimusmenetelmä}
Tutkimuskysymykseen vastataan kirjallisuuskatsauksen avulla ja tutkimalla, että mitkä arkkitehtuuriset päätökset ja elementit ovat hyvän testattavuuden tekijöitä. Hyvän testattavuuden havaitsemiseen etsitään näkymää nykyisistä menetelmistä kuvata arkkitehtuuria. Näitä menetelmiä ovat pääasiassa erilaisten näkymien ja näkökulmien joukko, joista tässä tutkimuksessa pyritään etsimään kehittäjän näkökulmasta kaikista relevantein kokoelma.

\subsection{Rajaus}

Tutkimuksessa keskitytään pääosin ainoastaan oliopohjaisen arkkitehtuurin kuvaamiseen ja sen yleisimpiin käytänteisiin. Testaustavoista on keskitytty yksikkö -ja hyväksymistesteihin. Arkkitehtuurin mallintamisesta on jätetty ADL:t (architecture description languages) pois.

\subsection{Tutkimuksen rakenne}

Kappaleessa 2 käydään läpi ohjelmistoarkkitehtuuria käsitteenä ja luodaan pohja eri kuvaustavoille ohjelmistoarkkitehtuuria varten. Samalla kuvataan, että miten ja mistä näkymä voidaan luoda ohjelmistojärjestelmälle. Kappale 3 keskittyy ohjelmistolle asetettaviin laadullisiin vaatimuksiin, joista kappale 4 tarkentaa testattavuutta. Kappale 5 etsii arkkitehtuurin ja testattavuuden välistä suhdetta ja viimeinen kappale keskittyy testattavuuden parantamiseen arkkitehtuurin avulla.


\section{Ohjelmistoarkkitehtuuri}
Arkkitehtuuri ohjelmistoissa on käsite, josta moni kehittäjä on tietoinen mutta joka ei ole kovin yksiselitteinen eikä siitä ole yksimielisiä määritelmää \citep[s. 363]{solms_what_2012}. 
Se kuvaa kuitenkin vähintään aina abstraktilla tasolla toteutettavaa ohjelmistojärjestelmää niin, että on mahdollista keskittyä vain suppeaan alueeseen jättämällä pois eri sidosryhmien kannalta epärelevantteja asioita. Kuvaus tapahtuu usein visuaalisella tavalla, koska visuaalisesta mallista on nopea ja helppo saada ulos tarvittava informaatio.   

\subsection{Ohjelmistojen arkkitehtuuri käsitteenä}
Ohjelmistoarkkitehtuuri voidaan nähdä karkeasti neljästä eri näkökulmasta  \citep[s. 2-7]{gorton_understanding_2011}:  ohjelmiston rakenteen kuvaajana, kuvaajana ohjelmiston komponenttien välisille suhteille, mallina joka ottaa huomioon ei-toiminnalliset (non-functional) vaatimukset ja yleisenä abstraktiona. 
% kappaleessa selitetään myös riippuvuuksien vähentämisestä

Rakenteen kuvaajana arkkitehtuuri määrittelee ohjelmistojärjestelmän sisäistä rakennetta, joka koostuu useista komponenteista sekä moduuleista, jotka yhdistävät ja ryhmittelet komponentteja. Erilaiset moduulit tarjoavat aina tietyn toiminnallisuuden ja tämän kautta erilaiset vastuut on jaettu ohjelmistojärjestelmän sisällä loogiisiin kokoelmiin.
% kappaleessa myös patterneja

Komponenttien välisen kommunikaation mallintaminen tapahtuu, kun ohjelmistojärjestelmää jaetaan erilaisiin komponentteihin. Tavoitteena on kertoa mallintamalla, että mitkä komponentit tai moduulit ovat vuorovaikutuksessa toistensa kanssa ja millä tavoin. Yleisin kommunikaatiotapa on esimerkiksi suorat funktiokutsut komponenttien välillä, joiden mallinnus selventää esimerkiksi informaation kulkua järjestelmässä.  
% kappaleessa ei-toiminnallisten vaatimuksien jako kolmeen eri luokkaan

Ei-toiminnaliset vaatimukset tulevat kunnolla esille vasta arkkitehtuurin avulla ja arkkitehtuurin mallinnuksen avulla voidaan määrittää miten ohjelma suorittaa sille määrättyä tehtävää sen sijasta, että mallinnettaisiin ainoastaan mitä ohjelma tekee. 
% lähteitä lisää?

Arkkitehtuurin avulla on mahdollista abstrahoida
sidosryhmille ohjelmistojärjestelmää helpommin lähestyttäväksi, jolloin kommunikaatio eri osapuolten välillä helpottuu. Abstrahoinnin avulla pystytään yksinkertaistamaan järjestelmän konkreettista toteutusta ja suorittamaan arkkitehtuurista erittelyä (architectural decomposition), jossa muodostetaan epärelevanteista komponenteista mustia laatikoita (black boxes). Mustien laatikoiden ideana on piilottaa komponenttien sisäistä toteutusta eri abstraktiotasoilla, jolloin arkkitehtuurista voidaan muodostaa eri tarkkuustason malleja. 
\\

Hieman samanlainen jaottelu on määritelty myös Solmsin tutkimuksessa \citep[s. 368-369]{solms_what_2012}. Siinä ohjelmistoarkkitehtuuri-määritelmä jaetaan kolmeen eri luokkaan: korkean tason abstraktioon ohjelmistojärjestelmästä, rakenteita sekä ulkoisia ominaisuuksia korostavaan määritelmään ja käsitteistöön sekä rajoitteisiin joiden puitteissa ohjelmistojärjestelmää kehitetään. 

Näistä kaksi ensimmäistä määritelmää vastaavat samoja kuin \citep[s. 2-7]{gorton_understanding_2011}, mutta tarkentaen kumpaakin omat kuvaustavat. Korkean tason abstraktioita mallinnetaan erilaisten näkymien kautta tai käyttämällä IEEE:n määrittelemiä käytänneitä \citep[s. 4-5]{ieee_2000}. % IEEE:stä voisi kirjoittaa enemmän    
Rakenteita korostettaessa mallinnuksessa käytetään usein UML-kaavioita, koska UML määrittelee ohjelmiston arkkitehtuuria osina, joita pystytään rekursiivisesti tarkentamaan haluttaessa. Tarkennuksen avulla osat pystytään kuvaamaan kommunikoivan keskenään erilaisten rajapintojen kautta, osia yhdistäviä suhteita pystytään tarkastelemaan ja erilaisia rajoitteita pystytään luomaan osien välille. 
% järjestelmien välinen kommunikaatio se lähde.

Kolmas määritelmä on paljon laajempi näkemys ohjelmistoarkkitehtuurista, koska se kuvaa ohjelmistojärjestelmän käsitteistön ja ominaisuudet siinä ympäristössä, jossa ne ilmeentyvät elementtien, suhteiden ja suunnittelun periaatteiden kautta. Peruskäsitteistö tarjoaa sen käsitteistön, jonka avulla sovelluslogiikka voidaan määritellä. Esimerkiksi määrittelemällä, että jokin järjestelmä on tyypiltään palvelin, kun taas ominaisuudet liittyvät ohjelmistojärjestelmän laadullisiin ominaisuuksiin. Periaatteet voidaan nähdä järjestelmän keskeisinä suunnittelurajoitteina (core design constraints), joiden kokonaisuus muodostaa järjestelmän arkkitehtuurisen tyylin. Ohjelmistojärjestelmän arkkitehtuurin tyyli voi esimerkiksi olla väylät ja suodattimet (pipes and filters). % lisää
\\

Näistä kahdesta eri jaottelusta ohjelmistoarkkitehtuuriin voidaan nähdä merkittävinä tekijöinä tarpeen kuvata ohjelmiston rakenteellisuutta, komponenttien välistä kommunikaatiota ja laadullisia vaatimuksia. Kaikki nämä edellämainitut ominaisuudet on saatava  upotettua ohjelmistojärjestelmästä luotavaan arkkitehtuuriseen malliin niin, että ne vastaavat muunmuassa seuraaviin kysymyksiin \citep[s. 31 - 33]{Rozanski:2011:SSA:2072649}: mitkä ovat arkkitehtuurin toiminnalliset elementit; miten nämä elementit kommunikoivat keskenään ja ulkomaailman kanssa; mitä tietoa käsitellään, talletetaan ja esitetään; mitä fyysisiä ja ohjelmallisia elementtejä tarvitaan tukemaan näitä  elementtejä. Kuitenkaan arkkitehtuurista luotava malli ei saisi olla monoliittinen malli, joka pyrkii kuvamaan kaiken yhdessä mallissa, koska arkkitehtuuria ei ole mahdollista kuvata vain yhden mallin avulla \cite{Rozanski:2011:SSA:2072649}. Tämä johtuu siitä, että monoliittinen malli on erittäin vaikea ymmärtää jokaiselle osapuolelle, siitä on vaikeaa löytää arkkitehtuurin tärkeimmät ominaisuudet (features) ja se on usein puutteelinen, jäljessä eikä vastaa enää nykyistä ohjelmistojärjestelmää. Ratkaisu tähän on jakaa malli useisiin toisiinsa liittyviin näkymiin (views), jotka esittävät jokainen yhden näkökulman (viewpoint) järjestelmän arkkitehtuuriin keräämällä yhteen toiminnalliset piirteet sekä laadulliset ominaisuudet \citetext{\citealp[s. 33-34]{Rozanski:2011:SSA:2072649}; \citealp[s. 8-9]{gorton_understanding_2011}; \citealp[s. 117]{Ran:1998:ASV:288408.288438}}. Tämän avulla voidaan tarkastella saavuttaako järjestelmä sille asetetut tavoitteet.


\subsection{Arkkitehtuurin kuvaus}

Arkkitehtuurin kuvaaminen sallii kommunikoinnin eri sidosryhmien välille ja mahdollistaa järjestelmän tarkastelemisen vain niiltä osin, jotka tiettyä sidosryhmää kiinnostaa \citetext{\citealp[s. 329]{ARaHVeSCiSDu}; \citealp[s. 60]{Brondum:2010:TAV:1833335.1833344}}. Kuvaaminen tapahtuu näkymien avulla, jotka auttavat erottelemaan (separation of concerns) arkkitehtuuria pienempiin palasiin \citep[s. 2]{Galster:2011:DTC:2031759.2031761}. Itse näkymät luodaan taas käyttämällä ennaltamäärättyjä näkökulmia, jotka edustavat tiettyä tai useampaa sidosryhmälle tärkeää asiaa. 

Hyvä kommunikointi sidosryhmien kanssa on aina tärkeää, joista ääripäinä ovat kehittäjät ja asiakkaat. Kehittäjät haluavat usein todella tarkkaa usean eri tason ja näkökulman abstraktia kuvausta luotavasta järjestelmästä \citep[s. 120]{Ran:1998:ASV:288408.288438} tai ymmärtääkseen jo valmiiksi luotua järjestelmää \cite{ARaHVeSCiSDu}, kun taas asiakkaat haluavat nähdä järjestelmän toiminnallisuuden juuri heitä koskevien asioiden kannalta ja usein mahdollisimman korkealla tasolla.

\subsubsection{Näkymät}
Arkkitehtuuristen näkymien tehtävänä on kuvata ne näkökulmat arkkitehtuurista, jotka ovat merkityksellisiä itse asialle, jota näkymä haluaa painottaa \citetext{\citealp[s. 34]{Rozanski:2011:SSA:2072649}; \citealp[s. 15]{may2005survey}}. Yksi tunnetuimmista määritelmistä arkkitehtuuriselle näkymälle on Krutchenin 4+1 näkymämalli (4+1 View Model) \citep[s.7-8]{gorton_understanding_2011}. 

4+1 -mallissa arkkitehtuuri kuvataan neljän näkymän avulla: looginen, prosessi, fyysinen ja kehitys. Looginen näkymä kuvailee esimerkiksi luokkakaavioiden avulla ohjelmistojärjestelmän elementtejä ja niiden välisiä suhteita tarkentaen järjestelmän rakennetta, prosessinäkymä keskittyy ajonaikaisen suorituksen kuvaamiseen tarkentamalla muunmuassa miten samanaikaisuuden hallinta tapahtuu järjestelmässä, fyysinen näkymä keskittyy siihen miten järjestelmän eri komponentit kuvautuvat fyysiselle laitteistolle jossa komponenttia ajetaan ja lopuksi kehitysnäkymä (development view) keskittyy järjestelmän sisäiseen toteutukseen tarkemmalla tasolla kuvailemalla sisäkkäisia pakkauksia tai luokkahierarkiaa. Jokainen näkymä voidaan liittää osaksi toista näkymää skenaarioiden avulla, jotka heijastelevat järjestelmälle asetettuja vaatimuksia, jolloin skenaariot voidaan nähdä ikäänkuin liimana muuten erillisille näkymille. 

Muita näkymämalleja arkkitehtuuriin on useita, joista jokainen kuitenkin tuo esille vähintään jollain tavalla ohjelmistojärjestelmän rakennetta ja yhteyksiä. Tästä esimerkkinä tunnettu \textit{Views and Beyond} -malli \citep[s.8]{gorton_understanding_2011}. Siinä arkkitehtuurinen malli kuvataan kolmella eri näkymällä: moduuli, joka on järjestelmän rakenteellinen näkymä kuvaten muunmuassa luokkia, pakkauksia, moduulien eriyttämistä (decomposition) sekä periytymistä; komponentti ja konnektori, joka kuvailee järjestelmän toiminnallista puolta sekä miten komponentit ovat yhteydessä toisiinsa; allokaatio, joka kuvailee miten prosessit kuvautuvat laitteistotasolla  ja miten ne kommunikoivat keskenään. 

Näiden kahden esitellyn mallin lisäksi on olemassa joukko eri tarkoituksiin sopivia näkymämalleja, joilla on omat vahvuutensa sekä heikkoutensa. Yhteensä viittä eri mallia vertailtiin Mayn tutkimuksessa \citep{may2005survey}, jossa kartoitettiin mahdollisimman laajaa näkymien muodostamaa näkökulmien joukkoa, jotka kattaisivat mahdollisimman laajalti ohjelmistoarkkitehtuurin aluetta (domain). Vertailtavat arkkitehtuurit olivat 4+1-malli, SEI:n (Software Engineering Institute) \textit{Views and Beyond}-malli, ISO:n (International Organization for Standardization) \textit{Reference Model of Open Distributed Processing}, Siemens'n \textit{Four View Model} ja \textit{Rational Architecture Description Specification}. Malleja vertailtiin tutkimalla, että kuinka niiden tarjoamat näkökulmat painottavat kolmeen eri kategoriaan liittyviä asioita: sidosryhmät, laadulliset tekijät ja rakenteelliset ominaisuudet. Joukko, joka painotti mahdollisimman laajasti jokaisen osa-alueen ominaisuuksia muodostettiin lopulta seuraavista osista: \textit{Views and Beyond} -mallin kaikki kolme näkymää ja \textit{Rational ADS}:n vaatimukset-näkökulma (requirements viewpoint). Syy miksi juuri nämä valittiin oli se, että \textit{Views and Beyond} sopii erittäin hyvin mallin pohjaksi, koska se kuvaa järjestelmän rakennetta kattavasti, sen näkökulmat ovat itsenäisiä ja se kokonaisuudessaan limittyy hyvin 4+1-mallin sekä Siemens'n mallin kanssa. Kuitenkaan se ei sisällä tarvittavia näkymiä kuvaamaan eri sidosryhmille tärkeitä asioita, kuten esimerkiksi loppukäyttäjiä varten oleva näkymä puuttuu kokonaan. Tämän takia mukaan on otettu \textit{Rational ADS}, jonka vaatimukset-näkökulma koostuu neljästä eri näkymästä: ei-toiminnalliset vaatimukset, alue (domain), käyttötapaus ja käyttökokemus. 



\subsubsection{Näkökulmat}
Rozanskin ja ym. \citep[s. 36-42]{Rozanski:2011:SSA:2072649} määrittelevät, että näkökulmat (viewpoints) liittyvät vahvasti arkkitehtuurisiin näkymiin. Näkökulma voidaan määritellä olevan kokoelma malleja (patterns), templaatteja sekä konventioita, joiden avulla näkymä pystytään rakentamaan.  Näkökulmien joukko voidaan taas jakaa seitsemään eri osaan: kontekstinen, funktionaalinen, informaatiollinen, samanaikaisuudellinen, kehittämisellinen, käyttöönotollinen ja operationaalinen. Näistä keskitytään tämän tutkimuksen myöhemmässä vaiheessa kehittämisen sekä funktionaalisuuden näkökulmaan. Kehittämisen näkökulmaan siksi, koska se ottaa huomieen niiden sidosryhmien asiat, jotka ovat mukana järjestelmän kehityksessä, testauksessa, ylläpidossa ja parantamisessa. Funktionaalinen näkökulma taas painottaa muunmuassa järjestelmän suorituksenaikaisia komponentteja sekä niiden rajapintoja.

% 4210 ISO
IEEE:n virallinen määritelmä näkokulmalle on \textit{a specification of the conventions for constructing and using a view. A pattern or template
from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis} \citep[s. 4]{ieee_2000}. Se on määritelmä, jota tullaan käyttämään myös tässä tutkimuksessa.




%onko testatavuus missäkin tapauksessa eri näkymien yli menevä vai voiko tai kannattaako sille jossain tilanteessa olla ihan oma näkymänsä, ja jos niin millainen se sitten olisi

\subsection{Näkymän luominen}

Ohjelmistoarkkitehtuuri toimii siltana ohjelmakoodin ja ohjelmalle asetettujen vaatimusten välillä \citep[s. 94]{Garlan:2000:SAR:336512.336537}, joten on luonnollista, että näkymä luodaan näiden pohjalta. Sitä luodessa on myös otettava huomioon kenelle näkymä on tarkoitettu, minkälaisia asioita halutaan näkymän painottavan ja millä abstraktiotasolla näkymän tulisi olla. 

Esimerkiksi ohjelmakoodin kautta luotava UML-malli saattaa olla näkymä projektin rakenteeseen uusia ohjelmoijia varten, jotta voitaisiin helposti esittää kyseisen ohjelmistojärjestelmän päärajapinnat. Tällaisen mallin päätarkoitus on kuvata ohjelmistojärjestelmän rakennetta, mutta abstrahoida pois kaikki turhan tarkat kuvaukset komponenteista, joilla ei ole juuri sillä hetkellä merkitystä. 

%Chapt. 7 & 8 + Arch views -paperi + What is an architectural description?
Jos järjestelmää ei ole vielä olemassa lainkaan, voidaan järjestelmän arkkitehtuuria lähteä ensin rakentamaan iteratiivisesti kolmen eri vaiheen kautta \citep[s. 97-115]{gorton_understanding_2011}: määritellään arkkitehtuuriset vaatimukset; luodaan rakenne, joka tukee näitä vaatimuksia; testataan, että rakenne tukee vaatimuksia. Arkkitehtuurille asetetut vaatimukset syntyvät toiminnallisten ja sidosryhmien asettamien vaatimusten tuloksena, koska ne yhdessä luovat tärkeimmät vaatimukset ja rajoitukset ohjelmistojärjestelmälle. Esimerkkinä järjestelmälle asetettavista vaatimuksista saattaa olla, että sen on pystyttävä tukemaan useita eri käyttöliittymiä. Tämä vaatimus voidaan taas ryhmittää tiettyyn laatuvaatimukseen, kuten useat muutkin järjestelmälle asetetut vaatimukset \citep[s. 117]{Ran:1998:ASV:288408.288438}. Tässä tapauksessa vaatimus ryhmitettäisiin muokattavuus-laatuvaatimuksen alle. Seuraavassa vaiheessa valitaan tätä laatuvaatimusta tukeva tyyli (architectural style), jota koko järjestelmä joutuu noudattamaan. Esimerkiksi N-tason -malli tukee muokattavuutta hyvin \citep[s. 103]{gorton_understanding_2011}. Tämän jälkeen järjestelmän keskeisimmät komponentit suunnitellaan ja sijoitetaan ne oikeisiin alueisiin, jotka valittu arkkitehtuurinen tyyli tuo tullessaan. Komponenttien väliset suhteet mallinnetaan pitämällä vastuut erillään, suhteet mahdollisimman vähäisinä sekä käyttämällä hyödyksi piilottamista (architectural decomposition). Lopuksi pystytään luomaan skenaarioita ja testaamaan niiden avulla, että onko luotu arkkitehtuuri sopiva. Komponenttien määrittely mahdollistaa arkkitehtuurin rakenteen kuvaamisen ja siten järjestelmästä on mahdollista luoda erilaisia näkymiä erilaisille sidosryhmille. Rakennetta pystytään kuvaamaan N-tason -mallin avulla erittäin korkealla tasolla, jos halutaan tuoda esille juurikin näkökulma muokattavuuteen, mutta myös matalemmalla tasolla, kun ohjelmistokehittäjä haluaa ymmärtää miten komponentit kommunikoivat keskenään.

\section{Ohjelmistojen laadulliset tekijät}

Miten voidaan jakaa? Miten tuodaan esille? 

\subsection{Laatuvaatimukset}
Keräys? Muodostus? Ryhmittely?
\subsubsection{Toiminnalliset}
\subsubsection{Ei-toiminnalliset vaatimukset}
\subsection{Tradeoffit}
\subsection{Arviointi}

\newpage

\section{Testattavuus laadullisena tekijänä}
Testattavuus luetaan kuuluvan ylläpidettävyyden alle \citep{ISO/IEC25010:2011} ja on täten yksi laatuvaatimuuksista. Kuitenkaan se laatuvaatimuksena ei esimerkiksi asiakkaalle ole edes aina kovin näkyvä, mutta ohjelmistokehittäjälle se tulee esille useassakin kontekstissa. Vaikeasti testattavaa järjestelmää on myös vaikea ylläpitää, ja ylläpidettävä järjestelmä on sekä asiakkaalle että kehittäjälle tärkeä ominaisuus.

% Yksikkö vs integraatio vs regressio testauksessa.
Ohjelmistojärjestelmään kohdistuva testaus voidaan jakaa moneen eri luokkaan, joista kaksi yleisintä ovat yksikkö -ja integraatiotestaus. Yksikkötestauksessa varmistetaan järjestelmän komponenttien toiminnallisuutta itsenäisesti, kun taas integraatiotestauksessa testaus kohdistuu järjestelmän rajapintoihin ja komponenttien yhteistoiminnallisuuteen. Testauksen voidaan nähdä siis löytän itse viat, mutta testattavuus paikat, joissa viat voivat sijaita \citep[s. 19]{Voas:1995:STN:624607.625469}. Testattavuus tukee täten testausta ja testausprosessia, koska sen avulla voidaan määritellä mikä on todennäköisyys sille, että järjestelmässä olevat viat löydetään \citep[s. 114]{voas_improving_1992}. 


\subsection{Testaamisen arviointi}

Testattavuuden arvioimisessa voidaan käyttää hyödyksi kolmea eri parametria \citep[s. 2]{baudry_measuring_2003}: havaittavuus (observability), hallittavuus (controllability) ja vaativuus, joka tarvitaan suorittamaan tietty testi. Havaittavuus määrittelee miten mahdollista testien tuloksia on tarkastella ja hallittavuus sitä, kuinka paljon testattavaan komponentin tilaan voidaan vaikuttaa. Havaittavuus voidaan myös nähdä arvona, joka kertoo kuinka helppo on määrittää, että vaikuttavatko tietyt syötteet testituloksiin ja hallittavuus sitä, että kuinka helppo on tuottaa jokin tietty tulos syötteestä \citep[s. 554]{Freedman:1991:TSC:126218.126229}. 

Domain-to-range indicates observability by comparing the size of the output range of a component to size of its input domain \citep[s. 2]{Jungmayr:2002} \citep{Freedman:1991:TSC:126218.126229}



\subsection{Hyvä testattavuus}

Hyvä testattavuus on järjestelmän laadulle hyvä ominaisuus \citep[s. 20]{Voas:1995:STN:624607.625469}. 

Isolating modules with high DDR \citep[s. 23]{Voas:1995:STN:624607.625469}.

Jo suunnitteluvaiheessa voidaan kiinnittää huomiota testattavuuteen ja näin parantaa itse testausprosessia. Decomposition, moduulien korkeat DRR (domain/range -ratio), korkean DRR:n omaavat moduulit mah. pieniksi ja eriytetyiksi, hyvä rajapinta joka paljastaa tarpeeksi moduulin sisäistä tilaa \citep[s. 117]{voas_improving_1992}.


Testattavan komponentin ominaisuudet: testitapaukset ovat pieniä ja helposti luotavia, testitapaukset eivät ole itseään toistavia, ongelmat on helppo jäljittää tiettyihin komponentteihin \citep[s. 554]{Freedman:1991:TSC:126218.126229}

\subsection{Huono testattavuus}

Tietyt ominaisuudet vaikuttavat yleisesti ohjelmistojärjestelmissä negatiivisesti testattavuuteen. Tiedon katoaminen on yksi näistä \citep[s. 20-22]{Voas:1995:STN:624607.625469} ja se voidaan jakaa implisiittisen ja eksplisiittisen tiedon katoamiseen. Implisiittisessä katoamisessa useat eri parametrit samaan kohteeseen tuottavat myös saman testituloksen ja eksplisiittisessä tiedon katoamisessa tietoa piilotetaan ulkoiselta näkymältä. Jälkimmäinen on hyvin yleinen tapa olio-ohjelmoinnissa ja liiallinen tiedon piilotus tuottaa vaikeuksia testauksessa, koska hallittavuus heikkenee. 

Ongelmat syötteiden ja tulosten tarkastelussa tiedon katoamisen johdosta johtavat helposti tarpeettomiin testeihin, joita on vaikea ymmärtää \citep[s. 554]{Freedman:1991:TSC:126218.126229} ja vaikeasti testattavan komponentin ominaisuuksiksi voidaankin määritellä sen sisältävän ulos- ja sisääntulo parametrien epäjohdonmukaisuuksia. Toisinsanoen vaikeasti testattava komponentti siis tuottaa eri tuloksia eri ajoilla, tai ei ikinä tuota haluttua tulosta.   




\subsection{Testattavuuden mittaaminen}

% Koskee UML-kaaviota -> Testability anti-patterns välttäminen (huono ratkaisu) suunnitteluvaiheessa\citep{baudry_measuring_2003}. \textbf{Jakaa} tämän kahtia: luokkien A ja B välinen interaktio jossa A:sta 2 tai useampi yhteys B:hen; itsekäyttö luokalla A on silloin, jos A:sta on yhteys itseensä. \textbf{Syitä}: suuri kytkentätaso, riippuvuuksissa syklejä, paljon mahdollisia vuorovaikuttavia komponentteja (viidakko). \textbf{Aiheuttaa}: vastuiden määrittely vaikeutuu ja testaus vaikeutuu, koska testicasejen määrittely vaikeutuu ja määrä kasvaa. \textbf{Estetään}: identifioimalla epäselvät suhteet.


Erilaisia testattavuuteen vaikuttavia mittareita on tutkittu paljon ja olio-pohjaisista järjestelmistä voidaan havaita seuraavat testaukseen vaikuttavat tekijät, joiden suuri arvo korreloi vahvasti huonoon testattavuuteen \citep[s. 5]{Dubey:2011:AMM:2020976.2020983}:

\begin{itemize}
	\item metodien määrä luokassa
	\item metodien määrä luokkahierarkiassa, jotka suoritetaan, kun luokan metodi suoritetaan
	\item luokkien määrä, johon luokalla on kytkentää
	\item periytymisaste
\end{itemize}

\noindent
Nämä tekijät ovat negatiivisia asioita testauksen kannalta, koska suuri metodien määrä on merkki luokan liiallisesta kompleksisuudesta ja se johtaa testauksen monimutkaistumiseen. Suuri kytkennän määrä vaikeuttaa luokan itsenäistä testaamista ja suuri periytymisaste tuo luokalle mahdollisesti paljon perittyjä metodeja, jotka on toteutettu jossain muualla, jolloin luokka on riippuvainen erittäin paljon muiden luokkien toteutuksista. 

% Testattavuuden mittareita lisää \citep{Bruntink:2004}.

Lisää testattavuuden mittareita yksikkötestauksen näkökulmasta on määritelty \citep[s. 9]{Bruntink:2004}. Siinä testitapausten kasvuun ja pituuteen vaikuttivat luokan: 

\begin{itemize}
	\item toisten luokkien määrä, joita luokka kutsuu tai jonka kenttiin se viittaa
	\item koko (rivien määrä)
	\item omien metodien määrä ja muiden luokkien metodien määrä, joita omat metodit käyttävät
\end{itemize} 

Nämä kaikki edellämainitut mittarit ovat ominaisuuksiltaan sellaisia, joita voidaan suurimmaksi osaksi mitata vain lähdekoodin avulla. Usein ohjelmistokehittäjät joutuvat tilanteisiin, joissa ainoa järkevä näkymä järjestelmään on abstraktilla tasolla oleva luokkakaavio.

\subsection{UML-kaavio testattavuuden tukemisessa}

UML-luokkakaavio on todella yleisesti käytössä oleva ja juuri sen avulla nähdään hyvin järjestelmän rakennetta. Se toimii hyvänä pohjana, kun halutaan mitata luokkien välisiä suhteita ja riippuvuuksia \citep[s. ]{baudry_testability_2002}. \citep[s. 3]{baudry_measuring_2003} määritteleekin testattavuuden anti-mallin (testability anti-pattern) luokkakaavioiden avulla. Anti-mallissa testattavuuteen negatiivisesti vaikuttaa kaksi suurta tekijää: luokkien välinen suuri interaktio ja itsekäyttö, jossa luokka on riippuvainen rekursiivisesti itsestään. Syitä näiden kahden esiintymiselle voi olla luokkien välinen suuri kytkentätaso, riippuvuuksien syklimäisyys ja komponenttien välinen suuri kommunikaatiotaso. Yhdessä nämä tekijät vaikeuttavat paljon vastuiden jakamista ja kasvattavat tarvittavien testitapausten määrää. 

% UML \citep{baudry_testability_2002}

UML-kaaviosta on mahdollista nähdä erilaisia asioita, kuin suoraan lähdekoodista. UML:n luokkakaavio toimiessa abstraktiivisena näkymänä suoraan lähdekoodiin, se tuo hieman korkeamman tason näkymän järjestelmään, mutta ilman liiallista tiedon piilottamista. Asioita, joita voidaan havaita UML:n avulla ja luokkakaaviosta luotavalla riippuvuusgraafilla esittää \citep{baudry_testability_2002}:

\begin{itemize} 
	\item kompleksiset perintäsuhteet
	\item abstraktien luokkien käyttö rajapintojen sijasta
\end{itemize}


% Class Dependency Graph from UML?

% Test critical dependencies
%Testi-kriittiset riippuvuudet \citep{Jungmayr:2002}.

Näiden lisäksi \citep{Jungmayr:2002} käsittelee testauksen kannalta kriittisten riippuvuuksien poistoa. 





%\subsection{Design for testability}

%Järjestelmä voidaan suunnitella tukemaan hyvää testattavuutta \citep[s. 20]{Voas:1995:STN:624607.625469}. 

\subsection{Testattavuuden merkitys}
% Mitä huono testattavuus voi tarkoittaa järjestelmän kannalta?
Huono testattavuus voi tarkoittaa järjestelmän kannalta ylläpidettävyyden huononemista ja täten aiheuttaa jatkuvaa ongelmaa kehityksen kannalta, koska testaus on usein tapahtuvaa toimintaa, jonka tarkoituksena on löytää vikoja järjestelmästä. Myöhäisessä vaiheessa löydetty vika saattaa tulla erittäin kalliiksi ja viedä pois useita työtunteja, jotka olisi pystytty käyttämään johonkin tuottavampaan tekemiseen, jos vaikeasti testattava järjestelmä ei olisi ongelman löytämistä hidastanut.


\section{Arkkitehtuurin vaikutus testattavuuteen}
%Modulaarisuus, mah. vähän riippuvuuksia. Miten tulee esille arkkitehtuurin kuvauksissa? Näkymät?

Testattavuus tulee esille arkkitehtuurisella tasolla hieman erilailla, kun ohjelmakooditasolla. Arkkitehtuurisella tasolla testattavuus vaikuttaa laajemmin ja sitä tutkitaan komponenttitasolla, jota tukee erittäin hyvin UML-kaaviot, joiden avulla ohjelmistojärjestelmän rakenne saadaan kuvattua. 
\\

Mikä tekee yhdestä arkkitehtuurista testattavamman, kuin toisen? -> Tyylien käyttö parantaa testattavuutta, \citep{Eickelmann:1996:MOS:243327.243602} 

Testattavuus tulee ilmi korkealla tasolla integraatiotestauksessa \citep{Eickelmann:1996:MOS:243327.243602} -> komponenttien rajapintojen toimivuus, miten komponetit antavat datan ja kontrollin eteenpäin.

Kolmentyyppisiä kriittisiä moduuleita: tehtävä, turvallisuus ja pääsykriittiset moduulit \citep{Eickelmann:1996:MOS:243327.243602}. Arkkitehtuurisellakin tasolla nämä pitäisi pitää erillään muista moduuleista.

\subsubsection{Metrics for maintainability}

% Kuuluu ehkä paremmin arkkitehtuurin alle

Ylläpidettävyyttä voidaan mitata arkkitehtuurisella tasolla analysoimalla näkymää, josta nähdään esimerkiksi UML-rakennekaavion avulla järjestelmän rakennetta. Sitä voidaan mitata arkkitehtuurisista elementeistä seuraavien mittarien avulla \citep[s. 3]{bengtsson1998towards}: metodien määrä elementin rajapinnassa; paikkamerkkien (placeholder) määrä arkkitehtuurisille elementeille, joiden avulla elementti parametrisoidaan; elementtien välisten viestien määrä; elementtityyppien määrä, joita tarkasteltava elementti toteuttaa (implement); elementtien määrä, mitkä toteuttavat tarkasteltavan elementin tyypin; saatavilla olevien metodien lukumäärä muista elementeistä, jotka ovat yhteydessä tarkasteltavaan elementtiin; elementin metodien ja parametrien määrä. 

Mittaaminen on mahdollista tehdä ilman lähdekoodia, jos näkymä on jo valmiiksi luotu. Näkymän avulla voidaan tuoda ongelmakohtia esille ohjelmistojärjestelmässä, koska moni metriikoista määrittää järjestelmän sisäistä riippuvuusastetta ja mitä suurempi aste on, sitä suurempi on mahdollisuus, ettei järjestelmä oli kovin ylläpidettävä.


\subsection{Hyvä testattavuus arkkitehtuurissa?}

Testattavuuden parantaminen erillisen patternin avulla \citep{coelho_improving_2005}. 

Tietyt arkkitehtuuriset tyylit sopivat tiettyihin testaustapoihin (critical module, sandwich, top-down, bottom-up, thread, big bang) \citep{Eickelmann:1996:MOS:243327.243602}. Kolmeen ensimmäiseen liittyvät vahvasti stubit ja test driverit. 

-> tyylin tunnistaminen?

\subsection{Sunnittelumallien vaikutus testaukseen}

Mitä on? Miten vaikuttaa rakenteeseen? Mitä  hyötyä? \citep{baudry_measuring_2003}.

Composition-patternin analyysi -> kansio sisältää useita tiedostoja ja kansioita -> sykli. Voidaan helpottaa lisäämällä rajoite (constraint) tai rajapinta mielummin kuin abstraktiluokka. 

Vaikeita patterneita testata: Mediator (similar to Observer) \& Visitor.

\subsection{UML}

UML + graph model to compute all possible anti-patterns that affect testability \citep{baudry_testability_2002}.

UML:n parantaminen uusilla notaatioilla \citep[s. 4]{baudry_measuring_2003}. \textbf{create}  luokka A luo luokan B, \textbf{use}  luokka A voi kutsua mitä tahansa, paitsi B:n konstruktoria. \textbf{use\_consult}  kutsumat metodit, jotka eivät koskaan muokkaa B:n sisäistä tilaa, \textbf{use\_def} -> jos vähintään yksi metodi muokkaa B:n tilaa.




\subsection{Arkkitehtuuriset hajut}

Arkkitehtuuriset suunnittelupäätökset, jotka negatiivisesti vaikuttavat järjestelmän elinkaareen ja muunmuassa testattavuuteen sekä ylläpidettävyyteen. Hajut eivät ole virheitä vaan vaikuttavat negatiivisesti laatuun \citep[s. 1]{de_andrade_architectural_2014}. Arkkitehtuuriset hajut eroavat koodihajuista abstraktiotasolla. Syitä arkkitehtuurisille hajuille on \citep[s. 2]{de_andrade_architectural_2014}: suunnittelumalli väärässä kontekstissa; design abstractions käyttö niin, että niillä on ei-haluttuja vaikutuksia; design abstractions käyttö väärällä rakeisuuden (granularity) tasolla. 

Testattavuus \citep{garcia_identifying_2009} yleisesti \citep{bertran_detecting_2011}.

\citep{HotSpot} arkkitehtuuriset hajut "hotspotit"\ 5kpl + kaikista altin virheille oli \citep[s. 57]{HotSpot} Unstable Interface \& Cross-Module Cycle.

Software Product Line Arch. smells -> \citep{de_andrade_architectural_2014}. Maintainability. Case: Notepad SPL. Komponenttimalli + arkkitehtuurin malli. \textbf{1} testability connector envy: Combining product construction capabilities and connector responsibilities represent a reduction in testability because application functionalities and interaction functionalities cannot be seperately tested. \textbf{2}: Ambiguous interfaces 1kpl. \textbf{3}: Feature Concentration -> paljon toiminnallisuutta yhteen komponenttiin sidottuna -> vaikeuttaa maintainability.  

Viisi hajua (4 + 1 for spl) \citep{garcia_toward_2009}: Connector envy (komponenteilla liikaa toiminnallisuutte suhteissa niiden konnektoreihin), Scattered Parasitic Functionality (korkean tason asia jaettu usealle eri komponentille -> väh. yhdellä komponentilla useita vastuita, komponentit tässä riippuvaisia toisistaan), Ambiguous Interfaces (komponentti tarjoaa vain yhden geneerisen sisääntulopisteen [entry-point]), Extraneous Adjacent Connector (kaksi eri tyypin konnektoria yhdistää kaksi komponenttia toisiinsa), Feature Concentration (SPL). 



\section{Pohdinta}

\section{Yhteenveto}
"puoli sivua"

Yleensä hieman johdantoa lyhyempi.

Muistuttaa mieleen tutkimuskysymyksen, mainitsee tärkeimmät tulokset ja niiden perusteet. Keskittyy impaktiin ja esimerkiksi suosituksiin. Ei vain summeeraa luku kerrallaan aikaisempaa tekstiä.



% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

%\bibliographystyle{babalpha-lf}
\bibliographystyle{apsr}
\bibliography{references-fi}


% --- Appendices ---

% uncomment the following

% \newpage
% \appendix
% 
% \section{Esimerkkiliite}

\end{document}
